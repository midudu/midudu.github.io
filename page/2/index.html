
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Midudu&#39;s Home</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Tech Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Midudu&#39;s Home">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Midudu&#39;s Home">
<meta property="og:description" content="Tech Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Midudu">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="Midudu&#39;s Home" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
<link rel="stylesheet" href="/css/style.css">

  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
<meta name="generator" content="Hexo 4.2.0"></head>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Midudu&#39;s Home</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="yoursite.com">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main">
  
    <article id="post-Redis源码阅读1_数据结构_sds" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB1_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_sds/" class="article-date">
  <time datetime="2020-03-11T12:10:26.585Z" itemprop="datePublished">2020-03-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/">开源组件</a>►<a class="article-category-link" href="/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/">Redis</a>►<a class="article-category-link" href="/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/">源码阅读</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB1_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_sds/">Redis 源码阅读1_数据结构_sds</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>简单动态字符串 sds</p>
<ul>
<li><a href="#%e6%b6%89%e5%8f%8a%e6%96%87%e4%bb%b6">涉及文件</a></li>
<li><a href="#%e7%bb%93%e6%9e%84%e4%bd%93">结构体</a></li>
<li><a href="#api">API</a></li>
<li><a href="#sds-sdsnewconst-char-init">sds sdsnew(const char *init);</a></li>
<li><a href="#sds-sdscatsds-s-const-char-t">sds sdscat(sds s, const char *t);</a></li>
<li><a href="#void-sdsclearsds-s">void sdsclear(sds s);</a></li>
</ul>
<h2 id="涉及文件"><a href="#涉及文件" class="headerlink" title="涉及文件"></a>涉及文件</h2><p><code>sds.h</code> 和 <code>sds.c</code></p>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 保存字符串对象的结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf 中已占用空间的长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf 中剩余可用空间的长度</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据空间</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>char buf[] 是一个柔性数组结构，统计 sizeof(struct sdshdr) 时不包含 buf（因为也确实不知道）</p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>sds sdsnewlen(const void *init, size_t initlen);</p>
<p>sds sdsnew(const char *init);</p>
<p>sds sdsempty(void);</p>
<p>size_t sdslen(const sds s);</p>
<p>sds sdsdup(const sds s);</p>
<p>void sdsfree(sds s);</p>
<p>size_t sdsavail(const sds s);</p>
<p>sds sdsgrowzero(sds s, size_t len);</p>
<p>sds sdscatlen(sds s, const void *t, size_t len);</p>
<p>sds sdscat(sds s, const char *t);</p>
<p>sds sdscatsds(sds s, const sds t);</p>
<p>sds sdscpylen(sds s, const char *t, size_t len);</p>
<p>sds sdscpy(sds s, const char *t);</p>
<p>sds sdscatvprintf(sds s, const char *fmt, va_list ap);</p>
<p>sds sdscatfmt(sds s, char const *fmt, …);</p>
<p>sds sdstrim(sds s, const char *cset);</p>
<p>void sdsrange(sds s, int start, int end);</p>
<p>void sdsupdatelen(sds s);</p>
<p>void sdsclear(sds s);</p>
<p>int sdscmp(const sds s1, const sds s2);</p>
<p>sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count);</p>
<p>void sdsfreesplitres(sds *tokens, int count);</p>
<p>void sdstolower(sds s);</p>
<p>void sdstoupper(sds s);</p>
<p>sds sdsfromlonglong(long long value);</p>
<p>sds sdscatrepr(sds s, const char *p, size_t len);</p>
<p>sds *sdssplitargs(const char *line, int *argc);</p>
<p>sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen);</p>
<p>sds sdsjoin(char **argv, int argc, char *sep);</p>
<p>/* Low level functions exposed to the user API */<br>sds sdsMakeRoomFor(sds s, size_t addlen);</p>
<p>void sdsIncrLen(sds s, int incr);</p>
<p>sds sdsRemoveFreeSpace(sds s);</p>
<p>size_t sdsAllocSize(sds s);</p>
<h2 id="sds-sdsnew-const-char-init"><a href="#sds-sdsnew-const-char-init" class="headerlink" title="sds sdsnew(const char *init);"></a>sds sdsnew(const char *init);</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 类型别名，用于指向 sdshdr 的 buf 属性</span><br><span class="line"> *&#x2F;</span><br><span class="line">typedef char *sds;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * 根据给定字符串 init ，创建一个包含同样字符串的 sds</span><br><span class="line"> *</span><br><span class="line"> * 参数</span><br><span class="line"> *  init ：如果输入为 NULL ，那么创建一个空白 sds</span><br><span class="line"> *         否则，新创建的 sds 中包含和 init 内容相同字符串</span><br><span class="line"> *</span><br><span class="line"> * 返回值</span><br><span class="line"> *  sds ：创建成功返回 sdshdr 相对应的 sds</span><br><span class="line"> *        创建失败返回 NULL</span><br><span class="line"> *</span><br><span class="line"> * 复杂度</span><br><span class="line"> *  T &#x3D; O(N)</span><br><span class="line"> *&#x2F;</span><br><span class="line">sds sdsnew(const char *init) &#123;</span><br><span class="line">    size_t initlen &#x3D; (init &#x3D;&#x3D; NULL) ? 0 : strlen(init);</span><br><span class="line">    return sdsnewlen(init, initlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先用 string.h 获取字符串长度，然后看 sdsnewlen 方法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 根据给定的初始化字符串 init 和字符串长度 initlen</span></span><br><span class="line"><span class="comment"> * 创建一个新的 sds</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数</span></span><br><span class="line"><span class="comment"> *  init ：初始化字符串指针</span></span><br><span class="line"><span class="comment"> *  initlen ：初始化字符串的长度</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值</span></span><br><span class="line"><span class="comment"> *  sds ：创建成功返回 sdshdr 相对应的 sds</span></span><br><span class="line"><span class="comment"> *        创建失败返回 NULL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 复杂度</span></span><br><span class="line"><span class="comment"> *  T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据是否有初始化内容，选择适当的内存分配方式</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    <span class="keyword">if</span> (init) &#123;</span><br><span class="line">        <span class="comment">// zmalloc 不初始化所分配的内存</span></span><br><span class="line">        sh = zmalloc(<span class="keyword">sizeof</span>(struct sdshdr) + initlen + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// zcalloc 将分配的内存全部初始化为 0</span></span><br><span class="line">        sh = zcalloc(<span class="keyword">sizeof</span>(struct sdshdr) + initlen + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存分配失败，返回</span></span><br><span class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置初始化长度</span></span><br><span class="line">    sh-&gt;len = initlen;</span><br><span class="line">    <span class="comment">// 新 sds 不预留任何空间</span></span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果有指定初始化内容，将它们复制到 sdshdr 的 buf 中</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</span><br><span class="line">        <span class="built_in">memcpy</span>(sh-&gt;buf, init, initlen);</span><br><span class="line">    <span class="comment">// 以 \0 结尾</span></span><br><span class="line">    sh-&gt;buf[initlen] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 buf 部分，而不是整个 sdshdr</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span> *) sh-&gt;buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>首先进行内存的分配/初始化，zmalloc 和 zcalloc 方法在 zmalloc.h / zmalloc.c 中定义和实现，具体细节未看；</p>
</li>
<li><p>然后把 sdshdr 的 len 和 free 属性设置好，用 string.h 中的 memcpy 把原始字符串的内容拷贝一份到 buf 中，然后给末尾添加上 ‘\0’；</p>
</li>
<li><p>最后返回的是 sds 的 buf 部分</p>
</li>
</ul>
<h2 id="sds-sdscat-sds-s-const-char-t"><a href="#sds-sdscat-sds-s-const-char-t" class="headerlink" title="sds sdscat(sds s, const char *t);"></a>sds sdscat(sds s, const char *t);</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将给定字符串 t 追加到 sds 的末尾</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 返回值</span></span><br><span class="line"><span class="comment"> *  sds ：追加成功返回新 sds ，失败返回 NULL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 复杂度</span></span><br><span class="line"><span class="comment"> *  T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdscat</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdscatlen(s, t, <span class="built_in">strlen</span>(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将长度为 len 的字符串 t 追加到 sds 的字符串末尾</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值</span></span><br><span class="line"><span class="comment"> *  sds ：追加成功返回新 sds ，失败返回 NULL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 复杂度</span></span><br><span class="line"><span class="comment"> *  T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原有字符串长度</span></span><br><span class="line">    <span class="keyword">size_t</span> curlen = sdslen(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩展 sds 空间</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    s = sdsMakeRoomFor(s, len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存不足？直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制 t 中的内容到字符串后部</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    sh = (<span class="keyword">void</span> *) (s - (<span class="keyword">sizeof</span>(struct sdshdr)));</span><br><span class="line">    <span class="built_in">memcpy</span>(s + curlen, t, len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新属性</span></span><br><span class="line">    sh-&gt;len = curlen + len;</span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = sh-&gt;<span class="built_in">free</span> - len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加新结尾符号</span></span><br><span class="line">    s[curlen + len] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回新 sds</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>首先获取 sds 当前的长度，但是这个也是有点操作的：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">size_t</span> <span class="title">sdslen</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span> *) (<span class="title">s</span> - (<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span><br><span class="line">    <span class="keyword">return</span> sh-&gt;len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  sdshdr 中的 len 属性记录了长度，但是 s 指向的是 buf 部分的首地址，而 sizeof 不包含 buf 部分，所以 <code>struct sdshdr *sh = (void *) (s - (sizeof(struct sdshdr)));</code> 这个操作可以让指针恰好指向 sdshdr 的开头</p>
</li>
<li><p>扩展 sds 的空间，这个也是有点操作的</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 对 sds 中 buf 的长度进行扩展，确保在函数执行之后，</span></span><br><span class="line"><span class="comment"> * buf 至少会有 addlen + 1 长度的空余空间</span></span><br><span class="line"><span class="comment"> * （额外的 1 字节是为 \0 准备的）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值</span></span><br><span class="line"><span class="comment"> *  sds ：扩展成功返回扩展后的 sds</span></span><br><span class="line"><span class="comment"> *        扩展失败返回 NULL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 复杂度</span></span><br><span class="line"><span class="comment"> *  T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>, *<span class="title">newsh</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 s 目前的空余空间长度</span></span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">free</span> = sdsavail(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> len, newlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s 目前的空余空间已经足够，无须再进行扩展，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">free</span> &gt;= addlen) &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 s 目前已占用空间的长度</span></span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    sh = (<span class="keyword">void</span> *) (s - (<span class="keyword">sizeof</span>(struct sdshdr)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s 最少需要的长度</span></span><br><span class="line">    newlen = (len + addlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据新长度，为 s 分配新空间所需的大小</span></span><br><span class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class="line">        <span class="comment">// 如果新长度小于 SDS_MAX_PREALLOC </span></span><br><span class="line">        <span class="comment">// 那么为它分配两倍于所需长度的空间</span></span><br><span class="line">        newlen *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则，分配长度为目前长度加上 SDS_MAX_PREALLOC</span></span><br><span class="line">        newlen += SDS_MAX_PREALLOC;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    newsh = zrealloc(sh, <span class="keyword">sizeof</span>(struct sdshdr) + newlen + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存不足，分配失败，返回</span></span><br><span class="line">    <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新 sds 的空余长度</span></span><br><span class="line">    newsh-&gt;<span class="built_in">free</span> = newlen - len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 sds</span></span><br><span class="line">    <span class="keyword">return</span> newsh-&gt;buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  sdshdr 的 free 属性记录了 剩余空间大小，如果空间足够就啥也不干；</p>
<p>  如果空间不够，要做的事情是 zrealloc，这个方法目标是新分配内存+把原来的 sdshdr 整体拷贝过去 + 释放原有空间</p>
</li>
<li><p>现在空间肯定是够了，把字符串放在原来的空间后面，加个 ‘\0’，然后更新 len 和 free 属性</p>
</li>
</ul>
<h2 id="void-sdsclear-sds-s"><a href="#void-sdsclear-sds-s" class="headerlink" title="void sdsclear(sds s);"></a>void sdsclear(sds s);</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在不释放 SDS 的字符串空间的情况下，</span></span><br><span class="line"><span class="comment"> * 重置 SDS 所保存的字符串为空字符串。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 复杂度</span></span><br><span class="line"><span class="comment"> *  T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsclear</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出 sdshdr</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span> *) (<span class="title">s</span> - (<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新计算属性</span></span><br><span class="line">    sh-&gt;<span class="built_in">free</span> += sh-&gt;len;</span><br><span class="line">    sh-&gt;len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将结束符放到最前面（相当于惰性地删除 buf 中的内容）</span></span><br><span class="line">    sh-&gt;buf[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>惰性</strong>空间释放，把属性更新一下，结束符放在 buf 最前面</p>
<hr>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB1_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_sds/" data-id="ck7naw84500012cve1k4d6t46" class="article-share-link">分享到</a>
      

      
        <a href="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB1_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_sds/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-muduo多线程模型：一个Sudoku服务器演变" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%EF%BC%9A%E4%B8%80%E4%B8%AASudoku%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%BC%94%E5%8F%98/" class="article-date">
  <time datetime="2020-03-09T03:01:57.280Z" itemprop="datePublished">2020-03-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/">开源组件</a>►<a class="article-category-link" href="/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/">muduo</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%EF%BC%9A%E4%B8%80%E4%B8%AASudoku%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%BC%94%E5%8F%98/">muduo 多线程模型：一个 Sudoku 服务器演变</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>原文链接 <a href="https://blog.csdn.net/solstice/article/details/6548228" target="_blank" rel="noopener">https://blog.csdn.net/solstice/article/details/6548228</a></p>
</blockquote>
<p>本文以一个 Sudoku Solver 为例，回顾了并发网络服务程序的多种设计方案，并介绍了使用 muduo 网络库编写<strong>多线程服务器</strong>的两种最常用手法。以往的例子展现了 Muduo 在编写单线程并发网络服务程序方面的能力与便捷性，今天我们看一看它在多线程方面的表现。</p>
<p>本文代码见：<a href="http://code.google.com/p/muduo/source/browse/trunk/examples/sudoku/" target="_blank" rel="noopener">http://code.google.com/p/muduo/source/browse/trunk/examples/sudoku/</a></p>
<p>下载：<a href="http://muduo.googlecode.com/files/muduo-0.2.5-alpha.tar.gz" target="_blank" rel="noopener">http://muduo.googlecode.com/files/muduo-0.2.5-alpha.tar.gz</a></p>
<p>关于数独的求解算法见 <a href="https://blog.csdn.net/Solstice/article/details/2096209" target="_blank" rel="noopener">https://blog.csdn.net/Solstice/article/details/2096209</a></p>
<ul>
<li><a href="#%e4%b8%80sudoku-solver">一、Sudoku Solver</a><ul>
<li><a href="#%e5%8d%8f%e8%ae%ae">协议</a></li>
<li><a href="#%e5%9f%ba%e6%9c%ac%e5%ae%9e%e7%8e%b0">基本实现</a></li>
</ul>
</li>
<li><a href="#%e4%ba%8c%e5%b8%b8%e8%a7%81%e7%9a%84%e5%b9%b6%e5%8f%91%e7%bd%91%e7%bb%9c%e6%9c%8d%e5%8a%a1%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%e6%96%b9%e6%a1%88">二、常见的并发网络服务程序设计方案</a></li>
<li><a href="#%e4%b8%89%e7%bb%93%e8%af%ad">三、结语</a></li>
<li><a href="#%e5%9b%9b%e4%bb%a3%e7%a0%81">四、代码</a><ul>
<li><a href="#%e6%96%b9%e6%a1%88-5%e5%8d%95%e7%ba%bf%e7%a8%8b-reactor">方案 5：单线程 Reactor</a></li>
<li><a href="#%e6%96%b9%e6%a1%88-8reactor--thread-pool">方案 8：Reactor + Thread Pool</a></li>
<li><a href="#%e6%96%b9%e6%a1%88-9multiple-reactors">方案 9：Multiple Reactors</a></li>
</ul>
</li>
</ul>
<h2 id="一、Sudoku-Solver"><a href="#一、Sudoku-Solver" class="headerlink" title="一、Sudoku Solver"></a>一、Sudoku Solver</h2><p>假设有这么一个网络编程任务：写一个求解数独的程序 (Sudoku Solver)，并把它做成一个网络服务。</p>
<p>Sudoku Solver 是我喜爱的网络编程例子，它曾经出现在《分布式系统部署、监控与进程管理的几重境界》、《Muduo 设计与实现之一：Buffer 类的设计》、《〈多线程服务器的适用场合〉例释与答疑》等文中，它也可以看成是 echo 服务的一个变种（《谈一谈网络编程学习经验》把 echo 列为三大 TCP 网络编程案例之一）。</p>
<p>写这么一个程序在网络编程方面的难度不高，跟写 echo 服务差不多（从网络连接读入一个 Sudoku 题目，算出答案，再发回给客户），挑战在于怎样做才能发挥现在多核硬件的能力？在谈这个问题之前，让我们先写一个基本的单线程版。</p>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>一个简单的以 /r/n 分隔的文本行协议，<strong>使用 TCP 长连接</strong>，<strong>客户端在不需要服务时主动断开连接</strong>。</p>
<p>请求：<code>[id:]〈81digits〉/r/n</code></p>
<p>响应：<code>[id:]〈81digits〉/r/n</code> 或者 <code>[id:]NoSolution/r/n</code></p>
<p>其中 <code>[id:]</code> 表示可选的 id，<strong>用于区分先后的请求</strong>，以支持 Parallel Pipelining，响应中会回显请求中的 id。Parallel Pipelining 的意义见赖勇浩的《以小见大——那些基于 protobuf 的五花八门的 RPC（2） 》，或者见我写的《分布式系统的工程化开发方法》第 54 页关于 out-of-order RPC 的介绍。</p>
<p>〈81digits〉是 Sudoku 的棋盘，9x9 个数字，未知数字以 0 表示。</p>
<p>如果 Sudoku 有解，那么响应是填满数字的棋盘；如果无解，则返回 NoSolution。</p>
<p><strong>例子1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">请求：000000010400000000020000000000050407008000300001090000300400200050100000000806000&#x2F;r&#x2F;n</span><br><span class="line"></span><br><span class="line">响应：693784512487512936125963874932651487568247391741398625319475268856129743274836159&#x2F;r&#x2F;n</span><br></pre></td></tr></table></figure>

<p><strong>例子2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">请求：a:000000010400000000020000000000050407008000300001090000300400200050100000000806000&#x2F;r&#x2F;n</span><br><span class="line"></span><br><span class="line">响应：a:693784512487512936125963874932651487568247391741398625319475268856129743274836159&#x2F;r&#x2F;n</span><br></pre></td></tr></table></figure>

<p><strong>例子3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">请求：b:000000010400000000020000000000050407008000300001090000300400200050100000000806005&#x2F;r&#x2F;n</span><br><span class="line"></span><br><span class="line">响应：b:NoSolution&#x2F;r&#x2F;n</span><br></pre></td></tr></table></figure>

<p>基于这个文本协议，我们可以用 <code>telnet</code> <strong>模拟客户端来测试</strong> sudoku solver，不需要单独编写 sudoku client。SudokuSolver 的默认端口号是 9981，因为它有 9x9=81 个格子。</p>
<h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><p>Sudoku 的求解算法见《谈谈数独(Sudoku)》一文，这不是本文的重点。假设我们已经有一个函数能求解 Sudoku，它的原型如下</p>
<p><code>string solveSudoku(const string&amp; puzzle);</code></p>
<p>函数的输入是上文的”〈81digits〉”，输出是”〈81digits〉”或”NoSolution”。这个函数是个 pure function，同时也是线程安全的。</p>
<p>有了这个函数，我们以《Muduo 网络编程示例之零：前言》中的 EchoServer 为蓝本，稍作修改就能得到 SudokuServer。这里只列出最关键的 onMessage() 函数，完整的代码见 <a href="http://code.google.com/p/muduo/source/browse/trunk/examples/sudoku/server_basic.cc" target="_blank" rel="noopener">http://code.google.com/p/muduo/source/browse/trunk/examples/sudoku/server_basic.cc</a> 。onMessage() 的主要功能是<strong>处理协议格式，并调用 solveSudoku() 求解问题</strong>。</p>
<p><code>server_basic.cc</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn, Buffer *buf, Timestamp)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    LOG_DEBUG &lt;&lt; conn-&gt;name();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">size_t</span> len = buf-&gt;readableBytes();</span><br><span class="line">    <span class="keyword">while</span> (len &gt;= kCells + <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *crlf = buf-&gt;findCRLF();</span><br><span class="line">        <span class="keyword">if</span> (crlf) &#123;</span><br><span class="line">            <span class="function"><span class="built_in">string</span> <span class="title">request</span><span class="params">(buf-&gt;peek(), crlf)</span></span>;</span><br><span class="line">            buf-&gt;retrieveUntil(crlf + <span class="number">2</span>);</span><br><span class="line">            len = buf-&gt;readableBytes();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!processRequest(conn, request)) &#123;</span><br><span class="line">                conn-&gt;send(<span class="string">"Bad Request!\r\n"</span>);</span><br><span class="line">                conn-&gt;shutdown();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; <span class="number">100</span>) &#123;</span><br><span class="line">            conn-&gt;send(<span class="string">"Id too long!\r\n"</span>);</span><br><span class="line">            conn-&gt;shutdown();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>server_basic.cc 是一个<strong>并发服务器</strong>，可以同时服务多个客户连接。<strong>但是它是单线程的</strong>，无法发挥多核硬件的能力。</p>
<p>Sudoku 是一个<strong>计算密集型</strong>的任务（见《Muduo 设计与实现之一：Buffer 类的设计》中关于其性能的分析），其瓶颈在 CPU。为了让这个单线程 server_basic 程序充分利用 CPU 资源，一个简单的办法是在同一台机器上部署多个 server_basic 进程，让每个进程占用不同的端口，比如在一台 8 核机器上部署 8 个 server_basic 进程，分别占用 9981、9982、……、9988 端口。这样做其实是把难题推给了客户端，因为客户端(s)要自己做负载均衡。再想得远一点，在 8 个 server_basic 前面部署一个 load balancer？似乎小题大做了。</p>
<p>能不能在一个端口上提供服务，并且又能发挥多核处理器的计算能力呢？当然可以，办法不止一种。</p>
<h2 id="二、常见的并发网络服务程序设计方案"><a href="#二、常见的并发网络服务程序设计方案" class="headerlink" title="二、常见的并发网络服务程序设计方案"></a>二、常见的并发网络服务程序设计方案</h2><p>W. Richard Stevens 的 UNP2e 第 27 章 Client-Server Design Alternatives 介绍了十来种当时（90 年代末）流行的编写并发网络程序的方案。UNP3e 第 30 章，内容未变，还是这几种。以下简称 UNP CSDA 方案。UNP 这本书主要讲解阻塞式网络编程，在非阻塞方面着墨不多，仅有一章。正确使用 non-blocking IO 需要考虑的问题很多，不适宜直接调用 Sockets API，而需要一个功能完善的网络库支撑。</p>
<p>随着 2000 年前后第一次互联网浪潮的兴起，业界对高并发 http 服务器的强烈需求大大推动了这一领域的研究，<strong>目前高性能 httpd 普遍采用的是单线程 reactor 方式</strong>。另外一个说法是 IBM Lotus 使用 TCP 长连接协议，而把 Lotus 服务端移植到 Linux 的过程中 IBM 的工程师们大大提高了 Linux 内核在处理并发连接方面的可伸缩性，因为一个公司可能有上万人同时上线，连接到同一台跑着 Lotus server 的 Linux 服务器。</p>
<p>可伸缩网络编程这个领域其实近十年来没什么新东西，POSA2 已经作了相当全面的总结，另外以下几篇文章也值得参考。</p>
<p><a href="http://bulk.fefe.de/scalable-networking.pdf" target="_blank" rel="noopener">http://bulk.fefe.de/scalable-networking.pdf</a></p>
<p><a href="http://www.kegel.com/c10k.html" target="_blank" rel="noopener">http://www.kegel.com/c10k.html</a></p>
<p><a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf" target="_blank" rel="noopener">http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf</a></p>
<p>下表是陈硕总结的 10 种常见方案。其中“<strong>多连接互通</strong>”指的是如果开发 chat 服务，多个客户连接之间是否能方便地交换数据（chat 也是《谈一谈网络编程学习经验》中举的三大 TCP 网络编程案例之一）。对于 echo/http/sudoku 这类“连接相互独立”的服务程序，这个功能无足轻重，但是对于 chat 类服务至关重要。“<strong>顺序性</strong>”指的是在 http/sudoku 这类请求-响应服务中，如果客户连接顺序发送多个请求，那么计算得到的多个响应是否按相同的顺序发还给客户（这里指的是在自然条件下，不含刻意同步）。</p>
<table>
<thead>
<tr>
<th align="center">方案</th>
<th align="center">model</th>
<th align="center">UNP 对应</th>
<th align="center">阻塞/非阻塞</th>
<th align="center">多进程？</th>
<th align="center">多线程？</th>
<th align="center">IO 复用？</th>
<th align="center">长连接？</th>
<th align="center">并发性</th>
<th align="center">多核？</th>
<th align="center">开销</th>
<th align="center">多连接互通？</th>
<th align="center">顺序性</th>
<th align="center">线程数确定？</th>
<th align="center">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">accept + read/write</td>
<td align="center">0</td>
<td align="center">阻塞</td>
<td align="center">no</td>
<td align="center">no</td>
<td align="center">no</td>
<td align="center">no</td>
<td align="center">无</td>
<td align="center">no</td>
<td align="center">低</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">一次服务一个客户</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">accept + fork</td>
<td align="center">1</td>
<td align="center">阻塞</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">低</td>
<td align="center">yes</td>
<td align="center">高</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">process-per-connection</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">accept + thread</td>
<td align="center">6</td>
<td align="center">阻塞</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">中</td>
<td align="center">yes</td>
<td align="center">中</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">thread-per-connection</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">prefork</td>
<td align="center">2/3/4/5</td>
<td align="center">阻塞</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">低</td>
<td align="center">yes</td>
<td align="center">高</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">见 UNP</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">pre threaded</td>
<td align="center">7/8</td>
<td align="center">阻塞</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">中</td>
<td align="center">yes</td>
<td align="center">中</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">见 UNP</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">poll(reactor)</td>
<td align="center">sec 6.8</td>
<td align="center">非阻塞</td>
<td align="center">no</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">高</td>
<td align="center">no</td>
<td align="center">低</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">单线程 reactor</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">reactor + thread-per-task</td>
<td align="center">无</td>
<td align="center">非阻塞</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">中</td>
<td align="center">yes</td>
<td align="center">中</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">no</td>
<td align="center">thread-per-request</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">reactor + worker thread</td>
<td align="center">无</td>
<td align="center">非阻塞</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">中</td>
<td align="center">yes</td>
<td align="center">中</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">worker-thread-per-connection</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">reactor + thread pool</td>
<td align="center">无</td>
<td align="center">非阻塞</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">高</td>
<td align="center">yes</td>
<td align="center">低</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">主线程 io + 工作线程计算</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">multiple reactors</td>
<td align="center">无</td>
<td align="center">非阻塞</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">高</td>
<td align="center">yes</td>
<td align="center">低</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">one-loop-per-thread</td>
</tr>
</tbody></table>
<p>UNP CSDA 方案归入 0~5。5 也是目前用得很多的单线程 reactor 方案，muduo 对此提供了很好的支持。6 和 7 其实不是实用的方案，只是作为过渡品。8 和 9 是本文重点介绍的方案，其实这两个方案已经在《多线程服务器的常用编程模型》一文中提到过，只不过当时我还没有写 muduo，无法用具体的代码示例来说明。</p>
<p>在对比各方案之前，我们先看看基本的 micro benchmark 数据（前三项由 lmbench 测得）：</p>
<ul>
<li>fork()+exit(): 160us</li>
<li>pthread_create()+pthread_join(): 12us</li>
<li>context switch : 1.5us</li>
<li>sudoku resolve: 100us (根据题目难度不同，浮动范围 20~200us)</li>
</ul>
<p>接下来看一下几种方案：</p>
<ul>
<li><p><strong>方案 0</strong>：这其实不是并发服务器，而是 iterative 服务器，因为它一次只能服务一个客户。代码见 UNP figure 1.9，UNP 以此为对比其他方案的基准点。这个方案不适合长连接，到是很适合 daytime 这种 write-only 服务。</p>
</li>
<li><p><strong>方案 1</strong>：这是传统的 Unix 并发网络编程方案，UNP 称之为 child-per-client 或 fork()-per-client，另外也俗称 process-per-connection。这种方案适合并发连接数不大的情况。至今仍有一些网络服务程序用这种方式实现，比如 PostgreSQL 和 Perforce 的服务端。<strong>这种方案适合“计算响应的工作量远大于 fork() 的开销”这种情况</strong>，比如数据库服务器。这种方案适合长连接，但不太适合短连接，因为 fork() 开销大于求解 sudoku 的用时。</p>
</li>
<li><p><strong>方案 2</strong>：<strong>这是传统的 Java 网络编程方案</strong> thread-per-connection，在 Java 1.4 引入 NIO 之前，Java 网络服务程序多采用这种方案。它的初始化开销比方案 1 要小很多。这种方案的伸缩性受到线程数的限制，一两百个还行，几千个的话对操作系统的 scheduler 恐怕是个不小的负担。</p>
</li>
<li><p><strong>方案 3</strong>：这是针对方案 1 的优化，UNP 详细分析了几种变化，包括对 accept 惊群问题的考虑。</p>
</li>
<li><p><strong>方案 4</strong>：这是对方案 2 的优化，UNP 详细分析了它的几种变化。</p>
</li>
</ul>
<p>以上几种方案都是<strong>阻塞式网络编程</strong>，程序（thread-of-control）通常<strong>阻塞在 read() 上</strong>，等待数据到达。但是 TCP 是个全双工协议，同时支持 read() 和 write() 操作，当一个线程/进程阻塞在 read() 上，但程序又想给这个 TCP 连接发数据，那该怎么办？比如说 echo client，既要从 stdin 读，又要从网络读，当程序正在阻塞地读网络的时候，如何处理键盘输入？又比如 proxy，既要把连接 a 收到的数据发给连接 b，又要把从连接 b 收到的数据发给连接 a，那么到底读哪个？（proxy 是《谈一谈网络编程学习经验》中举的三大 TCP 网络编程案例之一。）</p>
<p><strong>一种方法</strong>是用两个线程/进程，一个负责读，一个负责写。UNP 也在实现 echo client 时介绍了这种方案。另外见 Python Pinhole 的代码：<a href="http://code.activestate.com/recipes/114642/" target="_blank" rel="noopener">http://code.activestate.com/recipes/114642/</a></p>
<p>((另一种方法))是使用 <code>IO multiplexing</code>，也就是 select/poll/epoll/kqueue 这一系列的“多路选择器”，让一个 thread-of-control 能处理多个连接。“IO 复用”其实复用的不是 IO 连接，而是复用线程。<strong>使用 select/poll 几乎肯定要配合 non-blocking IO，而使用 non-blocking IO 肯定要使用应用层 buffer</strong>，原因见《Muduo 设计与实现之一：Buffer 类的设计》。这就不是一件轻松的事儿了，如果每个程序都去搞一套自己的 IO multiplexing 机制（本质是 event-driven 事件驱动），这是一种很大的浪费。感谢 Doug Schmidt 为我们总结出了 <code>Reactor</code> 模式，让 event-driven 网络编程有章可循。继而出现了一些通用的 reactor 框架/库，比如 libevent、muduo、Netty、twisted、POE 等等，有了这些库，我想基本不用去编写阻塞式的网络程序了（特殊情况除外，比如 proxy 流量限制）。</p>
<p>单线程 reactor 的程序结构是（图片取自 Doug Lea 的演讲）：</p>
<p><img src="/resources/%E5%8D%95%E7%BA%BF%E7%A8%8Breactor%E7%9A%84%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84.gif" alt="单线程 reactor 的程序结构"></p>
<ul>
<li><p><strong>方案 5</strong>：基本的单线程 reactor 方案，即前面的 server_basic.cc 程序。本文以它作为对比其他方案的基准点。这种方案的优点是由网络库搞定数据收发，程序只关心业务逻辑；缺点在前面已经谈了：适合 IO 密集的应用，不太适合 CPU 密集的应用，因为较难发挥多核的威力。</p>
</li>
<li><p><strong>方案 6</strong>：这是一个过渡方案，收到 Sudoku 请求之后，不在 reactor 线程计算，而是创建一个新线程去计算，以充分利用多核 CPU。这是非常初级的多线程应用，<strong>因为它为每个请求（而不是每个连接）创建了一个新线程</strong>。这个开销可以用线程池来避免，即方案 8。这个方案还有一个特点是 out-of-order，即同时创建多个线程去计算同一个连接上收到的多个请求，那么算出结果的次序是不确定的，可能第 2 个 Sudoku 比较简单，比第 1 个先算出结果。这也是为什么我们在一开始设计协议的时候使用了 id，以便客户端区分 response 对应的是哪个 request。</p>
</li>
<li><p><strong>方案 7</strong>：为了让返回结果的顺序确定，我们可以<strong>为每个连接创建一个计算线程，每个连接上的请求固定发给同一个线程去算，先到先得</strong>。这也是一个过渡方案，因为并发连接数受限于线程数目，这个方案或许还不如直接使用阻塞 IO 的 thread-per-connection 方案2。方案 7 与方案 6 的另外一个区别是一个 client 的最大 CPU 占用率，在方案 6 中，一个 connection 上发来的一长串突发请求(burst requests) 可以占满全部 8 个 core；而在方案 7 中，由于每个连接上的请求固定由同一个线程处理，那么它最多占用 12.5% 的 CPU 资源。这两种方案各有优劣，取决于应用场景的需要，到底是<strong>公平性</strong>重要还是<strong>突发性能</strong>重要。这个区别在方案 8 和方案 9 中同样存在，需要根据应用来取舍。</p>
</li>
<li><p><strong>方案 8</strong>：为了弥补方案 6 中为每个请求创建线程的缺陷，我们使用固定大小线程池，程序结构如下图。全部的 IO 工作都在一个 reactor 线程完成，而计算任务交给 thread pool。如果计算任务彼此独立，而且 IO 的压力不大，那么这种方案是非常适用的。Sudoku Solver 正好符合。代码见：<a href="http://code.google.com/p/muduo/source/browse/trunk/examples/sudoku/server_threadpool.cc" target="_blank" rel="noopener">http://code.google.com/p/muduo/source/browse/trunk/examples/sudoku/server_threadpool.cc</a> 后文给出了它与方案 9 的区别。</p>
</li>
</ul>
<p><img src="/resources/%E4%B8%BB%E7%BA%BF%E7%A8%8Bio+%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E8%AE%A1%E7%AE%97gif.gif" alt="主线程 io + 工作线程计算"></p>
<p>如果 IO 的压力比较大，一个 reactor 忙不过来，可以试试 multiple reactors 的方案 9。</p>
<ul>
<li><strong>方案 9</strong>：<strong>这是 muduo 内置的多线程方案</strong>，也是 Netty 内置的多线程方案。这种方案的特点是 one loop per thread，<strong>有一个 main reactor 负责 accept 连接，然后把连接挂在某个 sub reactor 中</strong>（muduo 采用 round-robin 的方式来选择 sub reactor），这样该连接的所有操作都在那个 sub reactor 所处的线程中完成。多个连接可能被分派到多个线程中，以充分利用 CPU。Muduo 采用的是固定大小的 reactor pool，池子的大小通常根据 CPU 核数确定，也就是说线程数是固定的，这样程序的总体处理能力不会随连接数增加而下降。另外，由于一个连接完全由一个线程管理，那么请求的顺序性有保证，突发请求也不会占满全部 8 个核（如果需要优化突发请求，可以考虑方案 10）。这种方案把 IO 分派给多个线程，防止出现一个 reactor 的处理能力饱和。与方案 8 的线程池相比，方案 9 减少了进出 thread pool 的两次上下文切换。我认为这是一个适应性很强的多线程 IO 模型，因此把它作为 muduo 的默认线程模型。</li>
</ul>
<p><img src="/resources/mutiple_reactors.gif" alt="Multiple Reactors"></p>
<ul>
<li><strong>方案 10</strong>：把方案 8 和方案 90 混合，既使用多个 reactors 来处理 IO，又使用线程池来处理计算。这种方案适合既有突发 IO （利用多线程处理多个连接上的 IO），又有突发计算的应用（利用线程池把一个连接上的计算任务分配给多个线程去做）。</li>
</ul>
<p><img src="/resources/multiple_reactors_with_thread_pool.gif" alt="Multiple Reactors With Thread Pool"></p>
<p>这种其实方案看起来复杂，<strong>其实写起来很简单，只要把方案 8 的代码加一行 server_.setThreadNum(numThreads); 就行</strong>，这里就不举例了。</p>
<h2 id="三、结语"><a href="#三、结语" class="headerlink" title="三、结语"></a>三、结语</h2><p>我在《多线程服务器的常用编程模型》一文中说</p>
<p>总结起来，我推荐的多线程服务端编程模式为：event loop per thread + thread pool。</p>
<p>event loop 用作 non-blocking IO 和定时器。<br>thread pool 用来做计算，具体可以是任务队列或消费者-生产者队列。</p>
<p>当时（2010年2月）我还说“以这种方式写服务器程序，需要一个优质的基于 Reactor 模式的网络库来支撑，我只用过in-house的产品，无从比较并推荐市面上常见的 C++ 网络库，抱歉。”</p>
<p>现在有了 muduo 网络库，我终于能够用具体的代码示例把思想完整地表达出来。</p>
<h2 id="四、代码"><a href="#四、代码" class="headerlink" title="四、代码"></a>四、代码</h2><h3 id="方案-5：单线程-Reactor"><a href="#方案-5：单线程-Reactor" class="headerlink" title="方案 5：单线程 Reactor"></a>方案 5：单线程 Reactor</h3><p><code>server_basic.cc</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SudokuServer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SudokuServer(EventLoop *loop, <span class="keyword">const</span> InetAddress &amp;listenAddr)</span><br><span class="line">            : server_(loop, listenAddr, <span class="string">"SudokuServer"</span>),</span><br><span class="line">              startTime_(Timestamp::now()) &#123;</span><br><span class="line">        server_.setConnectionCallback(</span><br><span class="line">                <span class="built_in">std</span>::bind(&amp;SudokuServer::onConnection, <span class="keyword">this</span>, _1));</span><br><span class="line">        server_.setMessageCallback(</span><br><span class="line">                <span class="built_in">std</span>::bind(&amp;SudokuServer::onMessage, <span class="keyword">this</span>, _1, _2, _3));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        server_.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn, Buffer *buf, Timestamp)</span> </span>&#123;</span><br><span class="line">        LOG_DEBUG &lt;&lt; conn-&gt;name();</span><br><span class="line">        <span class="keyword">size_t</span> len = buf-&gt;readableBytes();</span><br><span class="line">        <span class="keyword">while</span> (len &gt;= kCells + <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *crlf = buf-&gt;findCRLF();</span><br><span class="line">            <span class="keyword">if</span> (crlf) &#123;</span><br><span class="line">                <span class="function"><span class="built_in">string</span> <span class="title">request</span><span class="params">(buf-&gt;peek(), crlf)</span></span>;</span><br><span class="line">                buf-&gt;retrieveUntil(crlf + <span class="number">2</span>);</span><br><span class="line">                len = buf-&gt;readableBytes();</span><br><span class="line">                <span class="keyword">if</span> (!processRequest(conn, request)) &#123;</span><br><span class="line">                    conn-&gt;send(<span class="string">"Bad Request!\r\n"</span>);</span><br><span class="line">                    conn-&gt;shutdown();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; <span class="number">100</span>) <span class="comment">// id + ":" + kCells + "\r\n"</span></span><br><span class="line">            &#123;</span><br><span class="line">                conn-&gt;send(<span class="string">"Id too long!\r\n"</span>);</span><br><span class="line">                conn-&gt;shutdown();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">processRequest</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn, <span class="keyword">const</span> <span class="built_in">string</span> &amp;request)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> id;</span><br><span class="line">        <span class="built_in">string</span> puzzle;</span><br><span class="line">        <span class="keyword">bool</span> goodRequest = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span>::const_iterator colon = find(request.begin(), request.end(), <span class="string">':'</span>);</span><br><span class="line">        <span class="keyword">if</span> (colon != request.end()) &#123;</span><br><span class="line">            id.assign(request.begin(), colon);</span><br><span class="line">            puzzle.assign(colon + <span class="number">1</span>, request.end());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            puzzle = request;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (puzzle.size() == implicit_cast&lt;<span class="keyword">size_t</span>&gt;(kCells)) &#123;</span><br><span class="line">            LOG_DEBUG &lt;&lt; conn-&gt;name();</span><br><span class="line">            <span class="built_in">string</span> result = solveSudoku(puzzle);</span><br><span class="line">            <span class="keyword">if</span> (id.empty()) &#123;</span><br><span class="line">                conn-&gt;send(result + <span class="string">"\r\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                conn-&gt;send(id + <span class="string">":"</span> + result + <span class="string">"\r\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            goodRequest = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> goodRequest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TcpServer server_;</span><br><span class="line">    Timestamp startTime_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="方案-8：Reactor-Thread-Pool"><a href="#方案-8：Reactor-Thread-Pool" class="headerlink" title="方案 8：Reactor + Thread Pool"></a>方案 8：Reactor + Thread Pool</h3><p><code>server_threadpool.cc</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SudokuServer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SudokuServer(EventLoop *loop, <span class="keyword">const</span> InetAddress &amp;listenAddr, <span class="keyword">int</span> numThreads)</span><br><span class="line">            : server_(loop, listenAddr, <span class="string">"SudokuServer"</span>),</span><br><span class="line">              numThreads_(numThreads),</span><br><span class="line">              startTime_(Timestamp::now()) &#123;</span><br><span class="line"></span><br><span class="line">        server_.setConnectionCallback(</span><br><span class="line">                <span class="built_in">std</span>::bind(&amp;SudokuServer::onConnection, <span class="keyword">this</span>, _1));</span><br><span class="line">        server_.setMessageCallback(</span><br><span class="line">                <span class="built_in">std</span>::bind(&amp;SudokuServer::onMessage, <span class="keyword">this</span>, _1, _2, _3));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LOG_INFO &lt;&lt; <span class="string">"starting "</span> &lt;&lt; numThreads_ &lt;&lt; <span class="string">" threads."</span>;</span><br><span class="line">        threadPool_.start(numThreads_);</span><br><span class="line">        server_.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn, Buffer *buf, Timestamp)</span> </span>&#123;</span><br><span class="line">        LOG_DEBUG &lt;&lt; conn-&gt;name();</span><br><span class="line">        <span class="keyword">size_t</span> len = buf-&gt;readableBytes();</span><br><span class="line">        <span class="keyword">while</span> (len &gt;= kCells + <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *crlf = buf-&gt;findCRLF();</span><br><span class="line">            <span class="keyword">if</span> (crlf) &#123;</span><br><span class="line">                <span class="function"><span class="built_in">string</span> <span class="title">request</span><span class="params">(buf-&gt;peek(), crlf)</span></span>;</span><br><span class="line">                buf-&gt;retrieveUntil(crlf + <span class="number">2</span>);</span><br><span class="line">                len = buf-&gt;readableBytes();</span><br><span class="line">                <span class="keyword">if</span> (!processRequest(conn, request)) &#123;</span><br><span class="line">                    conn-&gt;send(<span class="string">"Bad Request!\r\n"</span>);</span><br><span class="line">                    conn-&gt;shutdown();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; <span class="number">100</span>) &#123;</span><br><span class="line">                conn-&gt;send(<span class="string">"Id too long!\r\n"</span>);</span><br><span class="line">                conn-&gt;shutdown();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">processRequest</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn, <span class="keyword">const</span> <span class="built_in">string</span> &amp;request)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> id;</span><br><span class="line">        <span class="built_in">string</span> puzzle;</span><br><span class="line">        <span class="keyword">bool</span> goodRequest = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span>::const_iterator colon = find(request.begin(), request.end(), <span class="string">':'</span>);</span><br><span class="line">        <span class="keyword">if</span> (colon != request.end()) &#123;</span><br><span class="line">            id.assign(request.begin(), colon);</span><br><span class="line">            puzzle.assign(colon + <span class="number">1</span>, request.end());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            puzzle = request;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (puzzle.size() == implicit_cast&lt;<span class="keyword">size_t</span>&gt;(kCells)) &#123;</span><br><span class="line">            threadPool_.run(<span class="built_in">std</span>::bind(&amp;solve, conn, puzzle, id));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            goodRequest = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> goodRequest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> <span class="built_in">string</span> &amp;puzzle,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> <span class="built_in">string</span> &amp;id)</span> </span>&#123;</span><br><span class="line">        LOG_DEBUG &lt;&lt; conn-&gt;name();</span><br><span class="line">        <span class="built_in">string</span> result = solveSudoku(puzzle);</span><br><span class="line">        <span class="keyword">if</span> (id.empty()) &#123;</span><br><span class="line">            conn-&gt;send(result + <span class="string">"\r\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            conn-&gt;send(id + <span class="string">":"</span> + result + <span class="string">"\r\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TcpServer server_;</span><br><span class="line">    ThreadPool threadPool_;</span><br><span class="line">    <span class="keyword">int</span> numThreads_;</span><br><span class="line">    Timestamp startTime_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="方案-9：Multiple-Reactors"><a href="#方案-9：Multiple-Reactors" class="headerlink" title="方案 9：Multiple Reactors"></a>方案 9：Multiple Reactors</h3><p><code>server_multiloop.cc</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SudokuServer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SudokuServer(EventLoop *loop, <span class="keyword">const</span> InetAddress &amp;listenAddr, <span class="keyword">int</span> numThreads)</span><br><span class="line">            : server_(loop, listenAddr, <span class="string">"SudokuServer"</span>),</span><br><span class="line">              numThreads_(numThreads),</span><br><span class="line">              startTime_(Timestamp::now()) &#123;</span><br><span class="line"></span><br><span class="line">        server_.setConnectionCallback(</span><br><span class="line">                <span class="built_in">std</span>::bind(&amp;SudokuServer::onConnection, <span class="keyword">this</span>, _1));</span><br><span class="line">        server_.setMessageCallback(</span><br><span class="line">                <span class="built_in">std</span>::bind(&amp;SudokuServer::onMessage, <span class="keyword">this</span>, _1, _2, _3));</span><br><span class="line">        server_.setThreadNum(numThreads);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LOG_INFO &lt;&lt; <span class="string">"starting "</span> &lt;&lt; numThreads_ &lt;&lt; <span class="string">" threads."</span>;</span><br><span class="line">        server_.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn, Buffer *buf, Timestamp)</span> </span>&#123;</span><br><span class="line">        LOG_DEBUG &lt;&lt; conn-&gt;name();</span><br><span class="line">        <span class="keyword">size_t</span> len = buf-&gt;readableBytes();</span><br><span class="line">        <span class="keyword">while</span> (len &gt;= kCells + <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *crlf = buf-&gt;findCRLF();</span><br><span class="line">            <span class="keyword">if</span> (crlf) &#123;</span><br><span class="line">                <span class="function"><span class="built_in">string</span> <span class="title">request</span><span class="params">(buf-&gt;peek(), crlf)</span></span>;</span><br><span class="line">                buf-&gt;retrieveUntil(crlf + <span class="number">2</span>);</span><br><span class="line">                len = buf-&gt;readableBytes();</span><br><span class="line">                <span class="keyword">if</span> (!processRequest(conn, request)) &#123;</span><br><span class="line">                    conn-&gt;send(<span class="string">"Bad Request!\r\n"</span>);</span><br><span class="line">                    conn-&gt;shutdown();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; <span class="number">100</span>) &#123;</span><br><span class="line">                conn-&gt;send(<span class="string">"Id too long!\r\n"</span>);</span><br><span class="line">                conn-&gt;shutdown();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">processRequest</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn, <span class="keyword">const</span> <span class="built_in">string</span> &amp;request)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> id;</span><br><span class="line">        <span class="built_in">string</span> puzzle;</span><br><span class="line">        <span class="keyword">bool</span> goodRequest = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span>::const_iterator colon = find(request.begin(), request.end(), <span class="string">':'</span>);</span><br><span class="line">        <span class="keyword">if</span> (colon != request.end()) &#123;</span><br><span class="line">            id.assign(request.begin(), colon);</span><br><span class="line">            puzzle.assign(colon + <span class="number">1</span>, request.end());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            puzzle = request;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (puzzle.size() == implicit_cast&lt;<span class="keyword">size_t</span>&gt;(kCells)) &#123;</span><br><span class="line">            LOG_DEBUG &lt;&lt; conn-&gt;name();</span><br><span class="line">            <span class="built_in">string</span> result = solveSudoku(puzzle);</span><br><span class="line">            <span class="keyword">if</span> (id.empty()) &#123;</span><br><span class="line">                conn-&gt;send(result + <span class="string">"\r\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                conn-&gt;send(id + <span class="string">":"</span> + result + <span class="string">"\r\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            goodRequest = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> goodRequest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TcpServer server_;</span><br><span class="line">    <span class="keyword">int</span> numThreads_;</span><br><span class="line">    Timestamp startTime_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%EF%BC%9A%E4%B8%80%E4%B8%AASudoku%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%BC%94%E5%8F%98/" data-id="ck7naw84q000w2cve18mtfqaz" class="article-share-link">分享到</a>
      

      
        <a href="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%EF%BC%9A%E4%B8%80%E4%B8%AASudoku%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%BC%94%E5%8F%98/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cpp/" rel="tag">Cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Net/" rel="tag">Net</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-muduo网络编程示例之二：Boost.Asio的聊天服务器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B%E4%B9%8B%E4%BA%8C%EF%BC%9ABoost.Asio%E7%9A%84%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/" class="article-date">
  <time datetime="2020-03-09T03:00:45.855Z" itemprop="datePublished">2020-03-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/">开源组件</a>►<a class="article-category-link" href="/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/">muduo</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B%E4%B9%8B%E4%BA%8C%EF%BC%9ABoost.Asio%E7%9A%84%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/">muduo 网络编程示例之二： Boost.Asio 的聊天服务器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>原文链接 <a href="https://blog.csdn.net/Solstice/article/details/6172391" target="_blank" rel="noopener">https://blog.csdn.net/Solstice/article/details/6172391</a></p>
</blockquote>
<p>本文将介绍一个与 Boost.Asio 的示例代码中的聊天服务器功能类似的网络服务程序，包括客户端与服务端的 muduo 实现。这个例子的<strong>主要目的是介绍如何处理分包</strong>，并初步涉及 Muduo 的<strong>多线程功能</strong>。Muduo 的下载地址： <a href="http://muduo.googlecode.com/files/muduo-0.1.7-alpha.tar.gz" target="_blank" rel="noopener">http://muduo.googlecode.com/files/muduo-0.1.7-alpha.tar.gz</a> ，SHA1 873567e43b3c2cae592101ea809b30ba730f2ee6，本文的完整代码可在线阅读<br><a href="http://code.google.com/p/muduo/source/browse/trunk/examples/asio/chat/" target="_blank" rel="noopener">http://code.google.com/p/muduo/source/browse/trunk/examples/asio/chat/</a> 。</p>
<ul>
<li><a href="#%e4%b8%80tcp-%e5%88%86%e5%8c%85">一、TCP 分包</a></li>
<li><a href="#%e4%ba%8c%e8%81%8a%e5%a4%a9%e6%9c%8d%e5%8a%a1">二、聊天服务</a></li>
<li><a href="#%e4%b8%89%e6%b6%88%e6%81%af%e6%a0%bc%e5%bc%8f">三、消息格式</a></li>
<li><a href="#%e5%9b%9b%e6%89%93%e5%8c%85%e7%9a%84%e4%bb%a3%e7%a0%81">四、打包的代码</a></li>
<li><a href="#%e4%ba%94%e5%88%86%e5%8c%85%e7%9a%84%e4%bb%a3%e7%a0%81">五、分包的代码</a></li>
<li><a href="#%e5%85%ad%e7%bc%96%e8%a7%a3%e7%a0%81%e5%99%a8-lengthheadercodec">六、编解码器 LengthHeaderCodec</a></li>
<li><a href="#%e4%b8%83%e6%9c%8d%e5%8a%a1%e7%ab%af%e7%9a%84%e5%ae%9e%e7%8e%b0">七、服务端的实现</a></li>
<li><a href="#%e5%85%ab%e5%ae%a2%e6%88%b7%e7%ab%af%e7%9a%84%e5%ae%9e%e7%8e%b0">八、客户端的实现</a></li>
<li><a href="#%e4%b9%9d%e7%ae%80%e5%8d%95%e6%b5%8b%e8%af%95">九、简单测试</a></li>
</ul>
<h2 id="一、TCP-分包"><a href="#一、TCP-分包" class="headerlink" title="一、TCP 分包"></a>一、TCP 分包</h2><p>前面一篇《五个简单 TCP 协议》中处理的协议没有涉及分包，在 TCP 这种字节流协议上做<strong>应用层分包</strong>是网络编程的基本需求。<strong>分包</strong>指的是在发送一个消息(message)或一帧(frame)数据时，通过一定的处理，让接收方能从字节流中识别并截取（还原）出一个个消息。“粘包问题”是个伪问题。</p>
<p><strong>对于短连接的 TCP 服务，分包不是一个问题</strong>，只要发送方主动关闭连接，就表示一条消息发送完毕，<strong>接收方 read() 返回 0，从而知道消息的结尾</strong>。例如前一篇文章里的 daytime 和 time 协议。</p>
<p><strong>注：一方主动关闭 TCP 连接时，另一方 read() 返回 0 ，则代表对方已经关闭连接。</strong></p>
<p>对于长连接的 TCP 服务，分包有四种方法：</p>
<ul>
<li><strong>消息长度固定</strong>，比如 muduo 的 roundtrip 示例就采用了固定的 16 字节消息；</li>
<li><strong>使用特殊的字符或字符串作为消息的边界</strong>，例如 HTTP 协议的 headers 以 “/r/n” 为字段的分隔符；</li>
<li><strong>在每条消息的头部加一个长度字段</strong>，这恐怕是<strong>最常见的做法</strong>，本文的聊天协议也采用这一办法；</li>
<li>利用消息本身的格式来分包，例如 XML 格式的消息中 <code>...</code> 的配对，或者 JSON 格式中的 <code>{ ... }</code> 的配对。解析这种消息格式通常会用到状态机。</li>
</ul>
<p>在后文的代码讲解中还会仔细讨论用长度字段分包的常见陷阱。</p>
<h2 id="二、聊天服务"><a href="#二、聊天服务" class="headerlink" title="二、聊天服务"></a>二、聊天服务</h2><p>本文实现的聊天服务非常简单，由服务端程序和客户端程序组成，<strong>协议如下</strong>：</p>
<ul>
<li>服务端程序中某个端口侦听 (listen) 新的连接；</li>
<li>客户端向服务端发起连接；</li>
<li>连接建立之后，客户端随时准备接收服务端的消息并在屏幕上显示出来；</li>
<li>客户端接受键盘输入，以回车为界，把消息发送给服务端；</li>
<li>服务端接收到消息之后，依次发送给每个连接到它的客户端；原来发送消息的客户端进程也会收到这条消息；</li>
<li>一个服务端进程可以同时服务多个客户端进程，当有消息到达服务端后，每个客户端进程都会收到同一条消息，服务端广播发送消息的顺序是任意的，不一定哪个客户端会先收到这条消息。</li>
<li>（可选）如果消息 A 先于消息 B 到达服务端，那么每个客户端都会先收到 A 再收到 B。</li>
</ul>
<p>这实际上是一个简单的基于 TCP 的应用层广播协议，<strong>由服务端负责把消息发送给每个连接到它的客户端</strong>。参与“聊天”的既可以是人，也可以是程序。在以后的文章中，我将介绍一个稍微复杂的一点的例子 hub，它有“聊天室”的功能，客户端可以注册特定的 topic(s)，并往某个 topic 发送消息，这样代码更有意思。</p>
<h2 id="三、消息格式"><a href="#三、消息格式" class="headerlink" title="三、消息格式"></a>三、消息格式</h2><p>本聊天服务的消息格式非常简单，“消息”本身是一个字符串，<strong>每条消息的有一个 4 字节的头部，以网络序存放字符串的长度</strong>。消息之间没有间隙，字符串也不一定以 ‘/0’ 结尾。比方说有两条消息 “hello” 和 “chenshuo”，那么打包后的字节流是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00, 0x00, 0x00, 0x05, &#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, 0x00, 0x00, 0x00, 0x08, &#39;c&#39;, &#39;h&#39;, &#39;e&#39;, &#39;n&#39;, &#39;s&#39;, &#39;h&#39;, &#39;u&#39;, &#39;o&#39;</span><br></pre></td></tr></table></figure>

<p>共 21 字节。</p>
<h2 id="四、打包的代码"><a href="#四、打包的代码" class="headerlink" title="四、打包的代码"></a>四、打包的代码</h2><p>这段代码把 const string&amp; message 打包为 muduo::net::Buffer，并通过 conn 发送。</p>
<p><code>muduo/examples/asio/chat/codec.h</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(muduo::net::TcpConnection* conn, <span class="keyword">const</span> <span class="built_in">string</span>&amp; message)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    muduo::net::Buffer buf;</span><br><span class="line">    buf.append(message.data(), message.size());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> len = muduo::net::sockets::hostToNetwork32(<span class="keyword">static_cast</span>(message.size()));</span><br><span class="line">    buf.prepend(&amp;len, <span class="keyword">sizeof</span> len);</span><br><span class="line"></span><br><span class="line">    conn-&gt;send(&amp;buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>muduo::Buffer 有一个很好的功能，它在头部预留了 8 个字节的空间，这样第 6 行的 prepend() 操作就不需要移动已有的数据，效率较高。</p>
<h2 id="五、分包的代码"><a href="#五、分包的代码" class="headerlink" title="五、分包的代码"></a>五、分包的代码</h2><p>解析数据往往比生成数据复杂，分包打包也不例外。</p>
<p><code>muduo/examples/asio/chat/codec.h</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr&amp; conn, muduo::net::Buffer* buf, muduo::Timestamp receiveTime)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (buf-&gt;readableBytes() &gt;= kHeaderLen) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">void</span>* data = buf-&gt;peek();</span><br><span class="line">        <span class="keyword">int32_t</span> tmp = *<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">int32_t</span>*&gt;(data);</span><br><span class="line">        <span class="keyword">int32_t</span> len = muduo::net::sockets::networkToHost32(tmp);</span><br><span class="line">        <span class="keyword">if</span> (len &gt; <span class="number">65536</span> || len &lt; <span class="number">0</span>) &#123; </span><br><span class="line">            LOG_ERROR &lt;&lt; <span class="string">"Invalid length "</span> &lt;&lt; len;</span><br><span class="line">            conn-&gt;shutdown();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (buf-&gt;readableBytes() &gt;= len + kHeaderLen) &#123;</span><br><span class="line">            buf-&gt;retrieve(kHeaderLen);</span><br><span class="line">            <span class="function">muduo::<span class="built_in">string</span> <span class="title">message</span><span class="params">(buf-&gt;peek(), len)</span></span>;</span><br><span class="line">            buf-&gt;retrieve(len);</span><br><span class="line">            messageCallback_(conn, message, receiveTime);  <span class="comment">// 收到完整的消息，通知用户</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码第 7 行用了 while 循环来反复读取数据，直到 Buffer 中的数据不够一条完整的消息。请读者思考，如果换成 if (buf-&gt;readableBytes() &gt;= kHeaderLen) 会有什么后果。</p>
<p>以前面提到的两条消息的字节流为例：</p>
<p>0x00, 0x00, 0x00, 0x05, ‘h’, ‘e’, ‘l’, ‘l’, ‘o’, 0x00, 0x00, 0x00, 0x08, ‘c’, ‘h’, ‘e’, ‘n’, ‘s’, ‘h’, ‘u’, ‘o’</p>
<p>假设数据最终都全部到达，onMessage() 至少要能正确处理以下各种数据到达的次序，每种情况下 messageCallback_ 都应该被调用两次：</p>
<ol>
<li>每次收到一个字节的数据，onMessage() 被调用 21 次；</li>
<li>数据分两次到达，第一次收到 2 个字节，不足消息的长度字段；</li>
<li>数据分两次到达，第一次收到 4 个字节，刚好够长度字段，但是没有 body；</li>
<li>数据分两次到达，第一次收到 8 个字节，长度完整，但 body 不完整；</li>
<li>数据分两次到达，第一次收到 9 个字节，长度完整，body 也完整；</li>
<li>数据分两次到达，第一次收到 10 个字节，第一条消息的长度完整、body 也完整，第二条消息长度不完整；</li>
<li>请自行移动分割点，验证各种情况；</li>
<li>数据一次就全部到达，这时必须用 while 循环来读出两条消息，否则消息会堆积。</li>
</ol>
<p>请读者验证 onMessage() 是否做到了以上几点。这个例子充分说明了 non-blocking read 必须和 input buffer 一起使用。这也解释了为什么该用 while 而不是 if 。</p>
<h2 id="六、编解码器-LengthHeaderCodec"><a href="#六、编解码器-LengthHeaderCodec" class="headerlink" title="六、编解码器 LengthHeaderCodec"></a>六、编解码器 LengthHeaderCodec</h2><p>有人评论 Muduo 的接收缓冲区不能设置回调函数的触发条件，确实如此。每当 socket 可读，Muduo 的 TcpConnection 会读取数据并存入 Input Buffer，然后回调用户的函数。不过，<strong>一个简单的间接层就能解决问题</strong>，让用户代码只关心“消息到达”而不是“数据到达”，如本例中的 LengthHeaderCodec 所展示的那一样。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MUDUO_EXAMPLES_ASIO_CHAT_CODEC_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MUDUO_EXAMPLES_ASIO_CHAT_CODEC_H</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">using</span> muduo::Logger;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LengthHeaderCodec</span> :</span> boost::noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> boost::function&lt;<span class="keyword">void</span> (<span class="keyword">const</span> muduo::net::TcpConnectionPtr&amp;, <span class="keyword">const</span> muduo::<span class="built_in">string</span>&amp; message, muduo::Timestamp)&gt; StringMessageCallback;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">LengthHeaderCodec</span><span class="params">(<span class="keyword">const</span> StringMessageCallback&amp; cb)</span> : <span class="title">messageCallback_</span><span class="params">(cb)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr&amp; conn, muduo::net::Buffer* buf, muduo::Timestamp receiveTime)</span> </span>&#123; 同上 &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(muduo::net::TcpConnection* conn, <span class="keyword">const</span> muduo::<span class="built_in">string</span>&amp; message)</span> </span>&#123; 同上 &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    StringMessageCallback messageCallback_;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">size_t</span> kHeaderLen = <span class="keyword">sizeof</span>(<span class="keyword">int32_t</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// MUDUO_EXAMPLES_ASIO_CHAT_CODEC_H</span></span></span><br></pre></td></tr></table></figure>

<p>这段代码把以 Buffer* 为参数的 MessageCallback 转换成了以 const string&amp; 为参数的 StringMessageCallback，<strong>让用户代码不必关心分包操作。客户端和服务端都能从中受益</strong>。</p>
<h2 id="七、服务端的实现"><a href="#七、服务端的实现" class="headerlink" title="七、服务端的实现"></a>七、服务端的实现</h2><p>聊天服务器的服务端代码小于 100 行，不到 asio 的一半。</p>
<p>请先阅读第 68 行起的数据成员的定义。除了经常见到的 EventLoop 和 TcpServer，ChatServer 还定义了 codec_ 和 std::set connections_ 作为成员，connections_ 是目前已建立的客户连接，<strong>在收到消息之后，服务器会遍历整个容器，把消息广播给其中每一个 TCP 连接</strong>。</p>
<p>首先，在构造函数里注册回调：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"codec.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo::net;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChatServer</span> :</span> boost::noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ChatServer(EventLoop* loop, <span class="keyword">const</span> InetAddress&amp; listenAddr): </span><br><span class="line">            loop_(loop),</span><br><span class="line">            server_(loop, listenAddr, <span class="string">"ChatServer"</span>),</span><br><span class="line">            codec_(boost::bind(&amp;ChatServer::onStringMessage, <span class="keyword">this</span>, _1, _2, _3)) &#123;</span><br><span class="line">  </span><br><span class="line">        server_.setConnectionCallback(boost::bind(&amp;ChatServer::onConnection, <span class="keyword">this</span>, _1));</span><br><span class="line">        server_.setMessageCallback(boost::bind(&amp;LengthHeaderCodec::onMessage, &amp;codec_, _1, _2, _3));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        server_.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里有几点值得注意，<strong>在以往的代码里是直接把本 class 的 onMessage() 注册给 server_；这里我们把 LengthHeaderCodec::onMessage() 注册给 server_，然后向 codec_ 注册了 ChatServer::onStringMessage()，等于说让 codec_ 负责解析消息，然后把完整的消息回调给 ChatServer</strong>。这正是我前面提到的“一个简单的间接层”，在不增加 Muduo 库的复杂度的前提下，提供了足够的灵活性让我们在用户代码里完成需要的工作。</p>
<p>另外，<strong>server_.start() 绝对不能在构造函数里调用，这么做将来会有线程安全的问题</strong>，见我在《当析构函数遇到多线程 ── C++ 中线程安全的对象回调》一文中的论述。</p>
<p>以下是处理连接的建立和断开的代码，注意它把新建的连接加入到 connections_ 容器中，把已断开的连接从容器中删除。这么做是为了避免内存和资源泄漏，<strong>TcpConnectionPtr 是 boost::shared_ptr，是 muduo 里唯一一个默认采用 shared_ptr 来管理生命期的对象</strong>。以后我们会谈到这么做的原因。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn)</span> </span>&#123;</span><br><span class="line">        LOG_INFO &lt;&lt; conn-&gt;localAddress().toHostPort() &lt;&lt; <span class="string">" -&gt; "</span> &lt;&lt; conn-&gt;peerAddress().toHostPort() &lt;&lt; <span class="string">" is "</span> &lt;&lt; (conn-&gt;connected() ? <span class="string">"UP"</span> : <span class="string">"DOWN"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (conn-&gt;connected()) &#123;</span><br><span class="line">            connections_.insert(conn);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            connections_.erase(conn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>以下是服务端处理消息的代码，它遍历整个 connections_ 容器，把消息打包发送给各个客户连接。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onStringMessage</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp; message, Timestamp)</span> </span>&#123;</span><br><span class="line">    <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (ConnectionList::iterator it = connections_.begin(); it != connections_.end(); ++it) &#123; </span><br><span class="line">        codec_.send(get_pointer(*it), message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据成员：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">set</span> ConnectionList;</span><br><span class="line">EventLoop* loop_;</span><br><span class="line">TcpServer server_;</span><br><span class="line">LengthHeaderCodec codec_;</span><br><span class="line">MutexLock mutex_;</span><br><span class="line">ConnectionList connections_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>main() 函数里边是例行公事的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">"pid = "</span> &lt;&lt; getpid();</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        EventLoop loop;</span><br><span class="line">        <span class="keyword">uint16_t</span> port = <span class="keyword">static_cast</span>(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">        <span class="function">InetAddress <span class="title">serverAddr</span><span class="params">(port)</span></span>;</span><br><span class="line">        <span class="function">ChatServer <span class="title">server</span><span class="params">(&amp;loop, serverAddr)</span></span>;</span><br><span class="line">        server.start();</span><br><span class="line">        loop.loop();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage: %s port/n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你读过 asio 的对应代码，会不会觉得 Reactor 往往比 Proactor 容易使用？</p>
<h2 id="八、客户端的实现"><a href="#八、客户端的实现" class="headerlink" title="八、客户端的实现"></a>八、客户端的实现</h2><p>我有时觉得服务端的程序常常比客户端的更容易写，聊天服务器再次验证了我的看法。客户端的复杂性来自于它要读取键盘输入，而 EventLoop 是独占线程的，<strong>所以我用了两个线程，main() 函数所在的线程负责读键盘，另外用一个 EventLoopThread 来处理网络 IO</strong>。我暂时没有把标准输入输出融入 Reactor 的想法，因为服务器程序的 stdin 和 stdout 往往是重定向了的。</p>
<p>来看代码，首先，在构造函数里注册回调，并使用了跟前面一样的 LengthHeaderCodec <strong>作为中间层</strong>，负责打包分包。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"codec.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo::net;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChatClient</span> :</span> boost::noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ChatClient(EventLoop* loop, <span class="keyword">const</span> InetAddress&amp; listenAddr)</span><br><span class="line">            : loop_(loop),</span><br><span class="line">              client_(loop, listenAddr, <span class="string">"ChatClient"</span>),</span><br><span class="line">              codec_(boost::bind(&amp;ChatClient::onStringMessage, <span class="keyword">this</span>, _1, _2, _3)) &#123;</span><br><span class="line">        client_.setConnectionCallback(boost::bind(&amp;ChatClient::onConnection, <span class="keyword">this</span>, _1));</span><br><span class="line">        client_.setMessageCallback(boost::bind(&amp;LengthHeaderCodec::onMessage, &amp;codec_, _1, _2, _3));</span><br><span class="line">        client_.enableRetry();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        client_.connect();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>disconnect() 目前为空，客户端的连接由操作系统在进程终止时关闭。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disconnect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// client_.disconnect();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>write() 会由 main 线程调用，所以要加锁，这个锁不是为了保护 TcpConnection，而是保护 shared_ptr。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; message)</span> </span>&#123;</span><br><span class="line">    <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (connection_) &#123;</span><br><span class="line">        codec_.send(get_pointer(connection_), message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>onConnection() 会由 EventLoop 线程调用，所以要加锁以保护 shared_ptr。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn)</span> </span>&#123;</span><br><span class="line">        LOG_INFO &lt;&lt; conn-&gt;localAddress().toHostPort() &lt;&lt; <span class="string">" -&gt; "</span> &lt;&lt; conn-&gt;peerAddress().toHostPort() &lt;&lt; <span class="string">" is "</span> &lt;&lt; (conn-&gt;connected() ? <span class="string">"UP"</span> : <span class="string">"DOWN"</span>);</span><br><span class="line">  </span><br><span class="line">        <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (conn-&gt;connected()) &#123;</span><br><span class="line">            connection_ = conn;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            connection_.reset();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>把收到的消息打印到屏幕，这个函数由 EventLoop 线程调用，但是不用加锁，因为 printf() 是线程安全的。<br><strong>注意这里不能用 cout，它不是线程安全的</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onStringMessage</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp; message, Timestamp)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&lt;&lt;&lt; %s/n"</span>, message.c_str());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据成员：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EventLoop* loop_;</span><br><span class="line">TcpClient client_;</span><br><span class="line">LengthHeaderCodec codec_;</span><br><span class="line">MutexLock mutex_;</span><br><span class="line">TcpConnectionPtr connection_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>main() 函数里除了例行公事，还要启动 EventLoop 线程和读取键盘输入。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">"pid = "</span> &lt;&lt; getpid();</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        EventLoopThread loopThread;</span><br><span class="line">        <span class="keyword">uint16_t</span> port = <span class="keyword">static_cast</span>(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">        <span class="function">InetAddress <span class="title">serverAddr</span><span class="params">(argv[<span class="number">1</span>], port)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function">ChatClient <span class="title">client</span><span class="params">(loopThread.startLoop(), serverAddr)</span></span>; <span class="comment">// 注册到 EventLoopThread 的 EventLoop 上。</span></span><br><span class="line">        client.connect();</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> line;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">std</span>::getline(<span class="built_in">std</span>::<span class="built_in">cin</span>, line)) &#123;</span><br><span class="line">            <span class="function"><span class="built_in">string</span> <span class="title">message</span><span class="params">(line.c_str())</span></span>; <span class="comment">// 这里似乎多此一举，可直接发送 line。这里是</span></span><br><span class="line">            client.write(message);</span><br><span class="line">        &#125;</span><br><span class="line">        client.disconnect();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage: %s host_ip port/n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="九、简单测试"><a href="#九、简单测试" class="headerlink" title="九、简单测试"></a>九、简单测试</h2><p>开三个命令行窗口，在第一个运行</p>
<p><code>$ ./asio_chat_server 3000</code></p>
<p>第二个运行</p>
<p><code>$ ./asio_chat_client 127.0.0.1 3000</code></p>
<p>第三个运行同样的命令</p>
<p><code>$ ./asio_chat_client 127.0.0.1 3000</code></p>
<p>这样就有两个客户端进程参与聊天。在第二个窗口里输入一些字符并回车，字符会出现在本窗口和第三个窗口中。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B%E4%B9%8B%E4%BA%8C%EF%BC%9ABoost.Asio%E7%9A%84%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/" data-id="ck7naw84s00122cveh3v3ceu5" class="article-share-link">分享到</a>
      

      
        <a href="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B%E4%B9%8B%E4%BA%8C%EF%BC%9ABoost.Asio%E7%9A%84%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Boost/" rel="tag">Boost</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cpp/" rel="tag">Cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Net/" rel="tag">Net</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-为什么muduo的shutdown()没有直接关闭TCP连接？" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/%E4%B8%BA%E4%BB%80%E4%B9%88muduo%E7%9A%84shutdown()%E6%B2%A1%E6%9C%89%E7%9B%B4%E6%8E%A5%E5%85%B3%E9%97%ADTCP%E8%BF%9E%E6%8E%A5%EF%BC%9F/" class="article-date">
  <time datetime="2020-03-09T02:59:18.134Z" itemprop="datePublished">2020-03-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/">开源组件</a>►<a class="article-category-link" href="/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/">muduo</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/%E4%B8%BA%E4%BB%80%E4%B9%88muduo%E7%9A%84shutdown()%E6%B2%A1%E6%9C%89%E7%9B%B4%E6%8E%A5%E5%85%B3%E9%97%ADTCP%E8%BF%9E%E6%8E%A5%EF%BC%9F/">为什么 muduo 的 shutdown() 没有直接关闭 TCP 连接？</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>原文链接 <a href="https://blog.csdn.net/Solstice/article/details/6208634" target="_blank" rel="noopener">https://blog.csdn.net/Solstice/article/details/6208634</a></p>
</blockquote>
<ul>
<li><a href="#%e9%97%ae%e9%a2%98">问题：</a></li>
<li><a href="#%e7%9b%b8%e5%85%b3%e4%bb%a3%e7%a0%81">相关代码</a></li>
<li><a href="#%e5%9b%9e%e7%ad%94">回答</a></li>
</ul>
<h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在 simple 中的 daytime 示例中，服务端主动关闭时调用的是如下函数序列，这不是只是关闭了连接上的写操作吗，怎么是关闭了整个连接？</span><br></pre></td></tr></table></figure>

<h3 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h3><p><code>daytime.cc</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DaytimeServer::onConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn)</span> </span>&#123;</span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">"DaytimeServer - "</span> &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; <span class="string">" -&gt; "</span></span><br><span class="line">             &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; <span class="string">" is "</span></span><br><span class="line">             &lt;&lt; (conn-&gt;connected() ? <span class="string">"UP"</span> : <span class="string">"DOWN"</span>);</span><br><span class="line">    <span class="keyword">if</span> (conn-&gt;connected()) &#123;</span><br><span class="line">        conn-&gt;send(Timestamp::now().toFormattedString() + <span class="string">"\n"</span>);</span><br><span class="line">        conn-&gt;shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TcpConnection.cc</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> use compare and swap</span></span><br><span class="line">    <span class="keyword">if</span> (state_ == kConnected) &#123;</span><br><span class="line">        setState(kDisconnecting);</span><br><span class="line">        <span class="comment">// <span class="doctag">FIXME:</span> shared_from_this()?</span></span><br><span class="line">        loop_-&gt;runInLoop(<span class="built_in">std</span>::bind(&amp;TcpConnection::shutdownInLoop, <span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::shutdownInLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    <span class="keyword">if</span> (!channel_-&gt;isWriting()) &#123;</span><br><span class="line">        <span class="comment">// we are not writing</span></span><br><span class="line">        socket_-&gt;shutdownWrite();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Socket.cc</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Socket::shutdownWrite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sockets::shutdownWrite(sockfd_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sockets::shutdownWrite</span><span class="params">(<span class="keyword">int</span> sockfd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (::shutdown(sockfd, SHUT_WR) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOG_SYSERR &lt;&lt; <span class="string">"sockets::shutdownWrite"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="回答"><a href="#回答" class="headerlink" title="回答"></a>回答</h3><p>Muduo TcpConnection <strong>没有提供 close，而只提供 shutdown</strong> ，这么做是为了<strong>收发数据的完整性</strong>。</p>
<p><strong>TCP 是一个全双工协议，同一个文件描述符既可读又可写，</strong> shutdownWrite() 关闭了“写”方向的连接，保留了“读”方向，这称为 TCP half-close。如果直接 close(socket_fd)，那么 socket_fd 就不能读或写了。</p>
<p>用 shutdown 而不用 close 的效果是，如果对方已经发送了数据，这些数据还“在路上”，那么 muduo 不会漏收这些数据。换句话说，muduo 在 TCP 这一层面解决了“当你打算关闭网络连接的时候，如何得知对方有没有发了一些数据而你还没有收到？”这一问题。当然，这个问题也可以在上面的协议层解决，双方商量好不再互发数据，就可以直接断开连接。</p>
<p><strong>等于说 muduo 把“主动关闭连接”这件事情分成两步来做</strong>，如果要主动关闭连接，它<strong>会先关本地“写”端</strong>，等对方关闭之后，<strong>再关本地“读”端</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">练习：阅读代码，回答“如果被动关闭连接，muduo 的行为如何？</span><br></pre></td></tr></table></figure>
<p>提示：<strong>muduo 在 read() 返回 0 的时候会回调 connection callback</strong>，这样客户代码就知道对方断开连接了。</p>
<p><strong>Muduo 这种关闭连接的方式对对方也有要求，那就是对方 read() 到 0 字节之后会主动关闭连接</strong>（无论 shutdownWrite() 还是 close()），一般的网络程序都会这样，不是什么问题。当然，这么做有一个潜在的安全漏洞，万一对方故意不不关，那么 muduo 的连接就一直半开着，消耗系统资源。</p>
<p><strong>完整的流程</strong>是：我们发完了数据，于是 shutdownWrite，发送 TCP FIN 分节，<strong>对方会读到 0 字节</strong>，然后对方通常会关闭连接，这样 muduo 会读到 0 字节，然后 muduo 关闭连接。（思考题，在 shutdown() 之后，muduo 回调 connection callback 的时间间隔大约是一个 round-trip time，为什么？）</p>
<p>另外，如果有必要，对方可以在 read() 返回 0 之后继续发送数据，这是直接利用了 half-close TCP 连接。muduo 会收到这些数据，通过 message callback 通知客户代码。</p>
<p><strong>那么 muduo 什么时候真正 close socket 呢？在 TcpConnection 对象析构的时候</strong>。TcpConnection 持有一个 Socket 对象，<strong>Socket 是一个 RAII handler，它的析构函数会 close(sockfd_)</strong>。这样，如果发生 TcpConnection 对象泄漏，那么我们从 /proc/pid/fd/ 就能找到没有关闭的文件描述符，便于查错。</p>
<p><strong>muduo 在 read() 返回 0 的时候会回调 connection callback，然后把 TcpConnection 的引用计数减一，如果 TcpConnection 的引用计数降到零，它就会析构了。</strong></p>
<p>参考：</p>
<p>《TCP/IP 详解》第一卷第 18.5 节，TCP Half-Close。</p>
<p>《UNIX 网络编程》第一卷第三版第 6.6 节， shutdown() 函数。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/%E4%B8%BA%E4%BB%80%E4%B9%88muduo%E7%9A%84shutdown()%E6%B2%A1%E6%9C%89%E7%9B%B4%E6%8E%A5%E5%85%B3%E9%97%ADTCP%E8%BF%9E%E6%8E%A5%EF%BC%9F/" data-id="ck7naw84x001e2cve9k817cr3" class="article-share-link">分享到</a>
      

      
        <a href="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/%E4%B8%BA%E4%BB%80%E4%B9%88muduo%E7%9A%84shutdown()%E6%B2%A1%E6%9C%89%E7%9B%B4%E6%8E%A5%E5%85%B3%E9%97%ADTCP%E8%BF%9E%E6%8E%A5%EF%BC%9F/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cpp/" rel="tag">Cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP/" rel="tag">TCP</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-muduo网络编程示例之一：五个简单TCP协议" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B%E4%B9%8B%E4%B8%80%EF%BC%9A%E4%BA%94%E4%B8%AA%E7%AE%80%E5%8D%95TCP%E5%8D%8F%E8%AE%AE/" class="article-date">
  <time datetime="2020-03-09T02:58:09.704Z" itemprop="datePublished">2020-03-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/">开源组件</a>►<a class="article-category-link" href="/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/">muduo</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B%E4%B9%8B%E4%B8%80%EF%BC%9A%E4%BA%94%E4%B8%AA%E7%AE%80%E5%8D%95TCP%E5%8D%8F%E8%AE%AE/">muduo 网络编程示例之一：五个简单 TCP 协议</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>原文链接 <a href="https://blog.csdn.net/Solstice/article/details/6171905" target="_blank" rel="noopener">https://blog.csdn.net/Solstice/article/details/6171905</a></p>
</blockquote>
<p>本文将介绍第一个示例：五个简单 TCP 网络服务协议，包括 echo (RFC 862)、discard (RFC 863)、chargen (RFC 864)、daytime (RFC 867)、time (RFC 868)，以及 time 协议的客户端。各协议的功能简介如下：</p>
<ul>
<li>discard - 丢弃所有收到的数据；</li>
<li>daytime - 服务端 accept 连接之后，以字符串形式发送当前时间，然后主动断开连接；</li>
<li>time - 服务端 accept 连接之后，以二进制形式发送当前时间（从 Epoch 到现在的秒数），然后主动断开连接；我们需要一个客户程序来把收到的时间转换为字符串。</li>
<li>echo - 回显服务，把收到的数据发回客户端；</li>
<li>chargen - 服务端 accept 连接之后，不停地发送测试数据。</li>
</ul>
<p><strong>以上五个协议使用不同的端口，可以放到同一个进程中实现，且不必使用多线程</strong>。完整的代码见 muduo/examples/simple，下载地址 <a href="http://muduo.googlecode.com/files/muduo-0.1.6-alpha.tar.gz" target="_blank" rel="noopener">http://muduo.googlecode.com/files/muduo-0.1.6-alpha.tar.gz</a> 。</p>
<ul>
<li><a href="#%e4%b8%80discard">一、discard</a></li>
<li><a href="#%e4%ba%8cdaytime">二、daytime</a></li>
<li><a href="#%e4%b8%89time">三、time</a><ul>
<li><a href="#server">server</a></li>
<li><a href="#client">client</a></li>
</ul>
</li>
<li><a href="#%e5%9b%9becho">四、echo</a></li>
<li><a href="#%e4%ba%94chargen">五、chargen</a><ul>
<li><a href="#server-1">server</a></li>
<li><a href="#client-1">client</a></li>
</ul>
</li>
<li><a href="#%e5%85%adfive-in-one">六、Five in one</a></li>
</ul>
<h2 id="一、discard"><a href="#一、discard" class="headerlink" title="一、discard"></a>一、discard</h2><p>Discard 恐怕算是最简单的长连接 TCP 应用层协议，它只需要关注“三个半事件”中的“消息/数据到达”事件</p>
<p><code>main.cpp</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">"pid = "</span> &lt;&lt; getpid();</span><br><span class="line">    EventLoop loop;</span><br><span class="line">    <span class="function">InetAddress <span class="title">listenAddr</span><span class="params">(<span class="number">2009</span>)</span></span>;</span><br><span class="line">    <span class="function">DiscardServer <span class="title">server</span><span class="params">(&amp;loop, listenAddr)</span></span>;</span><br><span class="line">    server.start();</span><br><span class="line">    loop.loop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>discard.h</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiscardServer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DiscardServer(muduo::net::EventLoop *loop,</span><br><span class="line">                  <span class="keyword">const</span> muduo::net::InetAddress &amp;listenAddr);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onConnection</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr &amp;conn)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr &amp;conn,</span></span></span><br><span class="line"><span class="function"><span class="params">                   muduo::net::Buffer *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">                   muduo::Timestamp time)</span></span>;</span><br><span class="line"></span><br><span class="line">    muduo::net::TcpServer server_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>discard.cc</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">DiscardServer::DiscardServer(EventLoop *loop,</span><br><span class="line">                             <span class="keyword">const</span> InetAddress &amp;listenAddr)</span><br><span class="line">        : server_(loop, listenAddr, <span class="string">"DiscardServer"</span>) &#123;</span><br><span class="line">    server_.setConnectionCallback(</span><br><span class="line">            <span class="built_in">std</span>::bind(&amp;DiscardServer::onConnection, <span class="keyword">this</span>, _1));</span><br><span class="line">    server_.setMessageCallback(</span><br><span class="line">            <span class="built_in">std</span>::bind(&amp;DiscardServer::onMessage, <span class="keyword">this</span>, _1, _2, _3));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DiscardServer::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    server_.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DiscardServer::onConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn)</span> </span>&#123;</span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">"DiscardServer - "</span> &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; <span class="string">" -&gt; "</span></span><br><span class="line">             &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; <span class="string">" is "</span></span><br><span class="line">             &lt;&lt; (conn-&gt;connected() ? <span class="string">"UP"</span> : <span class="string">"DOWN"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DiscardServer::onMessage</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Buffer *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Timestamp time)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">msg</span><span class="params">(buf-&gt;retrieveAllAsString())</span></span>;</span><br><span class="line">    LOG_INFO &lt;&lt; conn-&gt;name() &lt;&lt; <span class="string">" discards "</span> &lt;&lt; msg.size()</span><br><span class="line">             &lt;&lt; <span class="string">" bytes received at "</span> &lt;&lt; time.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、daytime"><a href="#二、daytime" class="headerlink" title="二、daytime"></a>二、daytime</h2><p>Daytime 是<strong>短连接协议</strong>，<strong>在发送完当前时间后，由服务端主动断开连接</strong>。它只需要关注“三个半事件”中的“连接已建立”事件</p>
<p>仅关注两个回调函数，其他部分和 discard 大同小异</p>
<p><code>daytime.cc</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DaytimeServer::onConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn)</span> </span>&#123;</span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">"DaytimeServer - "</span> &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; <span class="string">" -&gt; "</span></span><br><span class="line">             &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; <span class="string">" is "</span></span><br><span class="line">             &lt;&lt; (conn-&gt;connected() ? <span class="string">"UP"</span> : <span class="string">"DOWN"</span>);</span><br><span class="line">    <span class="keyword">if</span> (conn-&gt;connected()) &#123;</span><br><span class="line">        conn-&gt;send(Timestamp::now().toFormattedString() + <span class="string">"\n"</span>);</span><br><span class="line">        conn-&gt;shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DaytimeServer::onMessage</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Buffer *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Timestamp time)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">msg</span><span class="params">(buf-&gt;retrieveAllAsString())</span></span>;</span><br><span class="line">    LOG_INFO &lt;&lt; conn-&gt;name() &lt;&lt; <span class="string">" discards "</span> &lt;&lt; msg.size()</span><br><span class="line">             &lt;&lt; <span class="string">" bytes received at "</span> &lt;&lt; time.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较值得注意的是 onConnection 方法，发送完数据以后，由 server 端 shutdown 这个 socket</p>
<h2 id="三、time"><a href="#三、time" class="headerlink" title="三、time"></a>三、time</h2><p>Time 协议与 daytime 极为类似，只不过它返回的不是日期时间字符串，而是一个 32-bit 整数，表示从 1970-01-01 00:00:00Z 到现在的秒数。当然，这个协议有“2038 年问题”。服务端只需要关注“三个半事件”中的“连接已建立”事件。</p>
<h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><p>server 端和 daytime 差不多，也是 send 以后主动 shutdown</p>
<p><code>time.cc</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TimeServer::onConnection</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr &amp;conn)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">"TimeServer - "</span> &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; <span class="string">" -&gt; "</span></span><br><span class="line">             &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; <span class="string">" is "</span></span><br><span class="line">             &lt;&lt; (conn-&gt;connected() ? <span class="string">"UP"</span> : <span class="string">"DOWN"</span>);</span><br><span class="line">    <span class="keyword">if</span> (conn-&gt;connected()) &#123;</span><br><span class="line">        <span class="keyword">time_t</span> now = ::time(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">int32_t</span> be32 = sockets::hostToNetwork32(<span class="keyword">static_cast</span>&lt;<span class="keyword">int32_t</span>&gt;(now));</span><br><span class="line">        conn-&gt;send(&amp;be32, <span class="keyword">sizeof</span> be32);</span><br><span class="line">        conn-&gt;shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TimeServer::onMessage</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr &amp;conn,</span></span></span><br><span class="line"><span class="function"><span class="params">                           muduo::net::Buffer *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">                           muduo::Timestamp time)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">msg</span><span class="params">(buf-&gt;retrieveAllAsString())</span></span>;</span><br><span class="line">    LOG_INFO &lt;&lt; conn-&gt;name() &lt;&lt; <span class="string">" discards "</span> &lt;&lt; msg.size()</span><br><span class="line">             &lt;&lt; <span class="string">" bytes received at "</span> &lt;&lt; time.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="client"><a href="#client" class="headerlink" title="client"></a>client</h3><p>因为 time 服务端发送的是二进制数据，不便直接阅读，<strong>我们编写一个客户端来解析并打印收到的 4 个字节数据</strong>。这个程序只需要关注“三个半事件”中的“消息/数据到达”事件。</p>
<p><code>main.cpp</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">"pid = "</span> &lt;&lt; getpid();</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        EventLoop loop;</span><br><span class="line">        <span class="function">InetAddress <span class="title">serverAddr</span><span class="params">(argv[<span class="number">1</span>], <span class="number">2037</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">TimeClient <span class="title">timeClient</span><span class="params">(&amp;loop, serverAddr)</span></span>;</span><br><span class="line">        timeClient.connect();</span><br><span class="line">        loop.loop();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage: %s host_ip\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>timeclient.h</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeClient</span> :</span> noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TimeClient(EventLoop *loop, <span class="keyword">const</span> InetAddress &amp;serverAddr)</span><br><span class="line">            : loop_(loop),</span><br><span class="line">              client_(loop, serverAddr, <span class="string">"TimeClient"</span>) &#123;</span><br><span class="line">        client_.setConnectionCallback(</span><br><span class="line">                <span class="built_in">std</span>::bind(&amp;TimeClient::onConnection, <span class="keyword">this</span>, _1));</span><br><span class="line">        client_.setMessageCallback(</span><br><span class="line">                <span class="built_in">std</span>::bind(&amp;TimeClient::onMessage, <span class="keyword">this</span>, _1, _2, _3));</span><br><span class="line">        <span class="comment">// client_.enableRetry();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        client_.connect();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    EventLoop *loop_;</span><br><span class="line">    TcpClient client_;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn)</span> </span>&#123;</span><br><span class="line">        LOG_INFO &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; <span class="string">" -&gt; "</span></span><br><span class="line">                 &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; <span class="string">" is "</span></span><br><span class="line">                 &lt;&lt; (conn-&gt;connected() ? <span class="string">"UP"</span> : <span class="string">"DOWN"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!conn-&gt;connected()) &#123;</span><br><span class="line">            loop_-&gt;quit();   <span class="comment">// // 如果连接断开，则终止主循环，退出程序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn, Buffer *buf, Timestamp receiveTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (buf-&gt;readableBytes() &gt;= <span class="keyword">sizeof</span>(<span class="keyword">int32_t</span>)) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">void</span> *data = buf-&gt;peek();</span><br><span class="line">            <span class="keyword">int32_t</span> be32 = *<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">int32_t</span> *&gt;(data);</span><br><span class="line">            buf-&gt;retrieve(<span class="keyword">sizeof</span>(<span class="keyword">int32_t</span>));</span><br><span class="line">            <span class="keyword">time_t</span> time = sockets::networkToHost32(be32);</span><br><span class="line">            <span class="function">Timestamp <span class="title">ts</span><span class="params">(implicit_cast&lt;<span class="keyword">uint64_t</span>&gt;(time) * Timestamp::kMicroSecondsPerSecond)</span></span>;</span><br><span class="line">            LOG_INFO &lt;&lt; <span class="string">"Server time = "</span> &lt;&lt; time &lt;&lt; <span class="string">", "</span> &lt;&lt; ts.toFormattedString();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LOG_INFO &lt;&lt; conn-&gt;name() &lt;&lt; <span class="string">" no enough data "</span> &lt;&lt; buf-&gt;readableBytes()</span><br><span class="line">                     &lt;&lt; <span class="string">" at "</span> &lt;&lt; receiveTime.toFormattedString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意其中考虑到了<strong>如果数据没有一次性收全，已经收到的数据会暂存在 Buffer 里，以等待下一次机会，程序也不会阻塞</strong>。这样即便服务器一个字节一个字节地发送数据，代码还是能正常工作，这也是非阻塞网络编程必须在用户态使用接受缓冲的主要原因。</p>
<h2 id="四、echo"><a href="#四、echo" class="headerlink" title="四、echo"></a>四、echo</h2><p>Echo 是我们遇到的第一个带交互的协议：服务端把客户端发过来的数据原封不动地传回去。它只需要关注“三个半事件”中的“消息/数据到达”事件。</p>
<p><code>echo.cc</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EchoServer::onConnection</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr &amp;conn)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">"EchoServer - "</span> &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; <span class="string">" -&gt; "</span></span><br><span class="line">             &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; <span class="string">" is "</span></span><br><span class="line">             &lt;&lt; (conn-&gt;connected() ? <span class="string">"UP"</span> : <span class="string">"DOWN"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EchoServer::onMessage</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr &amp;conn,</span></span></span><br><span class="line"><span class="function"><span class="params">                           muduo::net::Buffer *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">                           muduo::Timestamp time)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">muduo::<span class="built_in">string</span> <span class="title">msg</span><span class="params">(buf-&gt;retrieveAllAsString())</span></span>;</span><br><span class="line">    LOG_INFO &lt;&lt; conn-&gt;name() &lt;&lt; <span class="string">" echo "</span> &lt;&lt; msg.size() &lt;&lt; <span class="string">" bytes, "</span></span><br><span class="line">             &lt;&lt; <span class="string">"data received at "</span> &lt;&lt; time.toString();</span><br><span class="line">    conn-&gt;send(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码实现的不是行回显(line echo)服务，而是有一点数据就发送一点数据。这样可以避免客户端恶意地不发送换行字符，而服务端又必须缓存已经收到的数据，导致服务器内存暴涨。<strong>但这个程序还是有一个安全漏洞，即如果客户端故意不断发生数据，但从不接收，那么服务端的发送缓冲区会一直堆积，导致内存暴涨。</strong>解决办法可以参考下面的 chargen 协议。</p>
<h2 id="五、chargen"><a href="#五、chargen" class="headerlink" title="五、chargen"></a>五、chargen</h2><p>Chargen 协议很特殊，它<strong>只发送数据，不接收数据</strong>。<strong>而且，它发送数据的速度不能快过客户端接收的速度</strong>，因此需要关注“三个半事件”中的半个“消息/数据发送完毕”事件(onWriteComplete)。</p>
<h3 id="server-1"><a href="#server-1" class="headerlink" title="server"></a>server</h3><p><code>chargen.h</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChargenServer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ChargenServer(muduo::net::EventLoop *loop,</span><br><span class="line">                  <span class="keyword">const</span> muduo::net::InetAddress &amp;listenAddr,</span><br><span class="line">                  <span class="keyword">bool</span> print = <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onConnection</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr &amp;conn)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr &amp;conn,</span></span></span><br><span class="line"><span class="function"><span class="params">                   muduo::net::Buffer *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">                   muduo::Timestamp time)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onWriteComplete</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr &amp;conn)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printThroughput</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    muduo::net::TcpServer server_;</span><br><span class="line"></span><br><span class="line">    muduo::<span class="built_in">string</span> message_;</span><br><span class="line">    <span class="keyword">int64_t</span> transferred_;</span><br><span class="line">    muduo::Timestamp startTime_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>chargen.cc</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">ChargenServer::ChargenServer(EventLoop *loop,</span><br><span class="line">                             <span class="keyword">const</span> InetAddress &amp;listenAddr,</span><br><span class="line">                             <span class="keyword">bool</span> print)</span><br><span class="line">        : server_(loop, listenAddr, <span class="string">"ChargenServer"</span>),</span><br><span class="line">          transferred_(<span class="number">0</span>),</span><br><span class="line">          startTime_(Timestamp::now()) &#123;</span><br><span class="line"></span><br><span class="line">    server_.setConnectionCallback(</span><br><span class="line">            <span class="built_in">std</span>::bind(&amp;ChargenServer::onConnection, <span class="keyword">this</span>, _1));</span><br><span class="line">    server_.setMessageCallback(</span><br><span class="line">            <span class="built_in">std</span>::bind(&amp;ChargenServer::onMessage, <span class="keyword">this</span>, _1, _2, _3));</span><br><span class="line">    server_.setWriteCompleteCallback(</span><br><span class="line">            <span class="built_in">std</span>::bind(&amp;ChargenServer::onWriteComplete, <span class="keyword">this</span>, _1));</span><br><span class="line">    <span class="keyword">if</span> (print) &#123;</span><br><span class="line">        loop-&gt;runEvery(<span class="number">3.0</span>, <span class="built_in">std</span>::bind(&amp;ChargenServer::printThroughput, <span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> line;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">33</span>; i &lt; <span class="number">127</span>; ++i) &#123;</span><br><span class="line">        line.push_back(<span class="keyword">char</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">    line += line;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">127</span> - <span class="number">33</span>; ++i) &#123;</span><br><span class="line">        message_ += line.substr(i, <span class="number">72</span>) + <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChargenServer::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    server_.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChargenServer::onConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn)</span> </span>&#123;</span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">"ChargenServer - "</span> &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; <span class="string">" -&gt; "</span></span><br><span class="line">             &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; <span class="string">" is "</span></span><br><span class="line">             &lt;&lt; (conn-&gt;connected() ? <span class="string">"UP"</span> : <span class="string">"DOWN"</span>);</span><br><span class="line">    <span class="keyword">if</span> (conn-&gt;connected()) &#123;   <span class="comment">// 在连接建立时发生第一次数据</span></span><br><span class="line">        conn-&gt;setTcpNoDelay(<span class="literal">true</span>);</span><br><span class="line">        conn-&gt;send(message_);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChargenServer::onMessage</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Buffer *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Timestamp time)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">msg</span><span class="params">(buf-&gt;retrieveAllAsString())</span></span>;</span><br><span class="line">    LOG_INFO &lt;&lt; conn-&gt;name() &lt;&lt; <span class="string">" discards "</span> &lt;&lt; msg.size()</span><br><span class="line">             &lt;&lt; <span class="string">" bytes received at "</span> &lt;&lt; time.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChargenServer::onWriteComplete</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn)</span> </span>&#123;     <span class="comment">// 继续发送数据</span></span><br><span class="line">    transferred_ += message_.size();</span><br><span class="line">    conn-&gt;send(message_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChargenServer::printThroughput</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Timestamp endTime = Timestamp::now();</span><br><span class="line">    <span class="keyword">double</span> time = timeDifference(endTime, startTime_);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%4.3f MiB/s\n"</span>, <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(transferred_) / time / <span class="number">1024</span> / <span class="number">1024</span>);</span><br><span class="line">    transferred_ = <span class="number">0</span>;</span><br><span class="line">    startTime_ = endTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="client-1"><a href="#client-1" class="headerlink" title="client"></a>client</h3><p><code>chargenclient.cc</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChargenClient</span> :</span> noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ChargenClient(EventLoop *loop, <span class="keyword">const</span> InetAddress &amp;listenAddr)</span><br><span class="line">            : loop_(loop),</span><br><span class="line">              client_(loop, listenAddr, <span class="string">"ChargenClient"</span>) &#123;</span><br><span class="line">        client_.setConnectionCallback(</span><br><span class="line">                <span class="built_in">std</span>::bind(&amp;ChargenClient::onConnection, <span class="keyword">this</span>, _1));</span><br><span class="line">        client_.setMessageCallback(</span><br><span class="line">                <span class="built_in">std</span>::bind(&amp;ChargenClient::onMessage, <span class="keyword">this</span>, _1, _2, _3));</span><br><span class="line">        <span class="comment">// client_.enableRetry();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        client_.connect();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn)</span> </span>&#123;</span><br><span class="line">        LOG_INFO &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; <span class="string">" -&gt; "</span></span><br><span class="line">                 &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; <span class="string">" is "</span></span><br><span class="line">                 &lt;&lt; (conn-&gt;connected() ? <span class="string">"UP"</span> : <span class="string">"DOWN"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!conn-&gt;connected())</span><br><span class="line">            loop_-&gt;quit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn, Buffer *buf, Timestamp receiveTime)</span> </span>&#123;</span><br><span class="line">        buf-&gt;retrieveAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EventLoop *loop_;</span><br><span class="line">    TcpClient client_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="六、Five-in-one"><a href="#六、Five-in-one" class="headerlink" title="六、Five in one"></a>六、Five in one</h2><p>前面五个程序都用到了 EventLoop，这其实是个 Reactor，用于注册和分发 IO 事件。Muduo 遵循 one loop per thread 模型，<strong>多个服务端(TcpServer)和客户端(TcpClient)可以共享同一个 EventLoop，也可以分配到多个 EventLoop 上以发挥多核多线程的好处</strong>。<strong>这里我们把五个服务端用同一个 EventLoop 跑起来，程序还是单线程的，功能却强大了很多</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">"pid = "</span> &lt;&lt; getpid();</span><br><span class="line">    EventLoop loop;  <span class="comment">// one loop shared by multiple servers</span></span><br><span class="line"></span><br><span class="line">    <span class="function">ChargenServer <span class="title">chargenServer</span><span class="params">(&amp;loop, InetAddress(<span class="number">2019</span>))</span></span>;</span><br><span class="line">    chargenServer.start();</span><br><span class="line"></span><br><span class="line">    <span class="function">DaytimeServer <span class="title">daytimeServer</span><span class="params">(&amp;loop, InetAddress(<span class="number">2013</span>))</span></span>;</span><br><span class="line">    daytimeServer.start();</span><br><span class="line"></span><br><span class="line">    <span class="function">DiscardServer <span class="title">discardServer</span><span class="params">(&amp;loop, InetAddress(<span class="number">2009</span>))</span></span>;</span><br><span class="line">    discardServer.start();</span><br><span class="line"></span><br><span class="line">    <span class="function">EchoServer <span class="title">echoServer</span><span class="params">(&amp;loop, InetAddress(<span class="number">2007</span>))</span></span>;</span><br><span class="line">    echoServer.start();</span><br><span class="line"></span><br><span class="line">    <span class="function">TimeServer <span class="title">timeServer</span><span class="params">(&amp;loop, InetAddress(<span class="number">2037</span>))</span></span>;</span><br><span class="line">    timeServer.start();</span><br><span class="line"></span><br><span class="line">    loop.loop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上几个协议的消息格式都非常简单，<strong>没有涉及 TCP 网络编程中常见的分包处理</strong>，在下一篇文章讲 Boost.Asio 的聊天服务器时我们再来讨论这个问题。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B%E4%B9%8B%E4%B8%80%EF%BC%9A%E4%BA%94%E4%B8%AA%E7%AE%80%E5%8D%95TCP%E5%8D%8F%E8%AE%AE/" data-id="ck7naw84t00142cveg60231we" class="article-share-link">分享到</a>
      

      
        <a href="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B%E4%B9%8B%E4%B8%80%EF%BC%9A%E4%BA%94%E4%B8%AA%E7%AE%80%E5%8D%95TCP%E5%8D%8F%E8%AE%AE/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cpp/" rel="tag">Cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP/" rel="tag">TCP</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-muduo中的net组件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E4%B8%AD%E7%9A%84net%E7%BB%84%E4%BB%B6/" class="article-date">
  <time datetime="2020-03-09T02:57:01.062Z" itemprop="datePublished">2020-03-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/">开源组件</a>►<a class="article-category-link" href="/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/">muduo</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E4%B8%AD%E7%9A%84net%E7%BB%84%E4%BB%B6/">muduo 中的 net 组件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><p>类之间的耦合关系</p>
<ol>
<li><p>最底层</p>
<p> Buffer：√</p>
<p> Socket：√</p>
<p> Timer：√</p>
<p> Channel ：和 EventLoop 相互耦合 √</p>
</li>
<li><p>第二层</p>
<p> TimerId ：依赖 Timer √</p>
<p> Poller ：依赖 Channel，和 EventLoop 相互耦合 √</p>
<p> Connector ：依赖 Channel，和 EventLoop 相互耦合 √</p>
<p> Acceptor ：依赖 Channel 和 Socket，和 EventLoop 相互耦合 √</p>
<p> TimerQueue ：依赖 Timer 和 Channel，和 EventLoop 相互耦合 √</p>
</li>
<li><p>第三层</p>
<p> EventLoop ：和 Channel、Poller 和 TimerQueue 相互耦合 √</p>
</li>
<li><p>第四层</p>
<p> EventLoopThread ：依赖 EventLoop √</p>
<p> TcpConnection ：依赖 EventLoop、Socket、Channel 和 Buffer √</p>
</li>
<li><p>第五层</p>
<p> EventLoopThreadPool ：依赖 EventLoopThread √</p>
<p> TcpServer ：依赖 EventLoop、Acceptor、EventLoopThread 和 TcpConnection √</p>
<p> TcpClient ：依赖 EventLoop 、 Connector 和 TcpConnection √</p>
</li>
</ol>
</li>
</ol>
<ul>
<li><a href="#%e6%9c%80%e5%ba%95%e5%b1%82">最底层</a><ul>
<li><a href="#1-buffer">1. Buffer</a></li>
<li><a href="#2-socket">2. Socket</a></li>
<li><a href="#3-timer">3. Timer</a></li>
<li><a href="#4-channel">4. Channel</a></li>
</ul>
</li>
<li><a href="#%e7%ac%ac%e4%ba%8c%e5%b1%82">第二层</a><ul>
<li><a href="#1-timerid">1. TimerId</a></li>
<li><a href="#2-poller">2. Poller</a></li>
<li><a href="#3-acceptor">3. Acceptor</a></li>
<li><a href="#4-timerqueue">4. TimerQueue</a></li>
<li><a href="#5-connector">5. Connector</a></li>
</ul>
</li>
<li><a href="#%e7%ac%ac%e4%b8%89%e5%b1%82">第三层</a><ul>
<li><a href="#1-eventloop">1. EventLoop</a></li>
</ul>
</li>
<li><a href="#%e7%ac%ac%e5%9b%9b%e5%b1%82">第四层</a><ul>
<li><a href="#1-eventloopthread">1. EventLoopThread</a></li>
<li><a href="#2-tcpconnection">2. TcpConnection</a></li>
</ul>
</li>
<li><a href="#%e7%ac%ac%e4%ba%94%e5%b1%82">第五层</a><ul>
<li><a href="#1-eventloopthreadpool">1. EventLoopThreadPool</a></li>
<li><a href="#2-tcpserver">2. TcpServer</a></li>
<li><a href="#3-tcpclient">3. TcpClient</a></li>
</ul>
</li>
</ul>
<h2 id="最底层"><a href="#最底层" class="headerlink" title="最底层"></a>最底层</h2><h3 id="1-Buffer"><a href="#1-Buffer" class="headerlink" title="1. Buffer"></a>1. Buffer</h3><p>见 “./5_Buffer类的设计.md”</p>
<h3 id="2-Socket"><a href="#2-Socket" class="headerlink" title="2. Socket"></a>2. Socket</h3><p>socket_fd 的 wrapper，目标是提供了几种 Socket 的封装，例如 listen、bind 等。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">InetAddress</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Socket</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="keyword">explicit</span> <span class="title">Socket</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span></span><br><span class="line"><span class="function">                    : <span class="title">sockfd_</span><span class="params">(sockfd)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">bindAddress</span><span class="params">(<span class="keyword">const</span> InetAddress &amp;localaddr)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(InetAddress *peeraddr)</span></span>;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> sockfd_;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<h3 id="3-Timer"><a href="#3-Timer" class="headerlink" title="3. Timer"></a>3. Timer</h3><p>用于时间事件的内部类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Timer</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            Timer(TimerCallback cb, Timestamp when, <span class="keyword">double</span> interval)</span><br><span class="line">                    : callback_(<span class="built_in">std</span>::move(cb)),</span><br><span class="line">                      expiration_(when),</span><br><span class="line">                      interval_(interval),</span><br><span class="line">                      repeat_(interval &gt; <span class="number">0.0</span>),</span><br><span class="line">                      sequence_(s_numCreated_.incrementAndGet()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">                callback_();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">restart</span><span class="params">(Timestamp now)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (repeat_) &#123;</span><br><span class="line">                    expiration_ = addTime(now, interval_);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    expiration_ = Timestamp::invalid();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">Timestamp <span class="title">expiration</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">            <span class="function"><span class="keyword">bool</span> <span class="title">repeat</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">            <span class="function"><span class="keyword">int64_t</span> <span class="title">sequence</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">            <span class="function"><span class="keyword">static</span> <span class="keyword">int64_t</span> <span class="title">numCreated</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="keyword">const</span> TimerCallback callback_;</span><br><span class="line">            Timestamp expiration_;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">double</span> interval_;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">bool</span> repeat_;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int64_t</span> sequence_;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">static</span> AtomicInt64 s_numCreated_;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<h3 id="4-Channel"><a href="#4-Channel" class="headerlink" title="4. Channel"></a>4. Channel</h3><p>用于注册与响应 IO 事件</p>
<ol>
<li>构造函数中和一个 EventLoop 绑定、和一个文件描述符 fd 绑定</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">EventLoop</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Channel</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            Channel(EventLoop *loop, <span class="keyword">int</span> fd);</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>IO 事件类型分为两种：ReadEventCallback 和 EventCallback；有四种回调函数类型：readCallback_、writeCallback_、closeCallback_ 和 errorCallback_，可以通过 setXXX 函数来注册（注意 std::move() 将左值转化为了右值引用以减少拷贝次数）</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Channel</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; EventCallback;</span><br><span class="line">            <span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(Timestamp)&gt; ReadEventCallback;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">setReadCallback</span><span class="params">(ReadEventCallback cb)</span> </span>&#123; readCallback_ = <span class="built_in">std</span>::move(cb); &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">setWriteCallback</span><span class="params">(EventCallback cb)</span> </span>&#123; writeCallback_ = <span class="built_in">std</span>::move(cb); &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">setCloseCallback</span><span class="params">(EventCallback cb)</span> </span>&#123; closeCallback_ = <span class="built_in">std</span>::move(cb); &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">setErrorCallback</span><span class="params">(EventCallback cb)</span> </span>&#123; errorCallback_ = <span class="built_in">std</span>::move(cb); &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            ReadEventCallback readCallback_;</span><br><span class="line">            EventCallback writeCallback_;</span><br><span class="line">            EventCallback closeCallback_;</span><br><span class="line">            EventCallback errorCallback_;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>设置事件读写能力，通过对 events_ 变量设置掩码完成，并且通知绑定的 EventLoop update</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Channel</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">enableReading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                events_ |= kReadEvent;</span><br><span class="line">                update();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">disableReading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                events_ &amp;= ~kReadEvent;</span><br><span class="line">                update();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">enableWriting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                events_ |= kWriteEvent;</span><br><span class="line">                update();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">disableWriting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                events_ &amp;= ~kWriteEvent;</span><br><span class="line">                update();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">disableAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                events_ = kNoneEvent;</span><br><span class="line">                update();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kNoneEvent = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kReadEvent = POLLIN | POLLPRI;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kWriteEvent = POLLOUT;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> events_;</span><br><span class="line"></span><br><span class="line">            update() &#123;</span><br><span class="line">                addedToLoop_ = <span class="literal">true</span>;</span><br><span class="line">                loop_-&gt;updateChannel(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>处理事件</p>
<p> revents_ 变量由 Poller 设置，表征事件的类型；处理事件时根据事件类型，调用注册好的几种回调函数</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Channel::handleEventWithGuard</span><span class="params">(Timestamp receiveTime)</span> </span>&#123;</span><br><span class="line">    eventHandling_ = <span class="literal">true</span>;</span><br><span class="line">    LOG_TRACE &lt;&lt; reventsToString();</span><br><span class="line">    <span class="keyword">if</span> ((revents_ &amp; POLLHUP) &amp;&amp; !(revents_ &amp; POLLIN)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logHup_) &#123;</span><br><span class="line">            LOG_WARN &lt;&lt; <span class="string">"fd = "</span> &lt;&lt; fd_ &lt;&lt; <span class="string">" Channel::handle_event() POLLHUP"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (closeCallback_) &#123;</span><br><span class="line">            closeCallback_();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (revents_ &amp; POLLNVAL) &#123;</span><br><span class="line">        LOG_WARN &lt;&lt; <span class="string">"fd = "</span> &lt;&lt; fd_ &lt;&lt; <span class="string">" Channel::handle_event() POLLNVAL"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (revents_ &amp; (POLLERR | POLLNVAL)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errorCallback_) &#123;</span><br><span class="line">            errorCallback_();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (revents_ &amp; (POLLIN | POLLPRI | POLLRDHUP)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (readCallback_) &#123;</span><br><span class="line">            readCallback_(receiveTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (revents_ &amp; POLLOUT) &#123;</span><br><span class="line">        <span class="keyword">if</span> (writeCallback_) &#123;</span><br><span class="line">            writeCallback_();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    eventHandling_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第二层"><a href="#第二层" class="headerlink" title="第二层"></a>第二层</h2><h3 id="1-TimerId"><a href="#1-TimerId" class="headerlink" title="1. TimerId"></a>1. TimerId</h3><p>用于取消 Timer</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Timer</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">TimerId</span> :</span> <span class="keyword">public</span> muduo::copyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            TimerId()</span><br><span class="line">                    : timer_(<span class="literal">NULL</span>),</span><br><span class="line">                      sequence_(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">            TimerId(Timer *timer, <span class="keyword">int64_t</span> seq)</span><br><span class="line">                    : timer_(timer),</span><br><span class="line">                      sequence_(seq) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// default copy-ctor, dtor and assignment are okay</span></span><br><span class="line">            <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerQueue</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            Timer *timer_;</span><br><span class="line">            <span class="keyword">int64_t</span> sequence_;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<h3 id="2-Poller"><a href="#2-Poller" class="headerlink" title="2. Poller"></a>2. Poller</h3><ol>
<li><p>IO 多路复用的虚基类，和一个 EventLoop 对象绑定，poll 方法必须在 loop 线程中调用。</p>
</li>
<li><p>一个 Poller 对象中可以包含多个 Channel，代表多个 IO 事件</p>
</li>
<li><p>有两个实现类：PollPoller 底层使用 poll；EPollPoller 底层使用 epoll</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Channel</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Poller</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Channel *&gt; ChannelList;</span><br><span class="line"></span><br><span class="line">            Poller(EventLoop *loop);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">virtual</span> ~Poller();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// Polls the I/O events.</span></span><br><span class="line">            <span class="comment">/// Must be called in the loop thread.</span></span><br><span class="line">            <span class="function"><span class="keyword">virtual</span> Timestamp <span class="title">poll</span><span class="params">(<span class="keyword">int</span> timeoutMs, ChannelList *activeChannels)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// Changes the interested I/O events.</span></span><br><span class="line">            <span class="comment">/// Must be called in the loop thread.</span></span><br><span class="line">            <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">updateChannel</span><span class="params">(Channel *channel)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// Remove the channel, when it destructs.</span></span><br><span class="line">            <span class="comment">/// Must be called in the loop thread.</span></span><br><span class="line">            <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">removeChannel</span><span class="params">(Channel *channel)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hasChannel</span><span class="params">(Channel *channel)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">static</span> Poller *<span class="title">newDefaultPoller</span><span class="params">(EventLoop *loop)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">assertInLoopThread</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">                ownerLoop_-&gt;assertInLoopThread();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span>:</span><br><span class="line">            <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, Channel *&gt; ChannelMap;</span><br><span class="line">            ChannelMap channels_;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            EventLoop *ownerLoop_;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<h3 id="3-Acceptor"><a href="#3-Acceptor" class="headerlink" title="3. Acceptor"></a>3. Acceptor</h3><p>用于接受 TCP 连接</p>
<ol>
<li>构造函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Acceptor</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            Acceptor(EventLoop *loop, <span class="keyword">const</span> InetAddress &amp;listenAddr, <span class="keyword">bool</span> reuseport) : </span><br><span class="line">                loop_(loop), </span><br><span class="line">                acceptSocket_(sockets::createNonblockingOrDie(listenAddr.family())),</span><br><span class="line">                acceptChannel_(loop, acceptSocket_.fd()),</span><br><span class="line">                listenning_(<span class="literal">false</span>),</span><br><span class="line">                idleFd_(::open(<span class="string">"/dev/null"</span>, O_RDONLY | O_CLOEXEC)) &#123;</span><br><span class="line"></span><br><span class="line">                assert(idleFd_ &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                acceptSocket_.setReuseAddr(<span class="literal">true</span>);</span><br><span class="line">                acceptSocket_.setReusePort(reuseport);</span><br><span class="line">                acceptSocket_.bindAddress(listenAddr);</span><br><span class="line">                acceptChannel_.setReadCallback(</span><br><span class="line">                <span class="built_in">std</span>::bind(&amp;Acceptor::handleRead, <span class="keyword">this</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            EventLoop *loop_;</span><br><span class="line">            Socket acceptSocket_;</span><br><span class="line">            Channel acceptChannel_;</span><br><span class="line">            NewConnectionCallback newConnectionCallback_;</span><br><span class="line">            <span class="keyword">bool</span> listenning_;</span><br><span class="line">            <span class="keyword">int</span> idleFd_;    </span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<p>每个 Acceptor 和一个 EventLoop 绑定，并且传入一个 InetAddress 对象用于构造 Socket 监听的端口。</p>
<p>在构造函数中，acceptSocket_ 对象初始化好，acceptChannel_ 也初始化好，并且注册 Read 事件的 CallBack 为 Acceptor::handleRead。</p>
<p>Acceptor::handleRead 的代码是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Acceptor::handleRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    InetAddress peerAddr;</span><br><span class="line">    <span class="comment">//FIXME loop until no more</span></span><br><span class="line">    <span class="keyword">int</span> connfd = acceptSocket_.accept(&amp;peerAddr);</span><br><span class="line">    <span class="keyword">if</span> (connfd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// string hostport = peerAddr.toIpPort();</span></span><br><span class="line">        <span class="comment">// LOG_TRACE &lt;&lt; "Accepts of " &lt;&lt; hostport;</span></span><br><span class="line">        <span class="keyword">if</span> (newConnectionCallback_) &#123;</span><br><span class="line">            newConnectionCallback_(connfd, peerAddr);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sockets::close(connfd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOG_SYSERR &lt;&lt; <span class="string">"in Acceptor::handleRead"</span>;</span><br><span class="line">        <span class="comment">// Read the section named "The special problem of</span></span><br><span class="line">        <span class="comment">// accept()ing when you can't" in libev's doc.</span></span><br><span class="line">        <span class="comment">// By Marc Lehmann, author of libev.</span></span><br><span class="line">        <span class="keyword">if</span> (errno == EMFILE) &#123;</span><br><span class="line">            ::close(idleFd_);</span><br><span class="line">            idleFd_ = ::accept(acceptSocket_.fd(), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">            ::close(idleFd_);</span><br><span class="line">            idleFd_ = ::open(<span class="string">"/dev/null"</span>, O_RDONLY | O_CLOEXEC);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，一旦 acceptChannel_ 产生了 read 事件，它就会调用 Acceptor 注册好的 newConnectionCallback_ 回调函数。</p>
<ol start="2">
<li>listen</li>
</ol>
<p>让 acceptSocket_ 开始 listen 某个端口（这个不是阻塞的），然后打开 acceptChannel_ 的读事件能力。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Acceptor::listen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    listenning_ = <span class="literal">true</span>;</span><br><span class="line">    acceptSocket_.listen();</span><br><span class="line">    acceptChannel_.enableReading();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-TimerQueue"><a href="#4-TimerQueue" class="headerlink" title="4. TimerQueue"></a>4. TimerQueue</h3><p>一个 Timer 队列，用于管理定时事件</p>
<ol>
<li>构造函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">TimerQueue</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="keyword">explicit</span> <span class="title">TimerQueue</span><span class="params">(EventLoop *loop)</span>: </span></span><br><span class="line">                loop_(loop),</span><br><span class="line">                timerfd_(createTimerfd()),</span><br><span class="line">                timerfdChannel_(loop, timerfd_),</span><br><span class="line">                timers_(),</span><br><span class="line">                callingExpiredTimers_(<span class="literal">false</span>) &#123;</span><br><span class="line"></span><br><span class="line">                timerfdChannel_.setReadCallback(<span class="built_in">std</span>::bind(&amp;TimerQueue::handleRead, <span class="keyword">this</span>));</span><br><span class="line">    </span><br><span class="line">                timerfdChannel_.enableReading();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">typedef</span> <span class="built_in">std</span>::pair&lt;Timestamp, Timer *&gt; Entry;</span><br><span class="line">            <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">set</span>&lt;Entry&gt; TimerList;</span><br><span class="line"></span><br><span class="line">            EventLoop *loop_;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> timerfd_;</span><br><span class="line">            Channel timerfdChannel_;</span><br><span class="line">            <span class="comment">// Timer list sorted by expiration</span></span><br><span class="line">            TimerList timers_;</span><br><span class="line">            <span class="keyword">bool</span> callingExpiredTimers_; <span class="comment">/* atomic */</span></span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<p>在构造函数中，首先将一个 TimerQueue 和一个 EventLoop 绑定，然后创建一个 timer 的 fd，然后用这个 fd 构造一个 timerfdChannel_。这个 timerfdChannel_ 会设置一个 Read 事件的 CallBack 回调函数，看一下这个回调函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TimerQueue::handleRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    <span class="function">Timestamp <span class="title">now</span><span class="params">(Timestamp::now())</span></span>;</span><br><span class="line">    readTimerfd(timerfd_, now);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Entry&gt; expired = getExpired(now);</span><br><span class="line"></span><br><span class="line">    callingExpiredTimers_ = <span class="literal">true</span>;</span><br><span class="line">    cancelingTimers_.clear();</span><br><span class="line">    <span class="comment">// safe to callback outside critical section</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> Entry &amp;it : expired) &#123;</span><br><span class="line">        it.second-&gt;run();</span><br><span class="line">    &#125;</span><br><span class="line">    callingExpiredTimers_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    reset(expired, now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个回调函数的大致原理是：如果 timerfdChannel_ 变得可读，说明有时间事件到达了；此时找一下过期的 timer 们，执行一下 timer 的 callback 函数</p>
<ol start="2">
<li>addTimer</li>
</ol>
<p>添加一个 Timer。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">TimerQueue</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function">TimerId <span class="title">addTimer</span><span class="params">(TimerCallback cb, Timestamp when, <span class="keyword">double</span> interval)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                Timer *timer = <span class="keyword">new</span> Timer(<span class="built_in">std</span>::move(cb), when, interval);</span><br><span class="line">    </span><br><span class="line">                loop_-&gt;runInLoop(<span class="built_in">std</span>::bind(&amp;TimerQueue::addTimerInLoop, <span class="keyword">this</span>, timer));</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> TimerId(timer, timer-&gt;sequence());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<p>具体方式是先 new 一个 Timer 对象，然后向绑定的 EventLoop 对象添加。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::runInLoop</span><span class="params">(Functor cb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isInLoopThread()) &#123;</span><br><span class="line">        cb();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        queueInLoop(<span class="built_in">std</span>::move(cb));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EventLoop 要么直接执行，要么稍后执行（对于添加 Timer 这个行为，很可能发生在其他线程），但是无论如何最终都会执行 addTimerInLoop 方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TimerQueue::addTimerInLoop</span><span class="params">(Timer *timer)</span> </span>&#123;</span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    <span class="keyword">bool</span> earliestChanged = insert(timer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (earliestChanged) &#123;</span><br><span class="line">        resetTimerfd(timerfd_, timer-&gt;expiration());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>细节没有关注，整体思路就是更新 timer 列表</p>
<ol start="3">
<li>cancel</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">TimerQueue</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">(TimerId timerId)</span> </span>&#123;</span><br><span class="line">                loop_-&gt;runInLoop(<span class="built_in">std</span>::bind(&amp;TimerQueue::cancelInLoop, <span class="keyword">this</span>, timerId));</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<p>和 addTimer 一样，最终也是到 EventLoop 中执行，接下来看 cancelInLoop</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TimerQueue::cancelInLoop</span><span class="params">(TimerId timerId)</span> </span>&#123;</span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    assert(timers_.size() == activeTimers_.size());</span><br><span class="line">    <span class="function">ActiveTimer <span class="title">timer</span><span class="params">(timerId.timer_, timerId.sequence_)</span></span>;</span><br><span class="line">    ActiveTimerSet::iterator it = activeTimers_.find(timer);</span><br><span class="line">    <span class="keyword">if</span> (it != activeTimers_.end()) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> n = timers_.erase(Entry(it-&gt;first-&gt;expiration(), it-&gt;first));</span><br><span class="line">        assert(n == <span class="number">1</span>);</span><br><span class="line">        (<span class="keyword">void</span>) n;</span><br><span class="line">        <span class="keyword">delete</span> it-&gt;first; <span class="comment">// <span class="doctag">FIXME:</span> no delete please</span></span><br><span class="line">        activeTimers_.erase(it);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (callingExpiredTimers_) &#123;</span><br><span class="line">        cancelingTimers_.insert(timer);</span><br><span class="line">    &#125;</span><br><span class="line">    assert(timers_.size() == activeTimers_.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本思路也是更新 TimerQueue 中的 Timer 列表</p>
<h3 id="5-Connector"><a href="#5-Connector" class="headerlink" title="5. Connector"></a>5. Connector</h3><p>属于 TcpClient 的底层组件，用于发起 TCP 连接，它是 TcpClient 的成员，生命期由后者控制。</p>
<ol>
<li>构造函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Connector</span> :</span> noncopyable,</span><br><span class="line">                          <span class="keyword">public</span> <span class="built_in">std</span>::enable_shared_from_this&lt;Connector&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            Connector(EventLoop *loop, <span class="keyword">const</span> InetAddress &amp;serverAddr) : </span><br><span class="line">                loop_(loop),</span><br><span class="line">                serverAddr_(serverAddr),</span><br><span class="line">                connect_(<span class="literal">false</span>),</span><br><span class="line">                state_(kDisconnected),</span><br><span class="line">                retryDelayMs_(kInitRetryDelayMs) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kInitRetryDelayMs = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">            EventLoop *loop_;</span><br><span class="line">            InetAddress serverAddr_;</span><br><span class="line">            <span class="keyword">bool</span> connect_; <span class="comment">// atomic</span></span><br><span class="line">            States state_;  <span class="comment">// <span class="doctag">FIXME:</span> use atomic variable</span></span><br><span class="line">            <span class="keyword">int</span> retryDelayMs_;</span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<p>绑定一个 EventLoop，指定一下 server 的地址和端口</p>
<ol start="2">
<li>start</li>
</ol>
<p>可以在任何线程中调用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Connector::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    connect_ = <span class="literal">true</span>;</span><br><span class="line">    loop_-&gt;runInLoop(<span class="built_in">std</span>::bind(&amp;Connector::startInLoop, <span class="keyword">this</span>)); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Connector::startInLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    assert(state_ == kDisconnected);</span><br><span class="line">    <span class="keyword">if</span> (connect_) &#123;</span><br><span class="line">        connect();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOG_DEBUG &lt;&lt; <span class="string">"do not connect"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Connector::connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = sockets::createNonblockingOrDie(serverAddr_.family());</span><br><span class="line">    <span class="keyword">int</span> ret = sockets::connect(sockfd, serverAddr_.getSockAddr());</span><br><span class="line">    <span class="keyword">int</span> savedErrno = (ret == <span class="number">0</span>) ? <span class="number">0</span> : errno;</span><br><span class="line">    <span class="keyword">switch</span> (savedErrno) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">case</span> EINPROGRESS:</span><br><span class="line">        <span class="keyword">case</span> EINTR:</span><br><span class="line">        <span class="keyword">case</span> EISCONN:</span><br><span class="line">            connecting(sockfd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EAGAIN:</span><br><span class="line">        <span class="keyword">case</span> EADDRINUSE:</span><br><span class="line">        <span class="keyword">case</span> EADDRNOTAVAIL:</span><br><span class="line">        <span class="keyword">case</span> ECONNREFUSED:</span><br><span class="line">        <span class="keyword">case</span> ENETUNREACH:</span><br><span class="line">            retry(sockfd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EACCES:</span><br><span class="line">        <span class="keyword">case</span> EPERM:</span><br><span class="line">        <span class="keyword">case</span> EAFNOSUPPORT:</span><br><span class="line">        <span class="keyword">case</span> EALREADY:</span><br><span class="line">        <span class="keyword">case</span> EBADF:</span><br><span class="line">        <span class="keyword">case</span> EFAULT:</span><br><span class="line">        <span class="keyword">case</span> ENOTSOCK:</span><br><span class="line">            LOG_SYSERR &lt;&lt; <span class="string">"connect error in Connector::startInLoop "</span> &lt;&lt; savedErrno;</span><br><span class="line">            sockets::close(sockfd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            LOG_SYSERR &lt;&lt; <span class="string">"Unexpected error in Connector::startInLoop "</span> &lt;&lt; savedErrno;</span><br><span class="line">            sockets::close(sockfd);</span><br><span class="line">            <span class="comment">// connectErrorCallback_();</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>start 方法从客户端开启一个 TCP 连接。基本做法是把 connect 放在 EventLoop 中执行，最终会开启 socket::connect</p>
<p>在 connect 方法中有很多种情况，最终归结为 3 大类：connecting、retry 和 close，close 就是 socket::close 就行了，重点看一下前两个。</p>
<p>先看 retry，retry 的操作是先把原来的 sockfd close 掉，然后设一个定时任务 runAfter，而这个延时时延每次翻倍，直到到达最大阈值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Connector::retry</span><span class="params">(<span class="keyword">int</span> sockfd)</span> </span>&#123;</span><br><span class="line">    sockets::close(sockfd);</span><br><span class="line">    setState(kDisconnected);</span><br><span class="line">    <span class="keyword">if</span> (connect_) &#123;</span><br><span class="line">        LOG_INFO &lt;&lt; <span class="string">"Connector::retry - Retry connecting to "</span> &lt;&lt; serverAddr_.toIpPort()</span><br><span class="line">                 &lt;&lt; <span class="string">" in "</span> &lt;&lt; retryDelayMs_ &lt;&lt; <span class="string">" milliseconds. "</span>;</span><br><span class="line">        loop_-&gt;runAfter(retryDelayMs_ / <span class="number">1000.0</span>,</span><br><span class="line">                        <span class="built_in">std</span>::bind(&amp;Connector::startInLoop, shared_from_this()));</span><br><span class="line">        retryDelayMs_ = <span class="built_in">std</span>::min(retryDelayMs_ * <span class="number">2</span>, kMaxRetryDelayMs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOG_DEBUG &lt;&lt; <span class="string">"do not connect"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种是 connecting，能进入 connecting 说明 connect 阻塞过程已经结束，接下来正式进入通讯过程，因此设置 channel 的两个回调。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Connector::connecting</span><span class="params">(<span class="keyword">int</span> sockfd)</span> </span>&#123;</span><br><span class="line">    setState(kConnecting);</span><br><span class="line">    assert(!channel_);</span><br><span class="line"></span><br><span class="line">    channel_.reset(<span class="keyword">new</span> Channel(loop_, sockfd));</span><br><span class="line">    channel_-&gt;setWriteCallback(</span><br><span class="line">            <span class="built_in">std</span>::bind(&amp;Connector::handleWrite, <span class="keyword">this</span>)); </span><br><span class="line">    channel_-&gt;setErrorCallback(</span><br><span class="line">            <span class="built_in">std</span>::bind(&amp;Connector::handleError, <span class="keyword">this</span>)); </span><br><span class="line">    channel_-&gt;enableWriting();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先看一下 WriteCallback，基本就是执行一下设置好的 newConnectionCallback_</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Connector::handleWrite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">"Connector::handleWrite "</span> &lt;&lt; state_;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (state_ == kConnecting) &#123;</span><br><span class="line">        <span class="keyword">int</span> sockfd = removeAndResetChannel();</span><br><span class="line">        <span class="keyword">int</span> err = sockets::getSocketError(sockfd);</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            LOG_WARN &lt;&lt; <span class="string">"Connector::handleWrite - SO_ERROR = "</span></span><br><span class="line">                     &lt;&lt; err &lt;&lt; <span class="string">" "</span> &lt;&lt; strerror_tl(err);</span><br><span class="line">            retry(sockfd);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sockets::isSelfConnect(sockfd)) &#123;</span><br><span class="line">            LOG_WARN &lt;&lt; <span class="string">"Connector::handleWrite - Self connect"</span>;</span><br><span class="line">            retry(sockfd);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            setState(kConnected);</span><br><span class="line">            <span class="keyword">if</span> (connect_) &#123;</span><br><span class="line">                newConnectionCallback_(sockfd);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sockets::close(sockfd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// what happened?</span></span><br><span class="line">        assert(state_ == kDisconnected);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看一下 ErrorCallback，基本操作就是 log 然后 retry。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Connector::handleError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOG_ERROR &lt;&lt; <span class="string">"Connector::handleError state="</span> &lt;&lt; state_;</span><br><span class="line">    <span class="keyword">if</span> (state_ == kConnecting) &#123;</span><br><span class="line">        <span class="keyword">int</span> sockfd = removeAndResetChannel();</span><br><span class="line">        <span class="keyword">int</span> err = sockets::getSocketError(sockfd);</span><br><span class="line">        LOG_TRACE &lt;&lt; <span class="string">"SO_ERROR = "</span> &lt;&lt; err &lt;&lt; <span class="string">" "</span> &lt;&lt; strerror_tl(err);</span><br><span class="line">        retry(sockfd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>restart</li>
</ol>
<p>restart 只能在 loop thread 中被调用，目标是重新设置各项 connector 参数，然后重启这个 connector</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Connector::restart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    setState(kDisconnected);</span><br><span class="line">    retryDelayMs_ = kInitRetryDelayMs;</span><br><span class="line">    connect_ = <span class="literal">true</span>;</span><br><span class="line">    startInLoop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="第三层"><a href="#第三层" class="headerlink" title="第三层"></a>第三层</h2><h3 id="1-EventLoop"><a href="#1-EventLoop" class="headerlink" title="1. EventLoop"></a>1. EventLoop</h3><p>封装事件循环，也是事件分派的中心。它用 TimerQueue 作为计时器管理，用 Poller 作为 IO Multiplexing。</p>
<ol>
<li>构造函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">EventLoop</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            EventLoop()</span><br><span class="line">                : </span><br><span class="line">                looping_(<span class="literal">false</span>),</span><br><span class="line">                quit_(<span class="literal">false</span>),</span><br><span class="line">                eventHandling_(<span class="literal">false</span>),</span><br><span class="line">                callingPendingFunctors_(<span class="literal">false</span>),</span><br><span class="line">                iteration_(<span class="number">0</span>),</span><br><span class="line">                threadId_(CurrentThread::tid()),</span><br><span class="line">                poller_(Poller::newDefaultPoller(<span class="keyword">this</span>)),</span><br><span class="line">                timerQueue_(<span class="keyword">new</span> TimerQueue(<span class="keyword">this</span>)),</span><br><span class="line">                wakeupFd_(createEventfd()),</span><br><span class="line">                wakeupChannel_(<span class="keyword">new</span> Channel(<span class="keyword">this</span>, wakeupFd_)),</span><br><span class="line">                currentActiveChannel_(<span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">                LOG_DEBUG &lt;&lt; <span class="string">"EventLoop created "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">" in thread "</span> &lt;&lt; threadId_;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (t_loopInThisThread) &#123;</span><br><span class="line">                    LOG_FATAL &lt;&lt; <span class="string">"Another EventLoop "</span> &lt;&lt; t_loopInThisThread &lt;&lt; <span class="string">" exists in this thread "</span> &lt;&lt; threadId_;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    t_loopInThisThread = <span class="keyword">this</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                wakeupChannel_-&gt;setReadCallback(<span class="built_in">std</span>::bind(&amp;EventLoop::handleRead, <span class="keyword">this</span>));</span><br><span class="line">    </span><br><span class="line">                wakeupChannel_-&gt;enableReading();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="keyword">bool</span> looping_; <span class="comment">/* atomic */</span></span><br><span class="line">            <span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; quit_;</span><br><span class="line">            <span class="keyword">bool</span> eventHandling_; <span class="comment">/* atomic */</span></span><br><span class="line">            <span class="keyword">bool</span> callingPendingFunctors_; <span class="comment">/* atomic */</span></span><br><span class="line">            <span class="keyword">int64_t</span> iteration_;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">pid_t</span> threadId_;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Poller&gt; poller_;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;TimerQueue&gt; timerQueue_;</span><br><span class="line">            <span class="keyword">int</span> wakeupFd_;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Channel&gt; wakeupChannel_;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<p>在构造函数中，构造了 Poller 和 TimerQueue。</p>
<p>另外就是构造了 wakeupChannel_，这个 channel 的 fd 是 eventfd，注册的 read 回调函数是下面这样，目前不知道这个 channel 是干啥的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::handleRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> one = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> n = sockets::read(wakeupFd_, &amp;one, <span class="keyword">sizeof</span> one);</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="keyword">sizeof</span> one) &#123;</span><br><span class="line">        LOG_ERROR &lt;&lt; <span class="string">"EventLoop::handleRead() reads "</span> &lt;&lt; n &lt;&lt; <span class="string">" bytes instead of 8"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Channel 相关</li>
</ol>
<p>一共有 3 个相关的函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">EventLoop</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">updateChannel</span><span class="params">(Channel *channel)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">removeChannel</span><span class="params">(Channel *channel)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">bool</span> <span class="title">hasChannel</span><span class="params">(Channel *channel)</span></span>;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Poller&gt; poller_;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<p>这几个函数的本质是向内部的 poller_ 对象注册或注销</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::updateChannel</span><span class="params">(Channel *channel)</span> </span>&#123;</span><br><span class="line">    assert(channel-&gt;ownerLoop() == <span class="keyword">this</span>);</span><br><span class="line">    assertInLoopThread();</span><br><span class="line">    poller_-&gt;updateChannel(channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::removeChannel</span><span class="params">(Channel *channel)</span> </span>&#123;</span><br><span class="line">    assert(channel-&gt;ownerLoop() == <span class="keyword">this</span>);</span><br><span class="line">    assertInLoopThread();</span><br><span class="line">    <span class="keyword">if</span> (eventHandling_) &#123;</span><br><span class="line">        assert(currentActiveChannel_ == channel ||</span><br><span class="line">               <span class="built_in">std</span>::find(activeChannels_.begin(), activeChannels_.end(), channel) == activeChannels_.end());</span><br><span class="line">    &#125;</span><br><span class="line">    poller_-&gt;removeChannel(channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EventLoop::hasChannel</span><span class="params">(Channel *channel)</span> </span>&#123;</span><br><span class="line">    assert(channel-&gt;ownerLoop() == <span class="keyword">this</span>);</span><br><span class="line">    assertInLoopThread();</span><br><span class="line">    <span class="keyword">return</span> poller_-&gt;hasChannel(channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Timer 相关</li>
</ol>
<p>一共有 4 个相关方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">EventLoop</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function">TimerId <span class="title">runAt</span><span class="params">(Timestamp time, TimerCallback cb)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function">TimerId <span class="title">runAfter</span><span class="params">(<span class="keyword">double</span> delay, TimerCallback cb)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function">TimerId <span class="title">runEvery</span><span class="params">(<span class="keyword">double</span> interval, TimerCallback cb)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">(TimerId timerId)</span></span>;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;TimerQueue&gt; timerQueue_;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<p>这几个方法的目标是注册定时回调函数或取消，实现靠的是内部的 TimerQueue 对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TimerId <span class="title">EventLoop::runAt</span><span class="params">(Timestamp time, TimerCallback cb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> timerQueue_-&gt;addTimer(<span class="built_in">std</span>::move(cb), time, <span class="number">0.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TimerId <span class="title">EventLoop::runAfter</span><span class="params">(<span class="keyword">double</span> delay, TimerCallback cb)</span> </span>&#123;</span><br><span class="line">    <span class="function">Timestamp <span class="title">time</span><span class="params">(addTime(Timestamp::now(), delay))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> runAt(time, <span class="built_in">std</span>::move(cb));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TimerId <span class="title">EventLoop::runEvery</span><span class="params">(<span class="keyword">double</span> interval, TimerCallback cb)</span> </span>&#123;</span><br><span class="line">    <span class="function">Timestamp <span class="title">time</span><span class="params">(addTime(Timestamp::now(), interval))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> timerQueue_-&gt;addTimer(<span class="built_in">std</span>::move(cb), time, interval);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::cancel</span><span class="params">(TimerId timerId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> timerQueue_-&gt;cancel(timerId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>loop </li>
</ol>
<p><code>EventLoop.h</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">EventLoop</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; Functor;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="keyword">bool</span> looping_; <span class="comment">/* atomic */</span></span><br><span class="line">            <span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; quit_;</span><br><span class="line">            <span class="keyword">int64_t</span> iteration_;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Poller&gt; poller_;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// scratch variables</span></span><br><span class="line">            ChannelList activeChannels_;</span><br><span class="line">            Channel *currentActiveChannel_;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<p><code>EventLoop.cc</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kPollTimeMs = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    assert(!looping_);</span><br><span class="line">    assertInLoopThread();</span><br><span class="line"></span><br><span class="line">    looping_ = <span class="literal">true</span>;</span><br><span class="line">    quit_ = <span class="literal">false</span>;  </span><br><span class="line"></span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">"EventLoop "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">" start looping"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!quit_) &#123;</span><br><span class="line">        activeChannels_.clear();</span><br><span class="line">        pollReturnTime_ = poller_-&gt;poll(kPollTimeMs, &amp;activeChannels_);</span><br><span class="line">        ++iteration_;</span><br><span class="line">        <span class="keyword">if</span> (Logger::logLevel() &lt;= Logger::TRACE) &#123;</span><br><span class="line">            printActiveChannels();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// TODO sort channel by priority</span></span><br><span class="line">        eventHandling_ = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (Channel *channel : activeChannels_) &#123;</span><br><span class="line">            currentActiveChannel_ = channel;</span><br><span class="line">            currentActiveChannel_-&gt;handleEvent(pollReturnTime_);</span><br><span class="line">        &#125;</span><br><span class="line">        currentActiveChannel_ = <span class="literal">NULL</span>;</span><br><span class="line">        eventHandling_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        doPendingFunctors();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">"EventLoop "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">" stop looping"</span>;</span><br><span class="line">    looping_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>loop 方法是一个死循环，它的主体是让 poller_ 监听一段时间的 IO 事件，然后调用已经注册好的这些 Channel 的各种 CallBack 函数进行处理；处理完这些事件以后，每一次循环会 doPendingFunctors 一次，看一下这个方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::doPendingFunctors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Functor&gt; functors;</span><br><span class="line">    callingPendingFunctors_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        functors.swap(pendingFunctors_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> Functor &amp;functor : functors) &#123;</span><br><span class="line">        functor();</span><br><span class="line">    &#125;</span><br><span class="line">    callingPendingFunctors_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的作用是有一些未执行的方法 pendingFunctors，在这个里面依次执行一下，pendingFunctors_ 是在以下的函数中被更新的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::runInLoop</span><span class="params">(Functor cb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isInLoopThread()) &#123;</span><br><span class="line">        cb();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        queueInLoop(<span class="built_in">std</span>::move(cb));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::queueInLoop</span><span class="params">(Functor cb)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        pendingFunctors_.push_back(<span class="built_in">std</span>::move(cb));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isInLoopThread() || callingPendingFunctors_) &#123;</span><br><span class="line">        wakeup();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>外部调用的接口是 runInLoop，如果 cb 没有被立刻执行，那么它就会加入到 pendingFunctors_ 中，等待在每次循环中执行掉。</p>
<p>事件包括了两部分：刚才说的是 IO 事件，还有一部分是 Timer 定时的事件，Timer 事件其实也跟 doPendingFunctors 有关：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TimerId <span class="title">EventLoop::runAt</span><span class="params">(Timestamp time, TimerCallback cb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> timerQueue_-&gt;addTimer(<span class="built_in">std</span>::move(cb), time, <span class="number">0.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TimerId <span class="title">TimerQueue::addTimer</span><span class="params">(TimerCallback cb,</span></span></span><br><span class="line"><span class="function"><span class="params">                             Timestamp when,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">double</span> interval)</span> </span>&#123;</span><br><span class="line">    Timer *timer = <span class="keyword">new</span> Timer(<span class="built_in">std</span>::move(cb), when, interval);</span><br><span class="line">    loop_-&gt;runInLoop(</span><br><span class="line">            <span class="built_in">std</span>::bind(&amp;TimerQueue::addTimerInLoop, <span class="keyword">this</span>, timer));</span><br><span class="line">    <span class="keyword">return</span> &#123;timer, timer-&gt;sequence()&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在 addTimer 时，本质上也把回调函数加到了 EventLoop 的 runInLoop 中，只不过回调函数是 TimerQueue::addTimerInLoop。</p>
<p>Timer 一旦注册好以后，跟 IO 事件一样，因为 timer 本身也有一个 timerfd，到时以后会唤醒，本质上还是一个 fd 的 IO。</p>
<p>TimerQueue 和 刚才的 wakeupChannel_ 的本质其实是一样的，TimerQueue 内部也有一个 Channel，对应一个 timerfd</p>
<p><code>TimerQueue.h</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">TimerQueue</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> timerfd_;</span><br><span class="line">            Channel timerfdChannel_;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="keyword">namespace</span> detail &#123;</span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">createTimerfd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> timerfd = ::timerfd_create(CLOCK_MONOTONIC, TFD_NONBLOCK | TFD_CLOEXEC);</span><br><span class="line">                <span class="keyword">if</span> (timerfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    LOG_SYSFATAL &lt;&lt; <span class="string">"Failed in timerfd_create"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> timerfd;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;  <span class="comment">// namespace detail</span></span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br><span class="line">```        </span><br><span class="line"></span><br><span class="line">`EventLoop.h`</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">EventLoop</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="keyword">int</span> wakeupFd_;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Channel&gt; wakeupChannel_;</span><br><span class="line">            </span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">createEventfd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> evtfd = ::eventfd(<span class="number">0</span>, EFD_NONBLOCK | EFD_CLOEXEC);</span><br><span class="line">        <span class="keyword">if</span> (evtfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            LOG_SYSERR &lt;&lt; <span class="string">"Failed in eventfd"</span>;</span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> evtfd;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>它们的底层都是一个系统调用，各产生一个 fd：timerfd 产生的是定时事件，eventfd 产生的事件，目标是让 poll 快速返回：向 eventfd 写入一个字节，就会产生一个可读事件，从而实现 poll 阻塞方法的快速返回。</p>
<p>无论是 TimerQueue 中的 timerfdChannel_，还是 EventLoop 中的 wakeupChannel_，都需要向 poller 中注册从而监听，这部分代码藏的比较深，在 Channel 的 enableReading 里面：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Channel::enableReading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    events_ |= kReadEvent;</span><br><span class="line">    update();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Channel::update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    addedToLoop_ = <span class="literal">true</span>;</span><br><span class="line">    loop_-&gt;updateChannel(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::updateChannel</span><span class="params">(Channel *channel)</span> </span>&#123;</span><br><span class="line">    assert(channel-&gt;ownerLoop() == <span class="keyword">this</span>);</span><br><span class="line">    assertInLoopThread();</span><br><span class="line">    poller_-&gt;updateChannel(channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>套了好几层，最终还是向 poller 注册上了。。。</p>
<p>总之，这个 loop 方法是 Reactor 模式的核心：一个 loop 一个 Thread，先向 poller 注册好要监听的 Channel，Channel 又包括了 3 种类型：要监听的 IO 端口、timerfd 抽象成的时间事件 Channel 和 为了快速推出阻塞而额外留好的 eventfd 抽象成的 Channel。产生事件以后，poller 退出阻塞，调用各个 channel 上注册好的处理回调函数。另外，在 loop 期间其他线程加入的方法，先 pending，然后一并处理一下。</p>
<ol start="5">
<li>quit</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">EventLoop</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                quit_ = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">                <span class="keyword">if</span> (!isInLoopThread()) &#123;</span><br><span class="line">                    wakeup();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">wakeup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">uint64_t</span> one = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">ssize_t</span> n = sockets::write(wakeupFd_, &amp;one, <span class="keyword">sizeof</span> one);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (n != <span class="keyword">sizeof</span> one) &#123;</span><br><span class="line">                    LOG_ERROR &lt;&lt; <span class="string">"EventLoop::wakeup() writes "</span> &lt;&lt; n &lt;&lt; <span class="string">" bytes instead of 8"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<p>quit 函数的目标是结束整个 loop：如果调用者就在当前线程，那么直接把 while 循环开始时的 quit 变量置为 true 即可；反之，为了快速退出 poller 的阻塞，向提前预留好的 wakeupfd 写一个字节，这样 poller 监听的 channel 就产生了可读事件，从而让阻塞退出。</p>
<h2 id="第四层"><a href="#第四层" class="headerlink" title="第四层"></a>第四层</h2><h3 id="1-EventLoopThread"><a href="#1-EventLoopThread" class="headerlink" title="1. EventLoopThread"></a>1. EventLoopThread</h3><p>启动一个线程，在其中运行 EventLoop::loop()</p>
<ol>
<li>构造函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">EventLoopThread</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(EventLoop *)&gt; ThreadInitCallback;</span><br><span class="line"></span><br><span class="line">            explicit EventLoopThread(const ThreadInitCallback &amp;cb = ThreadInitCallback(), const string &amp;name = string()) : loop_(NULL),</span><br><span class="line">                        exiting_(<span class="literal">false</span>),</span><br><span class="line">                        thread_(<span class="built_in">std</span>::bind(&amp;EventLoopThread::threadFunc, <span class="keyword">this</span>), name),</span><br><span class="line">                        mutex_(),</span><br><span class="line">                        cond_(mutex_),</span><br><span class="line">                        callback_(cb) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="function">EventLoop *loop_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">            <span class="keyword">bool</span> exiting_;</span><br><span class="line">            Thread thread_;</span><br><span class="line">            MutexLock mutex_;</span><br><span class="line">            <span class="function">Condition cond_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">            ThreadInitCallback callback_;</span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<p>其中，内部的 thread_ 对象注册的 func 是</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoopThread::threadFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EventLoop loop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (callback_) &#123;</span><br><span class="line">        callback_(&amp;loop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        loop_ = &amp;loop;</span><br><span class="line">        cond_.notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    loop.loop();</span><br><span class="line">    <span class="comment">//assert(exiting_);</span></span><br><span class="line">    <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    loop_ = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，在新开的 Thread 中，会先跑 ThreadInitCallBack，然后运行 loop.loop()</p>
<ol start="2">
<li>startLoop</li>
</ol>
<p>开始一个 loop，注意这里用 mutex 和 cond 保护 loop 的初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EventLoop *<span class="title">EventLoopThread::startLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assert(!thread_.started());</span><br><span class="line">    thread_.start();</span><br><span class="line"></span><br><span class="line">    EventLoop *loop = <span class="literal">NULL</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (loop_ == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            cond_.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        loop = loop_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-TcpConnection"><a href="#2-TcpConnection" class="headerlink" title="2. TcpConnection"></a>2. TcpConnection</h3><p>整个网络库的核心，封装一次 TCP 连接。每个 TcpConnection 必须归某个 EventLoop 管理，所有的 IO 会转移到这个线程。TcpConnection 既可以用于 Server，也可以用于 Client。</p>
<ol>
<li>构造函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">TcpConnection</span> :</span> noncopyable,</span><br><span class="line">                              <span class="keyword">public</span> <span class="built_in">std</span>::enable_shared_from_this&lt;TcpConnection&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            TcpConnection(EventLoop *loop,</span><br><span class="line">                          <span class="keyword">const</span> <span class="built_in">string</span> &amp;name,</span><br><span class="line">                          <span class="keyword">int</span> sockfd,</span><br><span class="line">                          <span class="keyword">const</span> InetAddress &amp;localAddr,</span><br><span class="line">                          <span class="keyword">const</span> InetAddress &amp;peerAddr): </span><br><span class="line">                    loop_(CHECK_NOTNULL(loop)),</span><br><span class="line">                    name_(nameArg),</span><br><span class="line">                    state_(kConnecting),</span><br><span class="line">                    reading_(<span class="literal">true</span>),</span><br><span class="line">                    socket_(<span class="keyword">new</span> Socket(sockfd)),</span><br><span class="line">                    channel_(<span class="keyword">new</span> Channel(loop, sockfd)),</span><br><span class="line">                    localAddr_(localAddr),</span><br><span class="line">                    peerAddr_(peerAddr),</span><br><span class="line">                    highWaterMark_(<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>) &#123;</span><br><span class="line"></span><br><span class="line">                channel_-&gt;setReadCallback(<span class="built_in">std</span>::bind(&amp;TcpConnection::handleRead, <span class="keyword">this</span>, _1));</span><br><span class="line"></span><br><span class="line">                channel_-&gt;setWriteCallback(<span class="built_in">std</span>::bind(&amp;TcpConnection::handleWrite, <span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">                channel_-&gt;setCloseCallback(<span class="built_in">std</span>::bind(&amp;TcpConnection::handleClose, <span class="keyword">this</span>));</span><br><span class="line">    </span><br><span class="line">                channel_-&gt;setErrorCallback(<span class="built_in">std</span>::bind(&amp;TcpConnection::handleError, <span class="keyword">this</span>));</span><br><span class="line">    </span><br><span class="line">                LOG_DEBUG &lt;&lt; <span class="string">"TcpConnection::ctor["</span> &lt;&lt; name_ &lt;&lt; <span class="string">"] at "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">" fd="</span> &lt;&lt; sockfd;</span><br><span class="line">    </span><br><span class="line">                socket_-&gt;setKeepAlive(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="keyword">enum</span> StateE &#123;</span><br><span class="line">                kDisconnected, kConnecting, kConnected, kDisconnecting</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            EventLoop *loop_;</span><br><span class="line">            <span class="keyword">const</span> <span class="built_in">string</span> name_;</span><br><span class="line">            StateE state_;  </span><br><span class="line">            <span class="keyword">bool</span> reading_;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Socket&gt; socket_;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Channel&gt; channel_;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> InetAddress localAddr_;</span><br><span class="line">            <span class="keyword">const</span> InetAddress peerAddr_;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">size_t</span> highWaterMark_;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<p>这个构造函数比较复杂：一个 TcpConnection 和一个 EventLoop 绑定；根据 sockfd 构造一个 Socket 对象；根据 EventLoop 和 sockfd 构造一个 Channel 对象。</p>
<p>localAddr_、peerAddr_ 和 highWaterMark_ 暂时还不知道代表什么；</p>
<p>每个 channel 可以设置 4 种 CallBack，在构造函数中都设置了，接下来依次看一下.</p>
<ol start="2">
<li><p>4 种 CallBack</p>
<ol>
<li><p>ReadCallBack</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::handleRead</span><span class="params">(Timestamp receiveTime)</span> </span>&#123;</span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    <span class="keyword">int</span> savedErrno = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> n = inputBuffer_.readFd(channel_-&gt;fd(), &amp;savedErrno);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        messageCallback_(shared_from_this(), &amp;inputBuffer_, receiveTime);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        handleClose();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        errno = savedErrno;</span><br><span class="line">        LOG_SYSERR &lt;&lt; <span class="string">"TcpConnection::handleRead"</span>;</span><br><span class="line">    </span><br><span class="line">        handleError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReadCallback 的目标是从内核把数据读到 inputBuffer_ 中，然后执行注册好的 messageCallback_。</p>
</li>
<li><p>WriteCallBack</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::handleWrite</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    <span class="keyword">if</span> (channel_-&gt;isWriting()) &#123;</span><br><span class="line">        <span class="keyword">ssize_t</span> n = sockets::write(channel_-&gt;fd(), outputBuffer_.peek(), outputBuffer_.readableBytes());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            outputBuffer_.retrieve(n);</span><br><span class="line">            <span class="keyword">if</span> (outputBuffer_.readableBytes() == <span class="number">0</span>) &#123;</span><br><span class="line">                channel_-&gt;disableWriting();</span><br><span class="line">                <span class="keyword">if</span> (writeCompleteCallback_) &#123;</span><br><span class="line">                    loop_-&gt;queueInLoop(<span class="built_in">std</span>::bind(writeCompleteCallback_, shared_from_this()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (state_ == kDisconnecting) &#123;</span><br><span class="line">                    shutdownInLoop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LOG_SYSERR &lt;&lt; <span class="string">"TcpConnection::handleWrite"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOG_TRACE &lt;&lt; <span class="string">"Connection fd = "</span> &lt;&lt; channel_-&gt;fd() &lt;&lt; <span class="string">" is down, no more writing"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WriteCallBack 的目标是把 outputBuffer_ 中的数据写到内核缓冲区中。如果把 outputBuffer_ 中的数据都写完了的话，那么就调用注册好的 writeCompleteCallback_</p>
</li>
<li><p>CloseCallBack</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::handleClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">"fd = "</span> &lt;&lt; channel_-&gt;fd() &lt;&lt; <span class="string">" state = "</span> &lt;&lt; stateToString();</span><br><span class="line"></span><br><span class="line">    assert(state_ == kConnected || state_ == kDisconnecting);</span><br><span class="line"></span><br><span class="line">    setState(kDisconnected);</span><br><span class="line"></span><br><span class="line">    channel_-&gt;disableAll();</span><br><span class="line"></span><br><span class="line">    <span class="function">TcpConnectionPtr <span class="title">guardThis</span><span class="params">(shared_from_this())</span></span>;</span><br><span class="line">    connectionCallback_(guardThis);</span><br><span class="line">    <span class="comment">// must be the last line</span></span><br><span class="line">    closeCallback_(guardThis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 CloseCallBack 中不关闭 sockfd，，只是设置状态且关闭 Channel 的读写能力，并调用 connectionCallback_</p>
</li>
<li><p>ErrorCallBack</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::handleError</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> err = sockets::getSocketError(channel_-&gt;fd());</span><br><span class="line">    LOG_ERROR &lt;&lt; <span class="string">"TcpConnection::handleError ["</span> &lt;&lt; name_ &lt;&lt; <span class="string">"] - SO_ERROR = "</span> &lt;&lt; err &lt;&lt; <span class="string">" "</span> &lt;&lt; strerror_tl(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个比较简单，获取一下 SocketError 就可以了</p>
</li>
</ol>
</li>
<li><p>send 方法</p>
</li>
</ol>
<p>总共有 3 个 public 方法</p>
<p><code>TcpConnection.h</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">TcpConnection</span> :</span> noncopyable,</span><br><span class="line">                              <span class="keyword">public</span> <span class="built_in">std</span>::enable_shared_from_this&lt;TcpConnection&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *message, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">const</span> StringPiece &amp;message)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(Buffer *message)</span></span>;  <span class="comment">// this one will swap data</span></span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::send</span><span class="params">(<span class="keyword">const</span> StringPiece &amp;message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state_ == kConnected) &#123;</span><br><span class="line">        <span class="keyword">if</span> (loop_-&gt;isInLoopThread()) &#123;</span><br><span class="line">            sendInLoop(message);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">void</span> (TcpConnection::*fp)(<span class="keyword">const</span> StringPiece &amp;message)</span><br><span class="line">            = &amp;TcpConnection::sendInLoop;</span><br><span class="line">            loop_-&gt;runInLoop(<span class="built_in">std</span>::bind(fp,<span class="keyword">this</span>, message.as_string()));</span><br><span class="line">            <span class="comment">//std::forward&lt;string&gt;(message)));</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::sendInLoop</span><span class="params">(<span class="keyword">const</span> StringPiece &amp;message)</span> </span>&#123;</span><br><span class="line">    sendInLoop(message.data(), message.size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::sendInLoop</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    <span class="keyword">ssize_t</span> nwrote = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> remaining = len;</span><br><span class="line">    <span class="keyword">bool</span> faultError = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (state_ == kDisconnected) &#123;</span><br><span class="line">        LOG_WARN &lt;&lt; <span class="string">"disconnected, give up writing"</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if no thing in output queue, try writing directly</span></span><br><span class="line">    <span class="keyword">if</span> (!channel_-&gt;isWriting() &amp;&amp; outputBuffer_.readableBytes() == <span class="number">0</span>) &#123;</span><br><span class="line">        nwrote = sockets::write(channel_-&gt;fd(), data, len);</span><br><span class="line">        <span class="keyword">if</span> (nwrote &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            remaining = len - nwrote;</span><br><span class="line">            <span class="keyword">if</span> (remaining == <span class="number">0</span> &amp;&amp; writeCompleteCallback_) &#123;</span><br><span class="line">                loop_-&gt;queueInLoop(<span class="built_in">std</span>::bind(writeCompleteCallback_, shared_from_this()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="comment">// nwrote &lt; 0</span></span><br><span class="line">        &#123;</span><br><span class="line">            nwrote = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (errno != EWOULDBLOCK) &#123;</span><br><span class="line">                LOG_SYSERR &lt;&lt; <span class="string">"TcpConnection::sendInLoop"</span>;</span><br><span class="line">                <span class="keyword">if</span> (errno == EPIPE || errno == ECONNRESET) <span class="comment">// <span class="doctag">FIXME:</span> any others?</span></span><br><span class="line">                &#123;</span><br><span class="line">                    faultError = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(remaining &lt;= len);</span><br><span class="line">    <span class="keyword">if</span> (!faultError &amp;&amp; remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> oldLen = outputBuffer_.readableBytes();</span><br><span class="line">        <span class="keyword">if</span> (oldLen + remaining &gt;= highWaterMark_</span><br><span class="line">            &amp;&amp; oldLen &lt; highWaterMark_</span><br><span class="line">            &amp;&amp; highWaterMarkCallback_) &#123;</span><br><span class="line">            loop_-&gt;queueInLoop(<span class="built_in">std</span>::bind(highWaterMarkCallback_, shared_from_this(), oldLen + remaining));</span><br><span class="line">        &#125;</span><br><span class="line">        outputBuffer_.append(<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt;(data) + nwrote, remaining);</span><br><span class="line">        <span class="keyword">if</span> (!channel_-&gt;isWriting()) &#123;</span><br><span class="line">            channel_-&gt;enableWriting();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>send 方法的主要思想是：如果 outputBuffer_ 中没有数据了，那么尝试直接通过 sockfd 写，不经过 outBuffer_ 这一中间环节了；否则的话，就把数据先写到 outputBuffer_ 中，等待 Channel 有写事件的时候，再通过注册好的 handleWrite 方法中，从 outputBuffer 写到 sockfd 中。</p>
<ol start="4">
<li>shutdown() 方法</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> use compare and swap</span></span><br><span class="line">    <span class="keyword">if</span> (state_ == kConnected) &#123;</span><br><span class="line">        setState(kDisconnecting);</span><br><span class="line">        <span class="comment">// <span class="doctag">FIXME:</span> shared_from_this()?</span></span><br><span class="line">        loop_-&gt;runInLoop(<span class="built_in">std</span>::bind(&amp;TcpConnection::shutdownInLoop, <span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::shutdownInLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    <span class="keyword">if</span> (!channel_-&gt;isWriting()) &#123;</span><br><span class="line">        <span class="comment">// we are not writing</span></span><br><span class="line">        socket_-&gt;shutdownWrite();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较简单，就是同步或者异步 shutdown socket</p>
<ol start="5">
<li>forceClose 和 forceCloseWithDelay</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::forceClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> use compare and swap</span></span><br><span class="line">    <span class="keyword">if</span> (state_ == kConnected || state_ == kDisconnecting) &#123;</span><br><span class="line">        setState(kDisconnecting);</span><br><span class="line">        loop_-&gt;queueInLoop(<span class="built_in">std</span>::bind(&amp;TcpConnection::forceCloseInLoop,</span><br><span class="line">                shared_from_this()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::forceCloseWithDelay</span><span class="params">(<span class="keyword">double</span> seconds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state_ == kConnected || state_ == kDisconnecting) &#123;</span><br><span class="line">        setState(kDisconnecting);</span><br><span class="line">        loop_-&gt;runAfter(</span><br><span class="line">                seconds, makeWeakCallback(shared_from_this(), &amp;TcpConnection::forceClose));  <span class="comment">// not forceCloseInLoop to avoid race condition</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::forceCloseInLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    <span class="keyword">if</span> (state_ == kConnected || state_ == kDisconnecting) &#123;</span><br><span class="line">        <span class="comment">// as if we received 0 byte in handleRead();</span></span><br><span class="line">        handleClose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也比较简单，最终是同步或异步调用 CloseCallBack</p>
<h2 id="第五层"><a href="#第五层" class="headerlink" title="第五层"></a>第五层</h2><h3 id="1-EventLoopThreadPool"><a href="#1-EventLoopThreadPool" class="headerlink" title="1. EventLoopThreadPool"></a>1. EventLoopThreadPool</h3><p>用于创建 IO 线程池，也就是说把 TcpConnection 分派到一组运行 EventLoop 的线程上。它是 TcpServer 的成员，生命期由后者控制</p>
<ol>
<li>构造函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">EventLoopThreadPool</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            EventLoopThreadPool(EventLoop *baseLoop, <span class="keyword">const</span> <span class="built_in">string</span> &amp;nameArg) : </span><br><span class="line">                baseLoop_(baseLoop),</span><br><span class="line">                name_(nameArg),</span><br><span class="line">                started_(<span class="literal">false</span>),</span><br><span class="line">                numThreads_(<span class="number">0</span>),</span><br><span class="line">                next_(<span class="number">0</span>) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            EventLoop *baseLoop_;</span><br><span class="line">            <span class="built_in">string</span> name_;</span><br><span class="line">            <span class="keyword">bool</span> started_;</span><br><span class="line">            <span class="keyword">int</span> numThreads_;</span><br><span class="line">            <span class="keyword">int</span> next_;</span><br><span class="line">            </span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<p>EventLoopThreadPool 有一个基本的 baseLoop_</p>
<ol start="2">
<li>start</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">EventLoopThreadPool</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">const</span> ThreadInitCallback &amp;cb = ThreadInitCallback())</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                assert(!started_);</span><br><span class="line">                baseLoop_-&gt;assertInLoopThread();</span><br><span class="line"></span><br><span class="line">                started_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numThreads_; ++i) &#123;</span><br><span class="line">                    <span class="keyword">char</span> buf[name_.size() + <span class="number">32</span>];</span><br><span class="line">                    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf, <span class="string">"%s%d"</span>, name_.c_str(), i);</span><br><span class="line"></span><br><span class="line">                    EventLoopThread *t = <span class="keyword">new</span> EventLoopThread(cb, buf);</span><br><span class="line">        </span><br><span class="line">                    threads_.push_back(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;EventLoopThread&gt;(t));</span><br><span class="line"></span><br><span class="line">                    loops_.push_back(t-&gt;startLoop());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (numThreads_ == <span class="number">0</span> &amp;&amp; cb) &#123;</span><br><span class="line">                    cb(baseLoop_);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;EventLoopThread&gt;&gt; threads_;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;EventLoop *&gt; loops_;</span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<p>这个方法会开 numThreads_ 个线程，并且在 numThreads_ 线程里面让 EventLoop 开始 loop 起来，在 EventLoopThreadPool 中保存好这个 Thread 和这些 EventLoop</p>
<ol start="3">
<li>getNextLoop</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">EventLoopThreadPool</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function">EventLoop *<span class="title">getNextLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                baseLoop_-&gt;assertInLoopThread();</span><br><span class="line">                assert(started_);</span><br><span class="line">                EventLoop *loop = baseLoop_;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!loops_.empty()) &#123;</span><br><span class="line">                    <span class="comment">// round-robin</span></span><br><span class="line">                    loop = loops_[next_];</span><br><span class="line">                    ++next_;</span><br><span class="line">                    <span class="keyword">if</span> (implicit_cast&lt;<span class="keyword">size_t</span>&gt;(next_) &gt;= loops_.size()) &#123;</span><br><span class="line">                        next_ = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> loop;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="keyword">int</span> numThreads_;</span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<p>这个方法是用来把 TcpConnection 分派到一组运行 EventLoop 的线程上，采取的方式是 round-robin</p>
<h3 id="2-TcpServer"><a href="#2-TcpServer" class="headerlink" title="2. TcpServer"></a>2. TcpServer</h3><p>用于编写网络服务器，接受客户的连接</p>
<ol>
<li>构造函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">TcpServer</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            TcpServer(EventLoop *loop,</span><br><span class="line">                      <span class="keyword">const</span> InetAddress &amp;listenAddr,</span><br><span class="line">                      <span class="keyword">const</span> <span class="built_in">string</span> &amp;nameArg,</span><br><span class="line">                      Option option = kNoReusePort) : </span><br><span class="line">                    loop_(CHECK_NOTNULL(loop)),</span><br><span class="line">                    ipPort_(listenAddr.toIpPort()),</span><br><span class="line">                    name_(nameArg),</span><br><span class="line">                    acceptor_(<span class="keyword">new</span> Acceptor(loop, listenAddr,option == kReusePort)),</span><br><span class="line">                    threadPool_(<span class="keyword">new</span> EventLoopThreadPool(loop, name_)),</span><br><span class="line">                    connectionCallback_(defaultConnectionCallback),</span><br><span class="line">                    messageCallback_(defaultMessageCallback),</span><br><span class="line">                    nextConnId_(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">                acceptor_-&gt;setNewConnectionCallback(<span class="built_in">std</span>::bind(&amp;TcpServer::newConnection, <span class="keyword">this</span>, _1, _2));</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            EventLoop *loop_;  <span class="comment">// the acceptor loop</span></span><br><span class="line">            <span class="keyword">const</span> <span class="built_in">string</span> ipPort_;</span><br><span class="line">            <span class="keyword">const</span> <span class="built_in">string</span> name_;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Acceptor&gt; acceptor_; <span class="comment">// avoid revealing Acceptor</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;EventLoopThreadPool&gt; threadPool_;</span><br><span class="line">            ConnectionCallback connectionCallback_;</span><br><span class="line">            MessageCallback messageCallback_;</span><br><span class="line">            <span class="keyword">int</span> nextConnId_;</span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<p>这个构造函数里面也干了很多事情：绑定 EventLoop；构造 Acceptor、构造 EventLoopThreadPool、设置 connectionCallback_ 和 messageCallback_。</p>
<p>其中，acceptor_ 设置了 NewConnectionCallback ：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpServer::newConnection</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> InetAddress &amp;peerAddr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    EventLoop *ioLoop = threadPool_-&gt;getNextLoop();</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">64</span>];</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf, <span class="string">"-%s#%d"</span>, ipPort_.c_str(), nextConnId_);</span><br><span class="line">    ++nextConnId_;</span><br><span class="line">    <span class="built_in">string</span> connName = name_ + buf;</span><br><span class="line"></span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">"TcpServer::newConnection ["</span> &lt;&lt; name_</span><br><span class="line">             &lt;&lt; <span class="string">"] - new connection ["</span> &lt;&lt; connName</span><br><span class="line">             &lt;&lt; <span class="string">"] from "</span> &lt;&lt; peerAddr.toIpPort();</span><br><span class="line">    <span class="function">InetAddress <span class="title">localAddr</span><span class="params">(sockets::getLocalAddr(sockfd))</span></span>;</span><br><span class="line">    <span class="comment">// FIXME poll with zero timeout to double confirm the new connection</span></span><br><span class="line">    <span class="comment">// FIXME use make_shared if necessary</span></span><br><span class="line">    <span class="function">TcpConnectionPtr <span class="title">conn</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">new</span> TcpConnection(ioLoop, connName, sockfd, localAddr, peerAddr))</span></span>;</span><br><span class="line">    connections_[connName] = conn;</span><br><span class="line">    </span><br><span class="line">    conn-&gt;setConnectionCallback(connectionCallback_);</span><br><span class="line">    conn-&gt;setMessageCallback(messageCallback_);</span><br><span class="line">    conn-&gt;setWriteCompleteCallback(writeCompleteCallback_);</span><br><span class="line">    conn-&gt;setCloseCallback(<span class="built_in">std</span>::bind(&amp;TcpServer::removeConnection, <span class="keyword">this</span>, _1)); <span class="comment">// <span class="doctag">FIXME:</span> unsafe</span></span><br><span class="line"></span><br><span class="line">    ioLoop-&gt;runInLoop(<span class="built_in">std</span>::bind(&amp;TcpConnection::connectEstablished, conn));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法比较重要。 Acceptor 用于接收 TCP 连接，它监听的是 listenfd；在连接到来后，会将 connfd 传入 newConnectionCallback_ 方法。</p>
<p>在这个 NewConnectionCallback 方法中，首先从 ThreadPool 中 Round-Robin 式的找一个 EventLoop，然后根据这个 connfd 新建一个 TcpConnection 传入这个 EventLoop 中，然后把这个 TcpConnection 的 4 种 CallBack 设置好，最终让这个 TcpConnection 放到 EventLoop 中开始跑。</p>
<p>接下来看看这 4 个 CallBack，这 4 个 CallBack 里面，connectionCallback_、messageCallback_ 和 writeCompleteCallback_ 都可以在 TcpServer 中外部 set，而 CloseCallback 是固定的：</p>
<ol start="2">
<li><p>TcpConnection 的 4 个 CallBack</p>
<ol>
<li><p>connectionCallback_ </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> muduo::net::defaultConnectionCallback(<span class="keyword">const</span> TcpConnectionPtr &amp;conn) &#123;</span><br><span class="line"></span><br><span class="line">    LOG_TRACE &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; <span class="string">" -&gt; "</span> &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; <span class="string">" is "</span> &lt;&lt; (conn-&gt;connected() ? <span class="string">"UP"</span> : <span class="string">"DOWN"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do not call conn-&gt;forceClose(), because some users want to register message callback only.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Default 情况下啥也不干</p>
</li>
<li><p>messageCallback_</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> muduo::net::defaultMessageCallback(<span class="keyword">const</span> TcpConnectionPtr &amp;, Buffer *buf, Timestamp) &#123;</span><br><span class="line">    buf-&gt;retrieveAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>writeCompleteCallback_</p>
<p> 没有 Default</p>
</li>
<li><p>closeCallBack_</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">conn-&gt;setCloseCallback(<span class="built_in">std</span>::bind(&amp;TcpServer::removeConnection, <span class="keyword">this</span>, _1)); <span class="comment">// <span class="doctag">FIXME:</span> unsafe</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpServer::removeConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> unsafe</span></span><br><span class="line">    loop_-&gt;runInLoop(<span class="built_in">std</span>::bind(&amp;TcpServer::removeConnectionInLoop, <span class="keyword">this</span>, conn));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpServer::removeConnectionInLoop</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn)</span> </span>&#123;</span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">"TcpServer::removeConnectionInLoop ["</span> &lt;&lt; name_ &lt;&lt; <span class="string">"] - connection "</span> &lt;&lt; conn-&gt;name();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> n = connections_.erase(conn-&gt;name());</span><br><span class="line">    (<span class="keyword">void</span>) n;</span><br><span class="line">    assert(n == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    EventLoop *ioLoop = conn-&gt;getLoop();</span><br><span class="line">    ioLoop-&gt;queueInLoop(<span class="built_in">std</span>::bind(&amp;TcpConnection::connectDestroyed, conn));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::connectDestroyed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    <span class="keyword">if</span> (state_ == kConnected) &#123;</span><br><span class="line">        setState(kDisconnected);</span><br><span class="line">        channel_-&gt;disableAll();</span><br><span class="line">        connectionCallback_(shared_from_this());</span><br><span class="line">    &#125;</span><br><span class="line">    channel_-&gt;remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 CloseCallBack 的目标是移除对应 EventLoop 中的 Channel</p>
</li>
</ol>
</li>
<li><p>start 方法</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpServer::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (started_.getAndSet(<span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        threadPool_-&gt;start(threadInitCallback_);</span><br><span class="line"></span><br><span class="line">        assert(!acceptor_-&gt;listenning());</span><br><span class="line">        loop_-&gt;runInLoop(</span><br><span class="line">                <span class="built_in">std</span>::bind(&amp;Acceptor::listen, get_pointer(acceptor_)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先一个 CAS 操作保证一个 TcpServer 只 start 一次，然后让 ThreadPool 开始启动线程，同时让 Acceptor 开始监听端口</p>
<ol start="4">
<li>析构函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TcpServer::~TcpServer() &#123;</span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">"TcpServer::~TcpServer ["</span> &lt;&lt; name_ &lt;&lt; <span class="string">"] destructing"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;item : connections_) &#123;</span><br><span class="line">        <span class="function">TcpConnectionPtr <span class="title">conn</span><span class="params">(item.second)</span></span>;</span><br><span class="line">        item.second.reset();</span><br><span class="line">        conn-&gt;getLoop()-&gt;runInLoop(</span><br><span class="line">                <span class="built_in">std</span>::bind(&amp;TcpConnection::connectDestroyed, conn));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>析构函数中，让所有的 TcpConnection 对象的 Channel 都销毁掉。</p>
<h3 id="3-TcpClient"><a href="#3-TcpClient" class="headerlink" title="3. TcpClient"></a>3. TcpClient</h3><p>用于编写网络客户端，能发起连接，并且有重试功能。</p>
<ol>
<li>构造函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">TcpClient</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            TcpClient(EventLoop *loop,</span><br><span class="line">                      <span class="keyword">const</span> InetAddress &amp;serverAddr,</span><br><span class="line">                      <span class="keyword">const</span> <span class="built_in">string</span> &amp;nameArg):</span><br><span class="line">                    loop_(CHECK_NOTNULL(loop)),</span><br><span class="line">                    connector_(<span class="keyword">new</span> Connector(loop, serverAddr)),</span><br><span class="line">                    name_(nameArg),</span><br><span class="line">                    connectionCallback_(defaultConnectionCallback),</span><br><span class="line">                    messageCallback_(defaultMessageCallback),</span><br><span class="line">                    retry_(<span class="literal">false</span>),</span><br><span class="line">                    connect_(<span class="literal">true</span>),</span><br><span class="line">                    nextConnId_(<span class="number">1</span>) &#123;</span><br><span class="line">    </span><br><span class="line">                connector_-&gt;setNewConnectionCallback(</span><br><span class="line">                <span class="built_in">std</span>::bind(&amp;TcpClient::newConnection, <span class="keyword">this</span>, _1));</span><br><span class="line">                LOG_INFO &lt;&lt; <span class="string">"TcpClient::TcpClient["</span> &lt;&lt; name_ &lt;&lt; <span class="string">"] - connector "</span> &lt;&lt; get_pointer(connector_);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            EventLoop *loop_;</span><br><span class="line">            ConnectorPtr connector_; <span class="comment">// avoid revealing Connector</span></span><br><span class="line">            <span class="keyword">const</span> <span class="built_in">string</span> name_;</span><br><span class="line">            ConnectionCallback connectionCallback_;</span><br><span class="line">            MessageCallback messageCallback_;</span><br><span class="line">            <span class="keyword">bool</span> retry_;   <span class="comment">// atomic</span></span><br><span class="line">            <span class="keyword">bool</span> connect_; <span class="comment">// atomic</span></span><br><span class="line">            <span class="comment">// always in loop thread</span></span><br><span class="line">            <span class="keyword">int</span> nextConnId_;</span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<p>TcpClient 绑定一个 EventLoop，内部有一个 connector 用于新建 TCP 连接；connectionCallback_ 和 messageCallback_ 初始都设为 default，default 是啥也不干；Connector 要设置 NewConnection 的 Callback 如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpClient::newConnection</span><span class="params">(<span class="keyword">int</span> sockfd)</span> </span>&#123;</span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    <span class="function">InetAddress <span class="title">peerAddr</span><span class="params">(sockets::getPeerAddr(sockfd))</span></span>;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf,</span><br><span class="line">             <span class="string">":%s#%d"</span>, peerAddr.toIpPort().c_str(), nextConnId_);</span><br><span class="line">    ++nextConnId_;</span><br><span class="line">    <span class="built_in">string</span> connName = name_ + buf;</span><br><span class="line"></span><br><span class="line">    <span class="function">InetAddress <span class="title">localAddr</span><span class="params">(sockets::getLocalAddr(sockfd))</span></span>;</span><br><span class="line">    <span class="comment">// FIXME poll with zero timeout to double confirm the new connection</span></span><br><span class="line">    <span class="comment">// FIXME use make_shared if necessary</span></span><br><span class="line">    <span class="function">TcpConnectionPtr <span class="title">conn</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">new</span> TcpConnection(loop_, connName, sockfd, localAddr, peerAddr))</span></span>;</span><br><span class="line"></span><br><span class="line">    conn-&gt;setConnectionCallback(connectionCallback_);</span><br><span class="line">    conn-&gt;setMessageCallback(messageCallback_);</span><br><span class="line">    conn-&gt;setWriteCompleteCallback(writeCompleteCallback_);</span><br><span class="line">    conn-&gt;setCloseCallback(</span><br><span class="line">            <span class="built_in">std</span>::bind(&amp;TcpClient::removeConnection, <span class="keyword">this</span>, _1)); <span class="comment">// <span class="doctag">FIXME:</span> unsafe</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        connection_ = conn;</span><br><span class="line">    &#125;</span><br><span class="line">    conn-&gt;connectEstablished();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 Callback 的目标是打开一个 TcpConnection，这个 TcpConnection 注册好各种回调，然后 channel 开始监听。</p>
<ol start="2">
<li>connect </li>
</ol>
<p>让内部的 connector 开始 connect </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpClient::connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> check state</span></span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">"TcpClient::connect["</span> &lt;&lt; name_ &lt;&lt; <span class="string">"] - connecting to "</span></span><br><span class="line">             &lt;&lt; connector_-&gt;serverAddress().toIpPort();</span><br><span class="line">    connect_ = <span class="literal">true</span>;</span><br><span class="line">    connector_-&gt;start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>disconnect</li>
</ol>
<p>断开 TcpConnection，对于 TcpClient，它只有一个 TcpConnection，这点和 TcpServer 明显不同</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpClient::disconnect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    connect_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (connection_) &#123;</span><br><span class="line">            connection_-&gt;shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>stop</li>
</ol>
<p>让内部的 connector stop</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpClient::stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    connect_ = <span class="literal">false</span>;</span><br><span class="line">    connector_-&gt;stop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>以上就把 muduo 中的 net 部分基本介绍完了，好累。。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E4%B8%AD%E7%9A%84net%E7%BB%84%E4%BB%B6/" data-id="ck7naw84r000y2cve3dcx6d52" class="article-share-link">分享到</a>
      

      
        <a href="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E4%B8%AD%E7%9A%84net%E7%BB%84%E4%BB%B6/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cpp/" rel="tag">Cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Net/" rel="tag">Net</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-muduo网络编程示例之零：前言" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B%E4%B9%8B%E9%9B%B6%EF%BC%9A%E5%89%8D%E8%A8%80/" class="article-date">
  <time datetime="2020-03-09T02:55:49.386Z" itemprop="datePublished">2020-03-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/">开源组件</a>►<a class="article-category-link" href="/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/">muduo</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B%E4%B9%8B%E9%9B%B6%EF%BC%9A%E5%89%8D%E8%A8%80/">muduo 网络编程示例之零：前言</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>原文链接 <a href="https://blog.csdn.net/Solstice/article/details/6171831" target="_blank" rel="noopener">https://blog.csdn.net/Solstice/article/details/6171831</a></p>
</blockquote>
<p>我将会写一系列文章，介绍用 muduo 网络库完成常见的 TCP 网络编程任务。目前计划如下：</p>
<ol>
<li>UNP 中的简单协议，包括 echo、daytime、time、discard 等。 </li>
<li>Boost.Asio 中的示例，包括 timer2~6、chat 等。</li>
<li>Java Netty 中的示例，包括 discard、echo、uptime 等，其中的 discard 和 echo 带流量统计功能。</li>
<li>Python twisted 中的示例，包括 finger01~07</li>
<li>用于测试两台机器的往返延迟的 roundtrip</li>
<li>用于测试两台机器的带宽的 pingpong</li>
<li>云风的串并转换连接服务器 multiplexer，包括单线程和多线程两个版本。</li>
<li>文件传输</li>
<li>一个基于 TCP 的应用层广播 hub</li>
<li>socks4a 代理服务器，包括简单的 TCP 中继(relay)。</li>
<li>一个 Sudoku 服务器的演变，从单线程到多线程，从阻塞到 event-based。</li>
<li>一个提供短址服务的 httpd 服务器</li>
</ol>
<p>其中前面 7 个已经放到了 muduo 代码的 examples 目录中，下载地址是： <a href="http://muduo.googlecode.com/files/muduo-0.1.5-alpha.tar.gz" target="_blank" rel="noopener">http://muduo.googlecode.com/files/muduo-0.1.5-alpha.tar.gz</a> </p>
<p>这些例子都比较简单，逻辑不复杂，代码也很短，适合摘取关键部分放到博客上。其中一些有一定的代表性与针对性，比如“如何传输完整的文件”估计是网络编程的初学者经常遇到的问题。请注意，<strong>muduo 是设计来开发内网的网络程序，它没有做任何安全方面的加强措施，如果用在公网上可能会受到攻击</strong>，在后面的例子中我会谈到这一点。</p>
<p>本系列文章适用于 <code>Linux 2.6.x (x &gt; 28)</code>，主要测试发行版为 <code>Ubuntu 10.04 LTS</code> 和 <code>Debian 6.0 Squeeze，64-bit x86</code> 硬件。</p>
<ul>
<li><a href="#1-tcp-%e7%bd%91%e7%bb%9c%e7%bc%96%e7%a8%8b%e6%9c%ac%e8%b4%a8%e8%ae%ba">1. TCP 网络编程本质论</a></li>
<li><a href="#2-muduo-%e7%ae%80%e4%bb%8b">2. Muduo 简介</a></li>
</ul>
<h2 id="1-TCP-网络编程本质论"><a href="#1-TCP-网络编程本质论" class="headerlink" title="1. TCP 网络编程本质论"></a>1. TCP 网络编程本质论</h2><p>我认为，TCP 网络编程最本质的是处理<strong>三个半事件</strong>：</p>
<ol>
<li><p><strong>连接的建立</strong>，包括服务端接受 (accept) 新连接和客户端成功发起 (connect) 连接。</p>
</li>
<li><p><strong>连接的断开</strong>，包括主动断开 (close 或 shutdown) 和被动断开 (read 返回 0)。</p>
</li>
<li><p><strong>消息到达，文件描述符可读</strong>。这是最为重要的一个事件，对它的处理方式决定了网络编程的风格（阻塞还是非阻塞，如何处理分包，应用层的缓冲如何设计等等）。</p>
</li>
<li><p><strong>消息发送完毕</strong>，这算半个。对于低流量的服务，可以不必关心这个事件；另外，<strong>这里“发送完毕”是指将数据写入操作系统的缓冲区，将由 TCP 协议栈负责数据的发送与重传</strong>，不代表对方已经收到数据。</p>
</li>
</ol>
<p>这其中有很多难点，也有很多细节需要注意，比方说：</p>
<ol>
<li><p><strong>如果要主动关闭连接，如何保证对方已经收到全部数据</strong>？如果应用层有缓冲（这在非阻塞网络编程中是必须的，见下文），那么如何保证先发送完缓冲区中的数据，然后再断开连接。直接调用 close(2) 恐怕是不行的。</p>
</li>
<li><p>如果主动发起连接，但是对方主动拒绝，<strong>如何定期 (带 back-off) 重试</strong>？</p>
</li>
<li><p><strong>非阻塞网络编程该用边沿触发(edge trigger)还是电平触发(level trigger)</strong>？（这两个中文术语有其他译法，我选择了一个电子工程师熟悉的说法。）如果是电平触发，那么什么时候关注 EPOLLOUT 事件？会不会造成 busy-loop？如果是边沿触发，如何防止漏读造成的饥饿？epoll 一定比 poll 快吗？</p>
</li>
<li><p>在非阻塞网络编程中，为什么要使用应用层缓冲区？假如一次读到的数据不够一个完整的数据包，那么这些已经读到的数据是不是应该先暂存在某个地方，等剩余的数据收到之后再一并处理？见 lighttpd 关于 /r/n/r/n 分包的 bug。假如数据是一个字节一个字节地到达，间隔 10ms，每个字节触发一次文件描述符可读 (readable) 事件，程序是否还能正常工作？lighttpd 在这个问题上出过安全漏洞。</p>
</li>
<li><p>在非阻塞网络编程中，如何设计并使用缓冲区？一方面我们希望减少系统调用，一次读的数据越多越划算，那么似乎应该准备一个大的缓冲区。另一方面，我们系统减少内存占用。如果有 10k 个连接，每个连接一建立就分配 64k 的读缓冲的话，将占用 640M 内存，而大多数时候这些缓冲区的使用率很低。muduo 用 readv 结合栈上空间巧妙地解决了这个问题。</p>
</li>
<li><p>如果使用发送缓冲区，万一接收方处理缓慢，数据会不会一直堆积在发送方，造成内存暴涨？如何做应用层的流量控制？</p>
</li>
<li><p><strong>如何设计并实现定时器</strong>？并使之与网络 IO 共用一个线程，以避免锁。</p>
</li>
</ol>
<p>这些问题在 muduo 的代码中可以找到答案。</p>
<h2 id="2-Muduo-简介"><a href="#2-Muduo-简介" class="headerlink" title="2. Muduo 简介"></a>2. Muduo 简介</h2><p>我编写 Muduo 网络库的目的之一就是简化日常的 TCP 网络编程，让程序员能把精力集中在业务逻辑的实现上，而不要天天和 Sockets API 较劲。借用 Brooks 的话说，我希望 Muduo 能减少网络编程中的偶发复杂性 (accidental complexity)。</p>
<p>Muduo 只支持 Linux 2.6.x 下的并发非阻塞 TCP 网络编程，它的安装方法见陈硕的 blog 文章。</p>
<p><strong>Muduo 的使用非常简单，不需要从指定的类派生，也不用覆写虚函数，只需要注册几个回调函数去处理前面提到的三个半事件就行了。</strong></p>
<p>以经典的 echo 回显服务为例：</p>
<ol>
<li>定义 <code>EchoServer class</code>，不需要派生自任何基类：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MUDUO_EXAMPLES_SIMPLE_ECHO_ECHO_H </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MUDUO_EXAMPLES_SIMPLE_ECHO_ECHO_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RFC 862 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">  EchoServer(muduo::net::EventLoop* loop, </span><br><span class="line">             <span class="keyword">const</span> muduo::net::InetAddress&amp; listenAddr);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onConnection</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr&amp; conn)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr&amp; conn, </span></span></span><br><span class="line"><span class="function"><span class="params">                 muduo::net::Buffer* buf, </span></span></span><br><span class="line"><span class="function"><span class="params">                 muduo::Timestamp time)</span></span>;</span><br><span class="line"></span><br><span class="line">  muduo::net::EventLoop* loop_; </span><br><span class="line">  muduo::net::TcpServer server_; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// MUDUO_EXAMPLES_SIMPLE_ECHO_ECHO_H</span></span></span><br></pre></td></tr></table></figure>

<p>在构造函数里注册回调函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">EchoServer::EchoServer(EventLoop* loop, </span><br><span class="line">                       <span class="keyword">const</span> InetAddress&amp; listenAddr) </span><br><span class="line">  : loop_(loop), </span><br><span class="line">    server_(loop, listenAddr, <span class="string">"EchoServer"</span>) &#123; </span><br><span class="line"></span><br><span class="line">    server_.setConnectionCallback(</span><br><span class="line">        boost::bind(&amp;EchoServer::onConnection, <span class="keyword">this</span>, _1)); </span><br><span class="line"></span><br><span class="line">    server_.setMessageCallback( </span><br><span class="line">        boost::bind(&amp;EchoServer::onMessage, <span class="keyword">this</span>, _1, _2, _3)); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EchoServer::start</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    server_.start(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>实现 EchoServer::onConnection() 和 EchoServer::onMessage()：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EchoServer::onConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn)</span> </span>&#123; </span><br><span class="line">    </span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">"EchoServer - "</span> &lt;&lt; conn-&gt;peerAddress().toHostPort() &lt;&lt; <span class="string">" -&gt; "</span> </span><br><span class="line">    &lt;&lt; conn-&gt;localAddress().toHostPort() &lt;&lt; <span class="string">" is "</span> </span><br><span class="line">    &lt;&lt; (conn-&gt;connected() ? <span class="string">"UP"</span> : <span class="string">"DOWN"</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EchoServer::onMessage</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, </span></span></span><br><span class="line"><span class="function"><span class="params">                           Buffer* buf, </span></span></span><br><span class="line"><span class="function"><span class="params">                           Timestamp time)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">msg</span><span class="params">(buf-&gt;retrieveAsString())</span></span>; </span><br><span class="line">  LOG_INFO &lt;&lt; conn-&gt;name() &lt;&lt; <span class="string">" echo "</span> &lt;&lt; msg.size() &lt;&lt; <span class="string">" bytes at "</span> &lt;&lt; time.toString(); </span><br><span class="line"></span><br><span class="line">  conn-&gt;send(msg); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 main() 里用 EventLoop 让整个程序跑起来：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"echo.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo; </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo::net;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">  LOG_INFO &lt;&lt; <span class="string">"pid = "</span> &lt;&lt; getpid(); </span><br><span class="line">  EventLoop loop; </span><br><span class="line">  <span class="function">InetAddress <span class="title">listenAddr</span><span class="params">(<span class="number">2007</span>)</span></span>; </span><br><span class="line">  <span class="function">EchoServer <span class="title">server</span><span class="params">(&amp;loop, listenAddr)</span></span>; </span><br><span class="line">  server.start(); </span><br><span class="line">  loop.loop(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整的代码见 muduo/examples/simple/echo。</p>
<p>这个几十行的小程序实现了一个并发的 echo 服务程序，可以同时处理多个连接。</p>
<p>对这个程序的详细分析见下一篇博客《Muduo 网络编程示例之一：五个简单 TCP 协议》<br>————————————————<br>版权声明：本文为CSDN博主「陈硕」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/Solstice/article/details/6171831" target="_blank" rel="noopener">https://blog.csdn.net/Solstice/article/details/6171831</a></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B%E4%B9%8B%E9%9B%B6%EF%BC%9A%E5%89%8D%E8%A8%80/" data-id="ck7naw84w001a2cve3t6ueg4p" class="article-share-link">分享到</a>
      

      
        <a href="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B%E4%B9%8B%E9%9B%B6%EF%BC%9A%E5%89%8D%E8%A8%80/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cpp/" rel="tag">Cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Net/" rel="tag">Net</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-以boost中的function和bind取代虚函数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/%E4%BB%A5boost%E4%B8%AD%E7%9A%84function%E5%92%8Cbind%E5%8F%96%E4%BB%A3%E8%99%9A%E5%87%BD%E6%95%B0/" class="article-date">
  <time datetime="2020-03-09T02:54:14.428Z" itemprop="datePublished">2020-03-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/">开源组件</a>►<a class="article-category-link" href="/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/">muduo</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/%E4%BB%A5boost%E4%B8%AD%E7%9A%84function%E5%92%8Cbind%E5%8F%96%E4%BB%A3%E8%99%9A%E5%87%BD%E6%95%B0/">以 boost 中的 function 和 bind 取代虚函数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>原文链接： <a href="https://blog.csdn.net/Solstice/article/details/3066268" target="_blank" rel="noopener">https://blog.csdn.net/Solstice/article/details/3066268</a></p>
</blockquote>
<p>这是一篇比较情绪化的 blog，中心思想是“继承就像一条贼船，上去就下不来了”，而借助 <code>boost::function</code>和<code>boost::bind</code>，大多数情况下，你都不用上贼船。</p>
<p><code>boost::function</code> 和 <code>boost::bind</code> 已经纳入了 std::tr1，这或许是 C++0x 最值得期待的功能，它将彻底改变 C++ 库的设计方式，以及应用程序的编写方式。</p>
<p>Scott Meyers 的 Effective C++ 3rd ed.第35条款<strong>提到了以 <code>boost::function</code> 和 <code>boost:bind</code> 取代虚函数的做法</strong>，这里谈谈我自己使用的感受。</p>
<ul>
<li><a href="#1-%e5%9f%ba%e6%9c%ac%e7%94%a8%e9%80%94">1. 基本用途</a></li>
<li><a href="#2-%e5%af%b9%e7%a8%8b%e5%ba%8f%e5%ba%93%e7%9a%84%e5%bd%b1%e5%93%8d">2. 对程序库的影响</a><ul>
<li><a href="#%e4%be%8b1%e7%ba%bf%e7%a8%8b%e5%ba%93">例1：线程库</a><ul>
<li><a href="#%e5%b8%b8%e8%a7%84oo%e8%ae%be%e8%ae%a1">常规OO设计：</a></li>
<li><a href="#%e5%9f%ba%e4%ba%8eclosure%e7%9a%84%e8%ae%be%e8%ae%a1">基于closure的设计：</a></li>
</ul>
</li>
<li><a href="#%e4%be%8b2%e7%bd%91%e7%bb%9c%e5%ba%93">例2：网络库</a></li>
</ul>
</li>
<li><a href="#3-%e5%af%b9%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%e7%9a%84%e5%bd%b1%e5%93%8d">3. 对面向对象程序设计的影响</a></li>
<li><a href="#4-%e5%af%b9%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%e7%9a%84%e5%bd%b1%e5%93%8d">4. 对面向对象设计模式的影响</a></li>
<li><a href="#5-%e4%be%9d%e8%b5%96%e6%b3%a8%e5%85%a5%e4%b8%8e%e5%8d%95%e5%85%83%e6%b5%8b%e8%af%95">5. 依赖注入与单元测试</a></li>
<li><a href="#6-%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99%e4%bd%bf%e7%94%a8%e7%bb%a7%e6%89%bf">6. 什么时候使用继承？</a></li>
<li><a href="#7-%e5%9f%ba%e4%ba%8e%e6%8e%a5%e5%8f%a3%e7%9a%84%e8%ae%be%e8%ae%a1">7. 基于接口的设计</a></li>
<li><a href="#8-%e5%ae%9e%e7%8e%b0signalslot">8. 实现Signal/Slot</a></li>
</ul>
<h2 id="1-基本用途"><a href="#1-基本用途" class="headerlink" title="1. 基本用途"></a>1. 基本用途</h2><p><code>boost::function</code> 就像 C# 里的 <code>delegate</code>，可以指向任何函数，包括成员函数。当用 <code>bind</code> 把某个成员函数绑到某个对象上时，我们得到了一个closure（闭包）。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/function.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/bind.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Foo::methodA\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodInt</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Foo::methodInt\t"</span> &lt;&lt; a &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Bar::methodB\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    boost::function&lt;<span class="keyword">void</span>()&gt; f1; <span class="comment">// 无参数，无返回值</span></span><br><span class="line"></span><br><span class="line">    Foo foo;</span><br><span class="line">    f1 = boost::bind(&amp;Foo::methodA, &amp;foo);</span><br><span class="line">    f1(); <span class="comment">// 调用 foo.methodA();</span></span><br><span class="line"></span><br><span class="line">    Bar bar;</span><br><span class="line">    f1 = boost::bind(&amp;Bar::methodB, &amp;bar);</span><br><span class="line">    f1(); <span class="comment">// 调用 bar.methodB();</span></span><br><span class="line"></span><br><span class="line">    f1 = boost::bind(&amp;Foo::methodInt, &amp;foo, <span class="number">42</span>);</span><br><span class="line">    f1(); <span class="comment">// 调用 foo.methodInt(42);</span></span><br><span class="line"></span><br><span class="line">    boost::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)&gt; f2; <span class="comment">// int 参数，无返回值</span></span><br><span class="line">    f2 = boost::bind(&amp;Foo::methodInt, &amp;foo, _1);</span><br><span class="line">    f2(<span class="number">53</span>); <span class="comment">// 调用 foo.methodInt(53);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有 <code>boost::bind</code>，那么 <code>boost::function</code> 就什么都不是，而有了 <code>bind()</code>，“同一个类的不同对象可以 <code>delegate</code> 给不同的实现，从而实现不同的行为”（myan 语），简直就无敌了。</p>
<h2 id="2-对程序库的影响"><a href="#2-对程序库的影响" class="headerlink" title="2. 对程序库的影响"></a>2. 对程序库的影响</h2><p>程序库的设计不应该给使用者带来不必要的限制（耦合），<strong>而继承是仅次于最强的一种耦合（最强耦合的是友元）</strong>。如果一个程序库限制其使用者必须从某个class派生，那么我觉得这是一个糟糕的设计。不巧的是，目前有些程序库就是这么做的。</p>
<h3 id="例1：线程库"><a href="#例1：线程库" class="headerlink" title="例1：线程库"></a>例1：线程库</h3><h4 id="常规OO设计："><a href="#常规OO设计：" class="headerlink" title="常规OO设计："></a>常规OO设计：</h4><p>写一个 <code>Thread base class</code>，含有（纯）虚函数 <code>Thread#run()</code>，然后应用程序派生一个继承 <code>class</code>，覆写 <code>run()</code>。程序里的每一种线程对应一个 <code>Thread</code> 的派生类。例如 <code>Java</code> 的 <code>Thread</code> 可以这么用。</p>
<p>缺点：如果一个class的三个method需要在三个不同的线程中执行，就得写helper class(es)并玩一些OO把戏。</p>
<h4 id="基于closure的设计："><a href="#基于closure的设计：" class="headerlink" title="基于closure的设计："></a>基于closure的设计：</h4><p>令 <code>Thread</code> 是一个具体类，其构造函数接受 <code>Callable</code> 对象。应用程序只需提供一个 <code>Callable</code> 对象，创建一份<code>Thread</code> 实体，调用 <code>Thread#start()</code> 即可。<code>Java</code> 的 <code>Thread</code> 也可以这么用，传入一个 <code>Runnable</code> 对象。<code>C#</code> 的 <code>Thread</code> 只支持这一种用法，构造函数的参数是 <code>delegate ThreadStart</code>。<code>boost::thread</code> 也只支持这种用法。</p>
<p>一个基于 <code>closure</code> 的 <code>Thread class</code> 基本结构</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/function.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/bind.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> boost::function&lt;<span class="keyword">void</span>()&gt; ThreadCallback;</span><br><span class="line"></span><br><span class="line">    Thread(ThreadCallback cb) : cb_(cb) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* some magic to call run() in new created thread */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cb_();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ThreadCallback cb_;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">runInThread</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Foo foo;</span><br><span class="line">    <span class="function">Thread <span class="title">thread</span><span class="params">(boost::bind(&amp;Foo::runInThread, &amp;foo))</span></span>;</span><br><span class="line"></span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例2：网络库"><a href="#例2：网络库" class="headerlink" title="例2：网络库"></a>例2：网络库</h3><p>以 <code>boost::function</code> 作为桥梁，<code>NetServer class</code> 对<strong>其使用者没有任何类型上的限制，只对成员函数的参数和返回类型有限制</strong>。使用者 <code>EchoService</code> 也完全不知道 <code>NetServer</code> 的存在，只要在 <code>main()</code> 里把两者装配到一起，程序就跑起来了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// library</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/noncopyable.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/function.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/bind.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Connection</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetServer</span> :</span> boost::noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> boost::function&lt;<span class="keyword">void</span>(Connection *)&gt; ConnectionCallback;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> boost::function&lt;<span class="keyword">void</span>(Connection *,</span><br><span class="line">                                 <span class="keyword">const</span> <span class="keyword">void</span> *, <span class="keyword">int</span> len)&gt; MessageCallback;</span><br><span class="line"></span><br><span class="line">    NetServer(<span class="keyword">uint16_t</span> port);</span><br><span class="line"></span><br><span class="line">    ~NetServer();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerConnectionCallback</span><span class="params">(<span class="keyword">const</span> ConnectionCallback &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerMessageCallback</span><span class="params">(<span class="keyword">const</span> MessageCallback &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(Connection *, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// user</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EchoService</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 符合NetServer::sendMessage的原型</span></span><br><span class="line">    <span class="keyword">typedef</span> boost::function&lt;<span class="keyword">void</span>(Connection *,</span><br><span class="line">                                 <span class="keyword">const</span> <span class="keyword">void</span> *, <span class="keyword">int</span>)&gt; SendMessageCallback;</span><br><span class="line"></span><br><span class="line">    EchoService(<span class="keyword">const</span> SendMessageCallback &amp;sendMsgCb) :</span><br><span class="line">            sendMessageCb_(sendMsgCb) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 符合NetServer::NetServer::MessageCallback的原型</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Connection *conn, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Received Msg from Connection %d: %.*s/n"</span>,</span><br><span class="line">               conn-&gt;id(), size, (<span class="keyword">const</span> <span class="keyword">char</span> *) buf);</span><br><span class="line">        sendMessageCb_(conn, buf, size); <span class="comment">// echo back</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 符合NetServer::NetServer::ConnectionCallback的原型</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onConnection</span><span class="params">(Connection *conn)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Connection from %s:%d is %s/n"</span>,</span><br><span class="line">               conn-&gt;ipAddr(), conn-&gt;port(),</span><br><span class="line">               conn-&gt;connected() ? <span class="string">"UP"</span> : <span class="string">"DOWN"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SendMessageCallback sendMessageCb_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扮演上帝的角色，把各部件拼起来</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">NetServer <span class="title">server</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line">    <span class="function">EchoService <span class="title">echo</span><span class="params">(bind(&amp;NetServer::sendMessage,</span></span></span><br><span class="line"><span class="function"><span class="params">            &amp;server, _1, _2, _3))</span></span>;</span><br><span class="line"></span><br><span class="line">    server.registerMessageCallback(</span><br><span class="line">            bind(&amp;EchoService::onMessage, &amp;echo, _1, _2, _3));</span><br><span class="line"></span><br><span class="line">    server.registerConnectionCallback(</span><br><span class="line">            bind(&amp;EchoService::onConnection, &amp;echo, _1));</span><br><span class="line"></span><br><span class="line">    server.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-对面向对象程序设计的影响"><a href="#3-对面向对象程序设计的影响" class="headerlink" title="3. 对面向对象程序设计的影响"></a>3. 对面向对象程序设计的影响</h2><p>一直以来，我对面向对象有一种厌恶感，叠床架屋，绕来绕去的，一拳拳打在棉花上，不解决实际问题。面向对象三要素是封装、继承和多态。我认为<strong>封装是根本的，继承和多态则是可有可无</strong>。用 <code>class</code> 来表示 <code>concept</code>，这是根本的；至于继承和多态，其耦合性太强，往往不划算。</p>
<p>继承和多态不仅规定了函数的名称、参数、返回类型，还规定了类的继承关系。在现代的 <code>OO</code> 编程语言里，借助反射和 <code>attribute/annotation</code>，已经大大放宽了限制。举例来说，<strong><code>JUnit 3.x</code> 是用反射，找出派生类里的名字符合 <code>void test*()</code> 的函数来执行</strong>，这里就没继承什么事，只是对函数的名称有部分限制（继承是全面限制，一字不差）。至于 <code>JUnit 4.x</code> 和 <code>NUnit 2.x</code> 则更进一步，以 <code>annoatation/attribute</code> 来标明 <code>test case</code>，更没继承什么事了。</p>
<p>我的猜测是，当初提出面向对象的时候，<code>closure</code> 还没有一个通用的实现，所以它没能算作基本的抽象工具之一。现在既然 <code>closure</code> 已经这么方便了，或许我们应该重新审视面向对象设计，至少不要那么滥用继承。</p>
<p>自从找到了 <code>boost::function+boost::bind</code> 这对神兵利器，不用再考虑类直接的继承关系，只需要基于对象的设计(<code>object-based</code>)，拳拳到肉，程序写起来顿时顺手了很多。</p>
<h2 id="4-对面向对象设计模式的影响"><a href="#4-对面向对象设计模式的影响" class="headerlink" title="4. 对面向对象设计模式的影响"></a>4. 对面向对象设计模式的影响</h2><p><strong>既然虚函数能用 <code>closure</code> 代替</strong>，那么很多 <code>OO</code> 设计模式，尤其是行为模式，失去了存在的必要。另外，既然没有继承体系，那么创建型模式似乎也没啥用了。</p>
<p><strong>最明显的是 <code>Strategy</code>，不用累赘的 <code>Strategy</code> 基类和<code>ConcreteStrategyA</code>、<code>ConcreteStrategyB</code> 等派生类，一个 <code>boost::function&lt;&gt;</code> 成员就解决问题</strong>。在《设计模式》这本书提到了23个模式，我认为 <code>iterator</code> 有用（或许再加个 <code>State</code>），其他都在摆谱，拉虚架子，没啥用。或许它们解决了面向对象中的常见问题，不过要是我的程序里连面向对象（指继承和多态）都不用，那似乎也不用叨扰面向对象设计模式了。</p>
<p>或许 <code>closure-based programming</code> 将作为一种新的 <code>programming paradiam</code> 而流行起来。</p>
<h2 id="5-依赖注入与单元测试"><a href="#5-依赖注入与单元测试" class="headerlink" title="5. 依赖注入与单元测试"></a>5. 依赖注入与单元测试</h2><p>前面的 <code>EchoService</code> 可算是依赖注入的例子，<code>EchoService</code> 需要一个什么东西来发送消息，它对这个“东西”的要求只是函数原型满足 <code>SendMessageCallback</code>，而并不关系数据到底发到网络上还是发到控制台。<strong>在正常使用的时候，数据应该发给网络，而在做单元测试的时候，数据应该发给某个 <code>DataSink</code></strong>。</p>
<p>安照面向对象的思路，先写一个 <code>AbstractDataSink interface</code>，包含 <code>sendMessage()</code> 这个虚函数，然后派生出两个 <code>classes</code>：<code>NetDataSink</code> 和 <code>MockDataSink</code>，前面那个干活用，后面那个单元测试用。<code>EchoService</code> 的构造函数应该以 <code>AbstractDataSink*</code> 为参数，这样就实现了所谓的接口与实现分离。</p>
<p>我认为这么做纯粹是脱了裤子放屁，直接传入一个 <code>SendMessageCallback</code> 对象就能解决问题。在单元测试的时候，可以 <code>boost::bind()</code> 到 <code>MockServer</code> 上，或某个全局函数上，完全不用继承和虚函数，也不会影响现有的设计。</p>
<h2 id="6-什么时候使用继承？"><a href="#6-什么时候使用继承？" class="headerlink" title="6. 什么时候使用继承？"></a>6. 什么时候使用继承？</h2><p>如果是指 <code>OO</code> 中的 <code>public</code> 继承，即为了接口与实现分离，那么我<strong>只会在派生类的数目和功能完全确定的情况下使用</strong>。换句话说，不为将来的扩展考虑，这时候面向对象或许是一种不错的描述方法。一旦要考虑扩展，什么办法都没用，还不如把程序写简单点，将来好大改或重写。</p>
<p>如果是功能继承，那么我会考虑继承 <code>boost::noncopyable</code> 或 <code>boost::enable_shared_from_this</code>，下一篇 blog 会讲到 <code>enable_shared_from_this</code> 在实现多线程安全的 <code>Signal/Slot</code> 时的妙用。</p>
<p>例如，<code>IO-Multiplex</code> 在不同的操作系统下有不同的推荐实现，最通用的 <code>select()</code>，<code>POSIX</code> 的 <code>poll()</code>，<code>Linux</code> 的 <code>epoll()</code>，<code>FreeBSD</code> 的 <code>kqueue</code> 等等，数目固定，功能也完全确定，不用考虑扩展。那么设计一个 <code>NetLoop base class</code> 加若干具体 <code>classes</code> 就是不错的解决办法。</p>
<h2 id="7-基于接口的设计"><a href="#7-基于接口的设计" class="headerlink" title="7. 基于接口的设计"></a>7. 基于接口的设计</h2><p>这个问题来自那个经典的讨论：不会飞的企鹅（Penguin）究竟应不应该继承自鸟（Bird），如果 Bird 定义了 virtual function fly() 的话。讨论的结果是，<strong>把具体的行为提出来，作为 <code>interface</code></strong>，比如 Flyable （能飞的），Runnable（能跑的），然后让企鹅实现 Runnable，麻雀实现 Flyable 和 Runnable。（其实麻雀只能双脚跳，不能跑，这里不作深究。）</p>
<p>进一步的讨论表明，<code>interface</code> 的粒度应足够小，或许包含一个 <code>method</code> 就够了，那么 <strong><code>interface</code> 实际上退化成了给类型打的标签(tag)</strong>。<strong>在这种情况下，完全可以使用boost::function来代替</strong>，比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/function.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/bind.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 企鹅能游泳，也能跑</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Penguin</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 麻雀能飞，也能跑</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sparrow</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以 closure 作为接口</span></span><br><span class="line"><span class="keyword">typedef</span> boost::function&lt;<span class="keyword">void</span>()&gt; FlyCallback;</span><br><span class="line"><span class="keyword">typedef</span> boost::function&lt;<span class="keyword">void</span>()&gt; RunCallback;</span><br><span class="line"><span class="keyword">typedef</span> boost::function&lt;<span class="keyword">void</span>()&gt; SwimCallback;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个既用到run，也用到fly的客户class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo(FlyCallback flyCb, RunCallback runCb) :</span><br><span class="line">            flyCb_(flyCb),</span><br><span class="line">            runCb_(runCb) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    FlyCallback flyCb_;</span><br><span class="line">    RunCallback runCb_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个既用到run，也用到swim的客户class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Bar(SwimCallback swimCb, RunCallback runCb) :</span><br><span class="line">            swimCb_(swimCb),</span><br><span class="line">            runCb_(runCb) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SwimCallback swimCb_;</span><br><span class="line">    RunCallback runCb_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Sparrow s;</span><br><span class="line">    Penguin p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 装配起来，Foo要麻雀，Bar要企鹅。</span></span><br><span class="line">    <span class="function">Foo <span class="title">foo</span><span class="params">(boost::bind(&amp;Sparrow::fly, &amp;s),</span></span></span><br><span class="line"><span class="function"><span class="params">            boost::bind(&amp;Sparrow::run, &amp;s))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Bar <span class="title">bar</span><span class="params">(boost::bind(&amp;Penguin::swim, &amp;p),</span></span></span><br><span class="line"><span class="function"><span class="params">            boost::bind(&amp;Penguin::run, &amp;p))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-实现Signal-Slot"><a href="#8-实现Signal-Slot" class="headerlink" title="8. 实现Signal/Slot"></a>8. 实现Signal/Slot</h2><p><code>boost::function</code> + <code>boost::bind</code> 描述了一对一的回调，在项目中，我们借助 <code>boost::shared_ptr</code> + <code>boost::weak_ptr</code> 简洁地实现了多播(multi-cast)，即一对多的回调，并且考虑了对象的生命期管理与多线程安全；并且，自然地，对使用者的类型不作任何限制，篇幅略长，留作下一篇blog吧。（<code>boost::signals</code> 也实现了 <code>Signal/Slot</code>，但可惜不是线程安全的。）</p>
<p>最后，向伟大的C语言致敬！</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/%E4%BB%A5boost%E4%B8%AD%E7%9A%84function%E5%92%8Cbind%E5%8F%96%E4%BB%A3%E8%99%9A%E5%87%BD%E6%95%B0/" data-id="ck7naw850001k2cvehync20d7" class="article-share-link">分享到</a>
      

      
        <a href="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/%E4%BB%A5boost%E4%B8%AD%E7%9A%84function%E5%92%8Cbind%E5%8F%96%E4%BB%A3%E8%99%9A%E5%87%BD%E6%95%B0/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Boost/" rel="tag">Boost</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cpp/" rel="tag">Cpp</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-muduo中的网络库" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E5%BA%93/" class="article-date">
  <time datetime="2020-03-09T02:52:15.035Z" itemprop="datePublished">2020-03-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/">开源组件</a>►<a class="article-category-link" href="/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/">muduo</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E5%BA%93/">muduo 中的网络库</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><a href="#1-buffer">1. Buffer</a></li>
</ul>
<h3 id="1-Buffer"><a href="#1-Buffer" class="headerlink" title="1. Buffer"></a>1. Buffer</h3><ol start="0">
<li>部分源码</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> :</span> <span class="keyword">public</span> muduo::copyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kCheapPrepend = <span class="number">8</span>;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kInitialSize = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">explicit</span> <span class="title">Buffer</span><span class="params">(<span class="keyword">size_t</span> initialSize = kInitialSize)</span></span></span><br><span class="line">                    : buffer_(kCheapPrepend + initialSize),</span><br><span class="line">                      readerIndex_(kCheapPrepend),</span><br><span class="line">                      writerIndex_(kCheapPrepend) &#123;</span><br><span class="line"></span><br><span class="line">                assert(readableBytes() == <span class="number">0</span>);</span><br><span class="line">                assert(writableBytes() == initialSize);</span><br><span class="line">                assert(prependableBytes() == kCheapPrepend);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// implicit copy-ctor, move-ctor, dtor and assignment are fine</span></span><br><span class="line">            <span class="comment">// <span class="doctag">NOTE:</span> implicit move-ctor is added in g++ 4.6</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Buffer &amp;rhs)</span> </span>&#123;</span><br><span class="line">                buffer_.swap(rhs.buffer_);</span><br><span class="line">                <span class="built_in">std</span>::swap(readerIndex_, rhs.readerIndex_);</span><br><span class="line">                <span class="built_in">std</span>::swap(writerIndex_, rhs.writerIndex_);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            <span class="comment">// retrieve returns void, to prevent</span></span><br><span class="line">            <span class="comment">// string str(retrieve(readableBytes()), readableBytes());</span></span><br><span class="line">            <span class="comment">// the evaluation of two functions are unspecified</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">retrieve</span><span class="params">(<span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">                assert(len &lt;= readableBytes());</span><br><span class="line">                <span class="keyword">if</span> (len &lt; readableBytes()) &#123;</span><br><span class="line">                    readerIndex_ += len;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    retrieveAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="comment">/*restrict*/</span> data, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">                ensureWritableBytes(len);</span><br><span class="line">                <span class="built_in">std</span>::copy(data, data + len, beginWrite());</span><br><span class="line">                hasWritten(len);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">///</span></span><br><span class="line">            <span class="comment">/// Peek int64_t from network endian</span></span><br><span class="line">            <span class="comment">///</span></span><br><span class="line">            <span class="comment">/// Require: buf-&gt;readableBytes() &gt;= sizeof(int64_t)</span></span><br><span class="line">            <span class="function"><span class="keyword">int64_t</span> <span class="title">peekInt64</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">                assert(readableBytes() &gt;= <span class="keyword">sizeof</span>(<span class="keyword">int64_t</span>));</span><br><span class="line">                <span class="keyword">int64_t</span> be64 = <span class="number">0</span>;</span><br><span class="line">                ::<span class="built_in">memcpy</span>(&amp;be64, peek(), <span class="keyword">sizeof</span> be64);</span><br><span class="line">                <span class="keyword">return</span> sockets::networkToHost64(be64);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">prepend</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> * <span class="comment">/*restrict*/</span> data, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">                assert(len &lt;= prependableBytes());</span><br><span class="line">                readerIndex_ -= len;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">char</span> *d = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt;(data);</span><br><span class="line">                <span class="built_in">std</span>::copy(d, d + len, begin() + readerIndex_);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">shrink</span><span class="params">(<span class="keyword">size_t</span> reserve)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">FIXME:</span> use vector::shrink_to_fit() in C++ 11 if possible.</span></span><br><span class="line">                Buffer other;</span><br><span class="line">                other.ensureWritableBytes(readableBytes() + reserve);</span><br><span class="line">                other.append(toStringPiece());</span><br><span class="line">                swap(other);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// Read data directly into buffer.</span></span><br><span class="line">            <span class="comment">///</span></span><br><span class="line">            <span class="comment">/// It may implement with readv(2)</span></span><br><span class="line">            <span class="comment">/// @return result of read(2), @c errno is saved</span></span><br><span class="line">            <span class="function"><span class="keyword">ssize_t</span> <span class="title">readFd</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> *savedErrno)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">makeSpace</span><span class="params">(<span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (writableBytes() + prependableBytes() &lt; len + kCheapPrepend) &#123;</span><br><span class="line">                    <span class="comment">// <span class="doctag">FIXME:</span> move readable data</span></span><br><span class="line">                    buffer_.resize(writerIndex_ + len);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// move readable data to the front, make space inside buffer</span></span><br><span class="line">                    assert(kCheapPrepend &lt; readerIndex_);</span><br><span class="line">                    <span class="keyword">size_t</span> readable = readableBytes();</span><br><span class="line">                    <span class="built_in">std</span>::copy(begin() + readerIndex_,</span><br><span class="line">                              begin() + writerIndex_,</span><br><span class="line">                              begin() + kCheapPrepend);</span><br><span class="line">                    readerIndex_ = kCheapPrepend;</span><br><span class="line">                    writerIndex_ = readerIndex_ + readable;</span><br><span class="line">                    assert(readable == readableBytes());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; buffer_;</span><br><span class="line">            <span class="keyword">size_t</span> readerIndex_;</span><br><span class="line">            <span class="keyword">size_t</span> writerIndex_;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> kCRLF[];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<ol>
<li>提供的 public 方法</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Buffer &amp;rhs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">retrieve</span><span class="params">(<span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="comment">/*restrict*/</span> data, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>底层是一个 <code>vector&lt;char&gt;</code> 类型的 buffer_；</p>
<p> 具体原理见 “./5_Buffer类的设计.md”</p>
</li>
<li><p><code>ssize_t readFd(int fd, int *savedErrno)</code> 方法</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">Buffer::readFd</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> *savedErrno)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// saved an ioctl()/FIONREAD call to tell how much to read</span></span><br><span class="line">    <span class="keyword">char</span> extrabuf[<span class="number">65536</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">vec</span>[2];</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> writable = writableBytes();</span><br><span class="line"></span><br><span class="line">    vec[<span class="number">0</span>].iov_base = begin() + writerIndex_;</span><br><span class="line">    vec[<span class="number">0</span>].iov_len = writable;</span><br><span class="line">    vec[<span class="number">1</span>].iov_base = extrabuf;</span><br><span class="line">    vec[<span class="number">1</span>].iov_len = <span class="keyword">sizeof</span> extrabuf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// when there is enough space in this buffer, don't read into extrabuf.</span></span><br><span class="line">    <span class="comment">// when extrabuf is used, we read 128k-1 bytes at most.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> iovcnt = (writable &lt; <span class="keyword">sizeof</span> extrabuf) ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">ssize_t</span> n = sockets::readv(fd, vec, iovcnt);</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        *savedErrno = errno;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (implicit_cast&lt;<span class="keyword">size_t</span>&gt;(n) &lt;= writable) &#123;</span><br><span class="line">        writerIndex_ += n;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        writerIndex_ = buffer_.size();</span><br><span class="line">        append(extrabuf, n - writable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的原理是：</p>
<ul>
<li><p>走内核的系统调用较为耗时，为了提高效率，最好一次读完</p>
</li>
<li><p>最终希望达到的目标是，数据从内核缓冲区全部进入 <code>buffer</code> 中的缓冲区(底层是一个 <code>vector</code>)</p>
</li>
<li><p>第一点和第二点有所矛盾，因此这个方法在<strong>栈</strong>上先分配一个 <code>char extrabuf[65536];</code>：如果 buffer 中的空间大小足够，就直接从内核拷贝到 buffer 中；如果不够，那就先读到栈上的 65536 字节的缓冲区，然后再 append 到 buffer 中，而 append 的过程是 buffer 类本身要考虑的事情</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E5%BA%93/" data-id="ck7naw84n000q2cvegos99i17" class="article-share-link">分享到</a>
      

      
        <a href="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E5%BA%93/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cpp/" rel="tag">Cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IO/" rel="tag">IO</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Buffer类的设计" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/Buffer%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1/" class="article-date">
  <time datetime="2020-03-09T02:49:12.510Z" itemprop="datePublished">2020-03-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/">开源组件</a>►<a class="article-category-link" href="/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/">muduo</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/Buffer%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1/">Buffer 类的设计</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>原文链接：<a href="https://blog.csdn.net/Solstice/article/details/6329080" target="_blank" rel="noopener">https://blog.csdn.net/Solstice/article/details/6329080</a></p>
</blockquote>
<ul>
<li><a href="#1muduo-%e7%9a%84-io-%e6%a8%a1%e5%9e%8b">1.Muduo 的 IO 模型</a></li>
<li><a href="#2%e4%b8%ba%e4%bb%80%e4%b9%88-non-blocking-%e7%bd%91%e7%bb%9c%e7%bc%96%e7%a8%8b%e4%b8%ad%e5%ba%94%e7%94%a8%e5%b1%82-buffer-%e6%98%af%e5%bf%85%e9%a1%bb%e7%9a%84">2.为什么 non-blocking 网络编程中应用层 buffer 是必须的？</a><ul>
<li><a href="#tcpconnection-%e5%bf%85%e9%a1%bb%e8%a6%81%e6%9c%89-output-buffer">TcpConnection 必须要有 output buffer</a></li>
<li><a href="#tcpconnection-%e5%bf%85%e9%a1%bb%e8%a6%81%e6%9c%89-input-buffer">TcpConnection 必须要有 input buffer</a></li>
</ul>
</li>
<li><a href="#3-buffer-%e7%9a%84%e8%a6%81%e6%b1%82">3. Buffer 的要求</a><ul>
<li><a href="#bufferreadfd">Buffer::readFd()</a></li>
<li><a href="#%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8">线程安全？</a></li>
</ul>
</li>
<li><a href="#4-muduo-buffer-%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84">4. Muduo Buffer 的数据结构</a></li>
<li><a href="#5-muduo-buffer-%e7%9a%84%e6%93%8d%e4%bd%9c">5. Muduo Buffer 的操作</a><ul>
<li><a href="#%e5%9f%ba%e6%9c%ac%e7%9a%84-read-write-cycle">基本的 read-write cycle</a></li>
<li><a href="#%e8%87%aa%e5%8a%a8%e5%a2%9e%e9%95%bf">自动增长</a></li>
<li><a href="#size-%e4%b8%8e-capacity">size() 与 capacity()</a></li>
<li><a href="#%e5%86%85%e9%83%a8%e8%85%be%e6%8c%aa">内部腾挪</a></li>
<li><a href="#prepend">prepend</a></li>
</ul>
</li>
<li><a href="#6-%e5%85%b6%e4%bb%96%e8%ae%be%e8%ae%a1%e6%96%b9%e6%a1%88">6. 其他设计方案</a><ul>
<li><a href="#%e4%b8%8d%e7%94%a8-vector">不用 vector？</a></li>
<li><a href="#zero-copy">Zero copy ?</a></li>
</ul>
</li>
<li><a href="#7-%e6%80%a7%e8%83%bd%e6%98%af%e4%b8%8d%e6%98%af%e9%97%ae%e9%a2%98%e7%9c%8b%e8%b7%9f%e8%b0%81%e6%af%94">7. 性能是不是问题？看跟谁比</a></li>
</ul>
<h2 id="1-Muduo-的-IO-模型"><a href="#1-Muduo-的-IO-模型" class="headerlink" title="1.Muduo 的 IO 模型"></a>1.Muduo 的 IO 模型</h2><p>UNPv1 第 6.2 节总结了 Unix/Linux 上的五种 IO 模型：阻塞(blocking)、非阻塞(non-blocking)、IO 复用(IO multiplexing)、信号驱动(signal-driven)、异步(asynchronous)。<strong>这些都是单线程下的 IO 模型</strong>。</p>
<p>C10k 问题的页面介绍了五种 IO 策略，把线程也纳入考量。（现在 C10k 已经不是什么问题，C100k 也不是大问题，C1000k 才算得上挑战）。</p>
<p><strong>在这个多核时代，线程是不可避免的</strong>。那么服务端网络编程该如何选择线程模型呢？我赞同 libev 作者的观点：one loop per thread is usually a good model。之前我也不止一次表述过这个观点，见《多线程服务器的常用编程模型》《多线程服务器的适用场合》。</p>
<p>如果采用 <strong><code>one loop per thread</code></strong> 的模型，多线程服务端编程的问题就简化为如何设计一个高效且易于使用的 event loop，然后每个线程 run 一个 event loop 就行了（当然、同步和互斥是不可或缺的）。在“高效”这方面已经有了很多成熟的范例（libev、libevent、memcached、varnish、lighttpd、nginx），在“易于使用”方面我希望 muduo 能有所作为。（muduo 可算是用现代 C++ 实现了 Reactor 模式，比起原始的 Reactor 来说要好用得多。）</p>
<p>event loop 是 non-blocking 网络编程的核心，在现实生活中，<strong>non-blocking 几乎总是和 IO-multiplexing 一起使用</strong>，原因有两点：</p>
<ul>
<li><p>没有人真的会用轮询 (busy-pooling) 来检查某个 non-blocking IO 操作是否完成，这样太浪费 CPU cycles。</p>
</li>
<li><p><strong>IO-multiplex 一般不能和 blocking IO 用在一起</strong>，因为 blocking IO 中 read()/write()/accept()/connect() 都有可能阻塞当前线程，<strong>这样线程就没办法处理其他 socket 上的 IO 事件了</strong>。见 UNPv1 第 16.6 节“nonblocking accept”的例子。</p>
</li>
</ul>
<p>所以，<strong>当我提到 non-blocking 的时候，实际上指的是 non-blocking + IO-muleiplexing</strong>，单用其中任何一个是不现实的。另外，本文所有的“连接”均指 TCP 连接，socket 和 connection 在文中可互换使用。</p>
<p>当然，non-blocking 编程比 blocking 难得多，见陈硕在《Muduo 网络编程示例之零：前言》中“TCP 网络编程本质论”一节列举的难点。<strong>基于 event loop 的网络编程跟直接用 C/C++ 编写单线程 Windows 程序颇为相像</strong>：</p>
<ul>
<li><p>程序不能阻塞，否则窗口就失去响应了；</p>
</li>
<li><p>在 event handler 中，程序要尽快交出控制权，返回窗口的事件循环。</p>
</li>
</ul>
<h2 id="2-为什么-non-blocking-网络编程中应用层-buffer-是必须的？"><a href="#2-为什么-non-blocking-网络编程中应用层-buffer-是必须的？" class="headerlink" title="2.为什么 non-blocking 网络编程中应用层 buffer 是必须的？"></a>2.为什么 non-blocking 网络编程中应用层 buffer 是必须的？</h2><p>Non-blocking IO 的<strong>核心思想</strong>是避免阻塞在 read() 或 write() 或其他 IO 系统调用上，这样可以最大限度地复用 thread-of-control，<strong>让一个线程能服务于多个 socket 连接</strong>。<strong>IO 线程只能阻塞在 IO-multiplexing 函数上</strong>，如 <code>select()/poll()/epoll_wait()</code>。这样一来，应用层的缓冲是必须的，每个 TCP socket 都要有 stateful 的 input buffer 和 output buffer。</p>
<h3 id="TcpConnection-必须要有-output-buffer"><a href="#TcpConnection-必须要有-output-buffer" class="headerlink" title="TcpConnection 必须要有 output buffer"></a>TcpConnection 必须要有 output buffer</h3><p>考虑一个常见场景：程序想通过 TCP 连接发送 100k 字节的数据，但是在 write() 调用中，操作系统只接受了 80k 字节（受 TCP advertised window 的控制，细节见 TCPv1），你肯定不想在原地等待，因为不知道会等多久（取决于对方什么时候接受数据，然后滑动 TCP 窗口）。<strong>程序应该尽快交出控制权</strong>，返回 event loop。在这种情况下，剩余的 20k 字节数据怎么办？</p>
<p>对于应用程序而言，它只管生成数据，它不应该关心到底数据是一次性发送还是分成几次发送，<strong>这些应该由网络库来操心</strong>，程序只要调用 TcpConnection::send() 就行了，网络库会负责到底。<em>网络库应该接管这剩余的 20k 字节数据，把它保存在该 TCP connection 的 output buffer 里，然后注册 POLLOUT 事件，一旦 socket 变得可写就立刻发送数据</em>。当然，这第二次 write() 也不一定能完全写入 20k 字节，如果还有剩余，网络库应该继续关注 POLLOUT 事件；如果写完了 20k 字节，网络库应该停止关注 POLLOUT，以免造成 busy loop。（Muduo EventLoop 采用的是 <code>epoll level trigger</code>，这么做的具体原因我以后再说。）</p>
<p>如果程序又写入了 50k 字节，而这时候 output buffer 里还有待发送的 20k 数据，那么网络库不应该直接调用 write()，而应该把这 50k 数据 append 在那 20k 数据之后，等 socket 变得可写的时候再一并写入。</p>
<p>如果 output buffer 里还有待发送的数据，而程序又想关闭连接（对程序而言，调用 TcpConnection::send() 之后他就认为数据迟早会发出去），那么这时候网络库不能立刻关闭连接，而要等数据发送完毕，见我在《为什么 muduo 的 shutdown() 没有直接关闭 TCP 连接？》一文中的讲解。</p>
<p><strong>综上，要让程序在 write 操作上不阻塞，网络库必须要给<code>每个 tcp connection</code> 配置 output buffer</strong>。</p>
<h3 id="TcpConnection-必须要有-input-buffer"><a href="#TcpConnection-必须要有-input-buffer" class="headerlink" title="TcpConnection 必须要有 input buffer"></a>TcpConnection 必须要有 input buffer</h3><p>TCP 是一个无边界的字节流协议，接收方必须要处理“收到的数据尚不构成一条完整的消息”和“一次收到两条消息的数据”等等情况。一个常见的场景是，发送方 send 了两条 10k 字节的消息（共 20k），接收方收到数据的情况可能是：</p>
<ul>
<li>一次性收到 20k 数据</li>
<li>分两次收到，第一次 5k，第二次 15k</li>
<li>分两次收到，第一次 15k，第二次 5k</li>
<li>分两次收到，第一次 10k，第二次 10k</li>
<li>分三次收到，第一次 6k，第二次 8k，第三次 6k</li>
<li>其他任何可能</li>
</ul>
<p>网络库在处理“socket 可读”事件的时候，必须一次性把 socket 里的数据读完（<strong>从操作系统 buffer 搬到应用层 buffer</strong>），否则会反复触发 POLLIN 事件，造成 busy-loop。（Again, Muduo EventLoop 采用的是 <code>epoll level trigger</code>，这么做的具体原因我以后再说。）</p>
<p>那么网络库必然要应对“数据不完整”的情况，收到的数据先放到 <code>input buffer</code> 里，<strong>等构成一条完整的消息再通知程序的业务逻辑</strong>。这通常是 codec 的职责，见陈硕《Muduo 网络编程示例之二：Boost.Asio 的聊天服务器》一文中的“TCP 分包”的论述与代码。</p>
<p>所以，在 tcp 网络编程中，网络库必须要给每个 tcp connection 配置 input buffer。</p>
<hr>
<p>所有 muduo 中的 IO 都是带缓冲的 IO (buffered IO)，<strong>你不会自己去 read() 或 write() 某个 socket，只会操作 TcpConnection 的 input buffer 和 output buffer</strong>。更确切的说，是在 onMessage() 回调里读取 input buffer；调用 TcpConnection::send() 来间接操作 output buffer，一般不会直接操作 output buffer。</p>
<p>btw, muduo 的 onMessage() 的原型如下，它既可以是 free function，也可以是 member function，反正 muduo TcpConnection 只认 <code>boost::function&lt;&gt;</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, Buffer* buf, Timestamp receiveTime)</span></span>;</span><br></pre></td></tr></table></figure>

<p>对于网络程序来说，一个简单的验收测试是：输入数据每次收到一个字节（200 字节的输入数据会分 200 次收到，每次间隔 10 ms），程序的功能不受影响。对于 Muduo 程序，通常可以用 codec 来分离“消息接收”与“消息处理”，见陈硕《在 muduo 中实现 protobuf 编解码器与消息分发器》一文中对“编解码器 codec”的介绍。</p>
<p>如果某个网络库只提供相当于 char buf[8192] 的缓冲，或者根本不提供缓冲区，而仅仅通知程序“某 socket 可读/某 socket 可写”，要程序自己操心 IO buffering，这样的网络库用起来就很不方便了。（我有所指，你懂得。）</p>
<h2 id="3-Buffer-的要求"><a href="#3-Buffer-的要求" class="headerlink" title="3. Buffer 的要求"></a>3. Buffer 的要求</h2><p>Muduo Buffer 的设计考虑了常见的网络编程需求，我试图在易用性和性能之间找一个平衡点，目前这个平衡点更偏向于易用性。</p>
<p>Muduo Buffer 的设计要点：</p>
<ul>
<li>对外表现为一块连续的内存(char*, len)，以方便客户代码的编写。</li>
<li>其 size() 可以自动增长，以适应不同大小的消息。它不是一个 fixed size array (即 char buf[8192])。</li>
<li>内部以 vector of char 来保存数据，并提供相应的访问函数。</li>
</ul>
<p>Buffer 其实像是一个 <code>queue</code>，从末尾写入数据，从头部读出数据。</p>
<p>谁会用 Buffer？谁写谁读？根据前文分析，<strong><code>TcpConnection</code> 会有两个 Buffer 成员，<code>input buffer</code> 与 <code>output buffer</code></strong>。</p>
<ul>
<li><p>input buffer，TcpConnection 会从 socket 读取数据，然后写入 input buffer（其实这一步是用 Buffer::readFd() 完成的）；<strong>客户代码从 input buffer 读取数据</strong>。</p>
</li>
<li><p>output buffer，<strong>客户代码会把数据写入 output buffer</strong>（其实这一步是用 TcpConnection::send() 完成的；TcpConnection 从 output buffer 读取数据并写入 socket。</p>
</li>
</ul>
<p><strong>其实，input 和 output 是针对客户代码而言，客户代码从 input 读，往 output 写。TcpConnection 的读写正好相反。</strong></p>
<p>这里不介绍每个成员函数的作用，留给《Muduo 网络编程示例》系列。下文会仔细介绍 readIndex 和 writeIndex 的作用。</p>
<h3 id="Buffer-readFd"><a href="#Buffer-readFd" class="headerlink" title="Buffer::readFd()"></a>Buffer::readFd()</h3><p>我在《Muduo 网络编程示例之零：前言》中写道</p>
<p>在非阻塞网络编程中，如何设计并使用缓冲区？</p>
<ul>
<li>一方面我们希望减少系统调用，一次读的数据越多越划算，那么似乎应该准备一个大的缓冲区。</li>
<li>另一方面，我们系统减少内存占用。如果有 10k 个连接，每个连接一建立就分配 64k 的读缓冲的话，将占用 640M 内存，而大多数时候这些缓冲区的使用率很低。</li>
</ul>
<p>muduo 用 <strong>readv 结合栈上空间</strong>巧妙地解决了这个问题。<br>具体做法是，在栈上准备一个 65536 字节的 stackbuf，然后利用 readv() 来读取数据，iovec 有两块，第一块指向 muduo Buffer 中的 writable 字节，另一块指向栈上的 stackbuf。这样如果读入的数据不多，那么全部都读到 Buffer 中去了；如果长度超过 Buffer 的 writable 字节数，就会读到栈上的 stackbuf 里，然后程序再把 stackbuf 里的数据 append 到 Buffer 中。</p>
<p>这么做利用了临时栈上空间，避免开巨大 Buffer 造成的内存浪费，也避免反复调用 read() 的系统开销（通常一次 readv() 系统调用就能读完全部数据）。</p>
<p>这算是一个小小的创新吧。</p>
<h3 id="线程安全？"><a href="#线程安全？" class="headerlink" title="线程安全？"></a>线程安全？</h3><p><code>muduo::net::Buffer</code> <strong>不是线程安全的</strong>，这么做是有意的，原因如下：</p>
<p>对于 input buffer，onMessage() 回调始终发生在该 TcpConnection 所属的那个 IO 线程，应用程序应该在 onMessage() 完成对 input buffer 的操作，<strong>并且不要把 input buffer 暴露给其他线程</strong>。这样所有对 input buffer 的操作都在同一个线程，Buffer class 不必是线程安全的。<br>对于 output buffer，应用程序不会直接操作它，而是调用 TcpConnection::send() 来发送数据，<strong>后者是线程安全的</strong>。<br>如果 TcpConnection::send() 调用发生在该 TcpConnection 所属的那个 IO 线程，那么它会转而调用 TcpConnection::sendInLoop()，sendInLoop() 会在当前线程（也就是 IO 线程）操作 output buffer；如果 TcpConnection::send() 调用发生在别的线程，它不会在当前线程调用 sendInLoop() ，而是通过 EventLoop::runInLoop() 把 sendInLoop() 函数调用转移到 IO 线程（听上去颇为神奇？），这样 sendInLoop() 还是会在 IO 线程操作 output buffer，不会有线程安全问题。当然，<strong>跨线程的函数转移调用涉及函数参数的跨线程传递，一种简单的做法是把数据拷一份，绝对安全</strong>（不明白的同学请阅读代码）。</p>
<p><strong>另一种更为高效做法是用 swap()</strong>。这就是为什么 TcpConnection::send() 的某个重载以 Buffer* 为参数，而不是 const Buffer&amp;，这样可以避免拷贝，而用 Buffer::swap() 实现高效的线程间数据转移。（最后这点，仅为设想，暂未实现。目前仍然以数据拷贝方式在线程间传递，略微有些性能损失。）</p>
<h2 id="4-Muduo-Buffer-的数据结构"><a href="#4-Muduo-Buffer-的数据结构" class="headerlink" title="4. Muduo Buffer 的数据结构"></a>4. Muduo Buffer 的数据结构</h2><p>Buffer 的内部是一个 <code>vector of char</code>，它是一块连续的内存。此外，Buffer 有两个 data members (readerIndex_ 和 writerIndex_)，指向该 vector 中的元素。这两个 indices 的类型是 int，不是 char<em>，目的是应对迭代器失效。muduo Buffer 的设计参考了 Netty 的 ChannelBuffer 和 libevent 1.4.x 的 evbuffer。*</em>不过，其 prependable 可算是一点“微创新”**。</p>
<p>Muduo Buffer 的数据结构如下：</p>
<p>图 1</p>
<p><img src="/resources/muduo_buffer.gif" alt="Muduo Buffer"></p>
<p>两个 indices 把 vector 的内容分为三块：<code>prependable</code>、<code>readable</code>、<code>writable</code>，各块的大小是（公式一）：</p>
<ul>
<li><p><code>prependable = readIndex</code></p>
</li>
<li><p><code>readable = writeIndex - readIndex</code></p>
</li>
<li><p><code>writable = size() - writeIndex</code></p>
</li>
</ul>
<p>注：如前文所述，对于客户代码和 TcpConnection 来说，无论这个 buffer 用于 input 还是 output，客户代码和 TcpConnection 的方向永远是<strong>相反</strong>的：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">input buffer</th>
<th align="center">output buffer</th>
</tr>
</thead>
<tbody><tr>
<td align="center">客户代码</td>
<td align="center">read</td>
<td align="center">write</td>
</tr>
<tr>
<td align="center">TcpConnection</td>
<td align="center">write</td>
<td align="center">read</td>
</tr>
</tbody></table>
<p>（prependable 的作用留到后面讨论。）</p>
<p>readIndex 和 writeIndex 满足以下不变式(invariant):</p>
<p><code>0 ≤ readIndex ≤ writeIndex ≤ data.size()</code></p>
<p>Muduo Buffer 里有两个常数 kCheapPrepend 和 kInitialSize，定义了 prependable 的初始大小和 writable 的初始大小。（readable 的初始大小为 0。）在初始化之后，Buffer 的数据结构如下：括号里的数字是该变量或常量的值。</p>
<p>图 2</p>
<p><img src="/resources/muduo_buffer.gif" alt="Buffer初始化以后的结构"></p>
<p>根据以上（公式一）可算出各块的大小，刚刚初始化的 Buffer 里没有 payload 数据，所以 readable == 0。</p>
<h2 id="5-Muduo-Buffer-的操作"><a href="#5-Muduo-Buffer-的操作" class="headerlink" title="5. Muduo Buffer 的操作"></a>5. Muduo Buffer 的操作</h2><h3 id="基本的-read-write-cycle"><a href="#基本的-read-write-cycle" class="headerlink" title="基本的 read-write cycle"></a>基本的 read-write cycle</h3><p>Buffer 初始化后的情况见图 1，如果有人向 Buffer 写入了 200 字节，那么其布局是：</p>
<p>图 3</p>
<p><img src="/resources/write_data_to_buffer.gif" alt="向Buffer写入200字节"></p>
<p>图 3 中 writeIndex 向后移动了 200 字节，readIndex 保持不变，readable 和 writable 的值也有变化。</p>
<p>如果有人从 Buffer read() &amp; retrieve() （下称“读入”）了 50 字节，结果见图 4。与上图相比，readIndex 向后移动 50 字节，writeIndex 保持不变，readable 和 writable 的值也有变化（这句话往后从略）。</p>
<p>图 4</p>
<p><img src="/resources/read_data_from_buffer.gif" alt="从Buffer读字节"></p>
<p>然后又写入了 200 字节，writeIndex 向后移动了 200 字节，readIndex 保持不变，见图 5。</p>
<p>图 5</p>
<p><img src="/resources/0_1303014375Esqf.gif" alt="图5"></p>
<p>接下来，一次性读入 350 字节，请注意，由于全部数据读完了，readIndex 和 writeIndex 返回原位以备新一轮使用，见图 6，<strong>这和图 2 是一样的</strong>。</p>
<p>图 6</p>
<p><img src="/resources/empty_buffer.gif" alt="读取全部数据后的空buffer"></p>
<p>以上过程可以看作是发送方发送了两条消息，长度分别为 50 字节和 350 字节，接收方分两次收到数据，每次 200 字节，然后进行分包，再分两次回调客户代码。</p>
<h3 id="自动增长"><a href="#自动增长" class="headerlink" title="自动增长"></a>自动增长</h3><p>Muduo Buffer <strong>不是固定长度的</strong>，它可以<strong>自动增长</strong>，这是使用 vector 的直接好处。</p>
<p>假设当前的状态如图 7 所示。（这和前面图 5 是一样的。）</p>
<p>图 7</p>
<p><img src="/resources/0_1303014376eDV2.gif" alt="图7"></p>
<p>客户代码一次性写入 1000 字节，而当前可写的字节数只有 624，那么 buffer <strong>会自动增长以容纳全部数据</strong>，得到的结果是图 8。注意 readIndex 返回到了前面，以保持 prependable 等于 kCheapPrependable。<strong>由于 vector 重新分配了内存，原来指向它元素的指针会失效，这就是为什么 readIndex 和 writeIndex 是整数下标而不是指针</strong>。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeSpace</span><span class="params">(<span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (writableBytes() + prependableBytes() &lt; len + kCheapPrepend) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">FIXME:</span> move readable data</span></span><br><span class="line">        buffer_.resize(writerIndex_ + len);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// move readable data to the front, make space inside buffer</span></span><br><span class="line">        assert(kCheapPrepend &lt; readerIndex_);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">size_t</span> readable = readableBytes();</span><br><span class="line">        <span class="built_in">std</span>::copy(begin() + readerIndex_, </span><br><span class="line">        begin() + writerIndex_, begin() + kCheapPrepend);</span><br><span class="line"></span><br><span class="line">        readerIndex_ = kCheapPrepend;</span><br><span class="line">        writerIndex_ = readerIndex_ + readable;</span><br><span class="line"></span><br><span class="line">        assert(readable == readableBytes());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>图 8</p>
<p><img src="/resources/auto_append.gif" alt="自动扩容"></p>
<p>然后读入 350 字节，readIndex 前移，见图 9。</p>
<p>图 9</p>
<p><img src="/resources/0_1303014376H0VH.gif" alt="图9"></p>
<p>最后，读完剩下的 1000 字节，readIndex 和 writeIndex 返回 kCheapPrependable，见图 10。</p>
<p>图 10</p>
<p><img src="/resources/0_13030143778RY9.gif" alt="图10"></p>
<p><strong>注意 buffer 并没有缩小大小</strong>，下次写入 1350 字节就不会重新分配内存了。换句话说，<strong>Muduo Buffer 的 size() 是自适应的</strong>，它一开始的初始值是 1k，如果程序里边经常收发 10k 的数据，那么用几次之后它的 size() 会自动增长到 10k，然后就保持不变。这样一方面避免浪费内存（有的程序可能只需要 4k 的缓冲），另一方面避免反复分配内存。当然，<strong>客户代码可以手动 shrink() buffer size()</strong>。</p>
<h3 id="size-与-capacity"><a href="#size-与-capacity" class="headerlink" title="size() 与 capacity()"></a>size() 与 capacity()</h3><p>使用 vector 的另一个好处是<strong>它的 capcity() 机制减少了内存分配的次数</strong>。比方说程序反复写入 1 字节，muduo Buffer 不会每次都分配内存，vector 的 capacity() 以指数方式增长，让 push_back() 的平均复杂度是常数。比方说经过第一次增长，size() 刚好满足写入的需求，如图 11。但这个时候 vector 的 capacity() 已经大于 size()，在接下来写入 capacity()-size() 字节的数据时，都不会重新分配内存，见图 12。</p>
<p>图 11</p>
<p><img src="/resources/0_13030143775oe2.gif" alt="图11"></p>
<p>图 12</p>
<p><img src="/resources/0_1303014377y2YN.gif" alt="图12"></p>
<p>细心的读者可能会发现用 capacity() 也不是完美的，它有优化的余地。具体来说，<em>vector::resize() 会初始化(memset/bzero)内存，而我们不需要它初始化，因为反正立刻就要填入数据</em>。比如，在图 12 的基础上写入 200 字节，由于 capacity() 足够大，不会重新分配内存，这是好事；但是 vector::resize() 会先把那 200 字节设为 0 （图 13），然后 muduo buffer 再填入数据（图 14）。这么做稍微有点浪费，不过我不打算优化它，除非它确实造成了性能瓶颈。（精通 STL 的读者可能会说用 vector::append() 以避免浪费，但是 writeIndex 和 size() 不一定是对齐的，会有别的麻烦。）</p>
<p>图 13</p>
<p><img src="/resources/0_1303014378Azb6.gif" alt="图13"></p>
<p>图 14</p>
<p><img src="/resources/0_1303014378rn6e.gif" alt="图14"></p>
<p>google protobuf 中有一个 STLStringResizeUninitialized 函数，干的就是这个事情。</p>
<h3 id="内部腾挪"><a href="#内部腾挪" class="headerlink" title="内部腾挪"></a>内部腾挪</h3><p>有时候，经过若干次读写，readIndex 移到了比较靠后的位置，留下了巨大的 prependable 空间，见图 14。</p>
<p>图 14</p>
<p><img src="/resources/internal_move.gif" alt="内部腾挪"></p>
<p>这时候，如果我们想写入 300 字节，而 writable 只有 200 字节，怎么办？muduo Buffer 在这种情况下不会重新分配内存，而是先把已有的数据移到前面去，腾出 writable 空间，见图 15。</p>
<p>图 15</p>
<p><img src="/resources/0_1303014379m3MC.gif" alt="图15"></p>
<p>然后，就可以写入 300 字节了，见图 16。</p>
<p>图 16</p>
<p><img src="/resources/0_1303014380uIzd.gif" alt="图16"></p>
<p>这么做的原因是，如果重新分配内存，反正也是要把数据拷到新分配的内存区域，代价只会更大。</p>
<h3 id="prepend"><a href="#prepend" class="headerlink" title="prepend"></a>prepend</h3><p>前面说 muduo Buffer 有个小小的创新（或许不是创新，我记得在哪儿看到过类似的做法，忘了出处），即提供 prependable 空间，<strong>让程序能以很低的代价在数据前面添加几个字节</strong>。</p>
<p>比方说，程序以固定的4个字节表示消息的长度（即《Muduo 网络编程示例之二：Boost.Asio 的聊天服务器》中的 LengthHeaderCodec），<strong>我要序列化一个消息，但是不知道它有多长</strong>，那么我可以一直 append() 直到序列化完成（图 17，写入了 200 字节），<strong>然后再在序列化数据的前面添加消息的长度</strong>（图 18，把 200 这个数 prepend 到首部）。</p>
<p>图 17</p>
<p><img src="/resources/0_1303014380qA8E.gif" alt="图17"></p>
<p>图 18</p>
<p><img src="/resources/0_1303014380Np9H.gif" alt="图18"></p>
<p><strong>通过预留 kCheapPrependable 空间，可以简化客户代码，一个简单的空间换时间思路</strong>。</p>
<h2 id="6-其他设计方案"><a href="#6-其他设计方案" class="headerlink" title="6. 其他设计方案"></a>6. 其他设计方案</h2><p>这里简单谈谈其他可能的应用层 buffer 设计方案。</p>
<h3 id="不用-vector？"><a href="#不用-vector？" class="headerlink" title="不用 vector？"></a>不用 vector？</h3><p>如果有 STL 洁癖，那么可以自己管理内存，以 4 个指针为 buffer 的成员，数据结构见图 19。</p>
<p>图 19</p>
<p><img src="/resources/nonvector_buffer.gif" alt="非vector的buffer"></p>
<p>说实话我不觉得这种方案比 vector 好。代码变复杂，性能也未见得有 noticeable 的改观。</p>
<p>如果放弃“连续性”要求，可以用 circular buffer，这样可以减少一点内存拷贝（没有“内部腾挪”）。</p>
<h3 id="Zero-copy"><a href="#Zero-copy" class="headerlink" title="Zero copy ?"></a>Zero copy ?</h3><p>如果对性能有极高的要求，受不了 copy() 与 resize()，那么可以考虑实现分段连续的 zero copy buffer 再配合 gather scatter IO，数据结构如图 20，这是 libevent 2.0.x 的设计方案。TCPv2介绍的 BSD TCP/IP 实现中的 mbuf 也是类似的方案，Linux 的 sk_buff 估计也差不多。细节有出入，但<strong>基本思路都是不要求数据在内存中连续，而是用链表把数据块链接到一起</strong>。</p>
<p>图 20</p>
<p><img src="/resources/zero_copy.gif" alt="zero copy"></p>
<p>当然，<strong>高性能的代价是代码变得晦涩难读</strong>，buffer 不再是连续的，parse 消息会稍微麻烦。如果你的程序只处理 protobuf Message，这不是问题，因为 protobuf 有 ZeroCopyInputStream 接口，只要实现这个接口，parsing 的事情就交给 protobuf Message 去操心了。</p>
<h2 id="7-性能是不是问题？看跟谁比"><a href="#7-性能是不是问题？看跟谁比" class="headerlink" title="7. 性能是不是问题？看跟谁比"></a>7. 性能是不是问题？看跟谁比</h2><p>看到这里，有的读者可能会嘀咕，muduo Buffer 有那么多可以优化的地方，其性能会不会太低？对此，我的回应是“可以优化，不一定值得优化。”</p>
<p><strong>Muduo 的设计目标是用于开发公司内部的分布式程序</strong>。换句话说，它是用来写专用的 Sudoku server 或者游戏服务器，不是用来写通用的 httpd 或 ftpd 或 www proxy。前者通常有业务逻辑，后者更强调高并发与高吞吐。</p>
<p>以 Sudoku 为例，假设求解一个 Sudoku 问题需要 0.2ms，服务器有 8 个核，那么理想情况下每秒最多能求解 40,000 个问题。每次 Sudoku 请求的数据大小低于 100 字节（一个 9x9 的数独只要 81 字节，加上 header 也可以控制在 100 bytes 以下），就是说 100 x 40000 = 4 MB per second 的吞吐量就足以让服务器的 CPU 饱和。在这种情况下，去优化 Buffer 的内存拷贝次数似乎没有意义。</p>
<p>再举一个例子，目前最常用的千兆以太网的裸吞吐量是 125MB/s，扣除以太网 header、IP header、TCP header之后，应用层的吞吐率大约在 115 MB/s 上下。而现在服务器上最常用的 DDR2/DDR3 内存的带宽至少是 4GB/s，比千兆以太网高 40 倍以上。就是说，对于几 k 或几十 k 大小的数据，在内存里边拷几次根本不是问题，因为受以太网延迟和带宽的限制，跟这个程序通信的其他机器上的程序不会觉察到性能差异。</p>
<p>最后举一个例子，<strong>如果你实现的服务程序要跟数据库打交道，那么瓶颈常常在 DB 上</strong>，优化服务程序本身不见得能提高性能（从 DB 读一次数据往往就抵消了你做的全部 low-level 优化），这时不如把精力投入在 DB 调优上。</p>
<p>专用服务程序与通用服务程序的另外一点区别是 benchmark 的对象不同。如果你打算写一个 httpd，自然有人会拿来和目前最好的 nginx 对比，立马就能比出性能高低。然而，如果你<strong>写一个实现公司内部业务的服务程序</strong>（比如<strong>分布式存储</strong>或者<strong>搜索</strong>或者微博或者短网址），由于市面上没有同等功能的开源实现，你不需要在优化上投入全部精力，只要一版做得比一版好就行。先正确实现所需的功能，投入生产应用，然后再根据真实的负载情况来做优化，这恐怕比在编码阶段就盲目调优要更 effective 一些。</p>
<p>Muduo 的设计目标之一是吞吐量能让千兆以太网饱和，也就是每秒收发 120 兆字节的数据。这个很容易就达到，不用任何特别的努力。</p>
<p>如果确实在内存带宽方面遇到问题，说明你做的应用实在太 critical，或许应该考虑放到 Linux kernel 里边去，而不是在用户态尝试各种优化。毕竟只有把程序做到 kernel 里才能真正实现 zero copy，否则，核心态和用户态之间始终是有一次内存拷贝的。如果放到 kernel 里还不能满足需求，那么要么自己写新的 kernel，或者直接用 FPGA 或 ASIC 操作 network adapter 来实现你的高性能服务器。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/Buffer%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1/" data-id="ck7naw84o000s2cvebzf668b0" class="article-share-link">分享到</a>
      

      
        <a href="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/Buffer%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cpp/" rel="tag">Cpp</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">下一页 &amp;raquo;</a>
  </nav>
</section>
      
      <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/">开源组件</a><span class="category-list-count">23</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/">Redis</a><span class="category-list-count">11</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/">源码阅读</a><span class="category-list-count">11</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/">muduo</a><span class="category-list-count">12</span></li></ul></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Boost/" rel="tag">Boost</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CMake/" rel="tag">CMake</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cpp/" rel="tag">Cpp</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IO/" rel="tag">IO</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Net/" rel="tag">Net</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reactor/" rel="tag">Reactor</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP/" rel="tag">TCP</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a><span class="tag-list-count">4</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Boost/" style="font-size: 12.5px;">Boost</a> <a href="/tags/C/" style="font-size: 17.5px;">C</a> <a href="/tags/CMake/" style="font-size: 10px;">CMake</a> <a href="/tags/Cpp/" style="font-size: 20px;">Cpp</a> <a href="/tags/IO/" style="font-size: 12.5px;">IO</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Net/" style="font-size: 15px;">Net</a> <a href="/tags/Reactor/" style="font-size: 10px;">Reactor</a> <a href="/tags/Redis/" style="font-size: 17.5px;">Redis</a> <a href="/tags/TCP/" style="font-size: 12.5px;">TCP</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 15px;">数据结构</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a><span class="archive-list-count">23</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB11_%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8_redisServer/">Redis 源码阅读11_客户端和服务器_redisServer</a>
          </li>
        
          <li>
            <a href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB10_%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8_networking/">Redis 源码阅读10_客户端和服务器_networking</a>
          </li>
        
          <li>
            <a href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB9_%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8_ae/">Redis 源码阅读9_客户端和服务器_ae</a>
          </li>
        
          <li>
            <a href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB8_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E7%8E%B0%E7%9B%B8%E5%85%B3_rdb/">Redis 源码阅读8_数据库实现相关_rdb</a>
          </li>
        
          <li>
            <a href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB7_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E7%8E%B0%E7%9B%B8%E5%85%B3_db/">Redis 源码阅读7_数据库实现相关_db</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">友情链接</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="https://github.com/midudu" target="_blank">GitHub</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Midudu<br>
      Powered by <a href="//hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/xiangming/landscape-plus" target="_blank">Landscape-plus</a>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->

<!-- 多说公共js代码 start -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"midudu"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共js代码 end -->


<!-- 百度分享 start -->

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>




<! -- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
                processEscapes: true
                    
}
  
        });
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
                  
}
    
        });
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Queue(function() {
            var all = MathJax.Hub.getAllJax(), i;
            for(i=0; i < all.length; i += 1) {
                            all[i].SourceElement().parentNode.className += ' has-jax';
                                    
            }
                
        });
</script>

<script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



<script src="/js/script.js"></script>


</div>
</body>
</html>
