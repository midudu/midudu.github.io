<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Midudu&#39;s Home</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-05-12T01:02:19.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Midudu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java 热加载的原理和代码</title>
    <link href="http://yoursite.com/Java/ClassLoader/Java%E7%83%AD%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86%E5%92%8C%E4%BB%A3%E7%A0%81/"/>
    <id>http://yoursite.com/Java/ClassLoader/Java%E7%83%AD%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86%E5%92%8C%E4%BB%A3%E7%A0%81/</id>
    <published>2021-05-12T01:01:33.282Z</published>
    <updated>2021-05-12T01:02:19.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>热加载的原理是：<ol><li>如果一个类已经被某个类加载器 ClassLoader 加载过，那么它就无法被再次加载，也就是更新 jar 包也没用了；</li><li>所以，解决方法就是重新搞一个类加载器，让这个类加载器去加载这个类，并且保证下次使用这个类时，使用的恰好就是这个新类加载器加载的类</li></ol></li></ol><ol start="2"><li>实现类主要有 2 个</li></ol><ul><li>ComponentHolder.java：用来持有一系列的 Constructor ，然后用反射的方式创建对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComponentHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LogManager.getLogger(ComponentHolder<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Constructor&lt;CustomScorer&gt;&gt; scorerConstructorMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ComponentHolder</span><span class="params">(File jarFilePath, Map&lt;String, String&gt; scorerClassNameMap)</span> <span class="keyword">throws</span> MalformedURLException, ClassNotFoundException,</span></span><br><span class="line"><span class="function">            NoSuchMethodException </span>&#123;</span><br><span class="line">        ComponentLoader componentLoader = <span class="keyword">new</span> ComponentLoader();</span><br><span class="line">        componentLoader.addDir(jarFilePath);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String scorerName : scorerClassNameMap.keySet()) &#123;</span><br><span class="line">            String className = scorerClassNameMap.get(scorerName);</span><br><span class="line"></span><br><span class="line">            Class&lt;?&gt; functionClass = componentLoader.loadClass(className);</span><br><span class="line">            <span class="keyword">if</span> (!CustomScorer<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">functionClass</span>)) </span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"is not a subclass for CustomScorer"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Constructor&lt;CustomScorer&gt; customScorerConstructor = (Constructor&lt;CustomScorer&gt;) functionClass.getConstructor(Map<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">            logger.info(<span class="string">"load scorer &#123;&#125; successfully, customScorerConstructor is &#123;&#125;"</span>, scorerName, customScorerConstructor);</span><br><span class="line">            scorerConstructorMap.put(scorerName, customScorerConstructor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Constructor&lt;CustomScorer&gt; <span class="title">getConstructor</span><span class="params">(String scorerName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scorerConstructorMap.get(scorerName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>ComponentLoader.java：继承了 URLClassLoader，用来 load 新 jar 包中的类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComponentLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LogManager.getLogger(ComponentLoader<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;JarURLConnection&gt; cachedJarFiles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ComponentLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">new</span> URL[] &#123;&#125;, findParentClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addDir</span><span class="params">(File file)</span> <span class="keyword">throws</span> MalformedURLException </span>&#123;</span><br><span class="line">        addComponent(file.toURI().toURL());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addComponent</span><span class="params">(URL file)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            URLConnection uc = file.openConnection();</span><br><span class="line">            <span class="keyword">if</span> (uc <span class="keyword">instanceof</span> JarURLConnection) &#123;</span><br><span class="line">                uc.setUseCaches(<span class="keyword">true</span>);</span><br><span class="line">                ((JarURLConnection) uc).getManifest();</span><br><span class="line">                cachedJarFiles.add((JarURLConnection) uc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">"Failed to add JAR file! fileUrl: &#123;&#125;"</span>, file.getPath(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        addURL(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ClassLoader <span class="title">findParentClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ClassLoader parent = MEPScorerPlugin<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            parent = ComponentLoader<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            parent = ClassLoader.getSystemClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>gc 问题<ol><li>上面的这种实现方式，最终结果是有个 Map，保存着 Constructor 对象，Constructor 对象又持有 Class 对象，Class 又持有 ClassLoader，这些都在堆内存中；另外，类信息放在方法区里面</li><li>热加载了新的类以后，结果是老的 Constructor 没了，这样堆内存中的对象会被回收</li><li>但是，方法区中的类需要同时满足以下三个条件才能被标记为无用的类：<ol><li>Java堆中不存在该类的任何实例对象；</li><li>加载该类的类加载器已经被回收；</li><li>该类对应的java.lang.Class对象不在任何地方被引用，且无法在任何地方通过反射访问该类的方法。</li></ol></li></ol></li></ol><p>当满足上述三个条件的类才可以被回收，但是<strong>并不是一定会被回收，需要参数进行控制，例如HotSpot虚拟机提供了-Xnoclassgc参数进行控制是否回收</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;热加载的原理是：&lt;ol&gt;
&lt;li&gt;如果一个类已经被某个类加载器 ClassLoader 加载过，那么它就无法被再次加载，也就是更新 jar 包也没用了；&lt;/li&gt;
&lt;li&gt;所以，解决方法就是重新搞一个类加载器，让这个类加载器去加载这个类，并且保证下次使用这个类时
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
      <category term="ClassLoader" scheme="http://yoursite.com/categories/Java/ClassLoader/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="ClassLoader" scheme="http://yoursite.com/tags/ClassLoader/"/>
    
      <category term="热加载" scheme="http://yoursite.com/tags/%E7%83%AD%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>使用 Hexo + GitHub 搭建个人免费博客教程</title>
    <link href="http://yoursite.com/%E6%95%99%E7%A8%8B/Hexo/%E4%BD%BF%E7%94%A8Hexo+GitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%85%8D%E8%B4%B9%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/%E6%95%99%E7%A8%8B/Hexo/%E4%BD%BF%E7%94%A8Hexo+GitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%85%8D%E8%B4%B9%E5%8D%9A%E5%AE%A2/</id>
    <published>2021-05-11T01:13:29.489Z</published>
    <updated>2020-03-11T01:15:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考链接 </p><p><a href="https://zhuanlan.zhihu.com/p/60578464" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/60578464</a></p><p><a href="https://cloud.tencent.com/developer/article/1100307" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1100307</a></p></blockquote><ul><li><a href="#一简介">一、简介</a><ul><li><a href="#1-hexo--github-文章发布原理">1. Hexo + GitHub 文章发布原理</a></li><li><a href="#2-github-pages-是什么">2. GitHub Pages 是什么？</a></li><li><a href="#3-hexo-是什么">3. Hexo 是什么？</a></li></ul></li><li><a href="#二步骤">二、步骤</a><ul><li><a href="#1-安装-nodejs">1. 安装 Node.js</a></li><li><a href="#2-安装-hexo">2. 安装 Hexo</a></li><li><a href="#3-github-配置">3. GitHub 配置</a></li></ul></li><li><a href="#三常用命令">三、常用命令</a></li></ul><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><h3 id="1-Hexo-GitHub-文章发布原理"><a href="#1-Hexo-GitHub-文章发布原理" class="headerlink" title="1. Hexo + GitHub 文章发布原理"></a>1. Hexo + GitHub 文章发布原理</h3><p>在本地撰写 Markdown 格式文章后，通过 Hexo 解析文档，渲染生成具有主题样式的 HTML 静态网页，再推送到 GitHub 上完成博文的发布。</p><p><img src="/resources/v2-a193a47cf70fe6ecf156e5f3d34920ea_1440w.jpg" alt="gewt"></p><h3 id="2-GitHub-Pages-是什么？"><a href="#2-GitHub-Pages-是什么？" class="headerlink" title="2. GitHub Pages 是什么？"></a>2. GitHub Pages 是什么？</h3><p>GitHub Pages 是由 GitHub 官方提供的一种免费的静态站点托管服务，让我们可以在 GitHub 仓库里托管和发布自己的静态网站页面。</p><p><a href="https://help.github.com/en/github/working-with-github-pages/about-github-pages" target="_blank" rel="noopener">GitHub Pages</a></p><h3 id="3-Hexo-是什么？"><a href="#3-Hexo-是什么？" class="headerlink" title="3. Hexo 是什么？"></a>3. Hexo 是什么？</h3><p>Hexo 是一个快速、简洁且高效的静态博客框架，它基于 Node.js 运行，可以将我们撰写的 Markdown 文档解析渲染成静态的 HTML 网页。</p><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a></p><h2 id="二、步骤"><a href="#二、步骤" class="headerlink" title="二、步骤"></a>二、步骤</h2><h3 id="1-安装-Node-js"><a href="#1-安装-Node-js" class="headerlink" title="1. 安装 Node.js"></a>1. 安装 Node.js</h3><p>直接下二进制文件，一路 next</p><p><a href="http://nodejs.cn/download/" target="_blank" rel="noopener">Node.js</a></p><h3 id="2-安装-Hexo"><a href="#2-安装-Hexo" class="headerlink" title="2. 安装 Hexo"></a>2. 安装 Hexo</h3><p>建一个文件夹用于保存 hexo 文件资源，然后依次执行以下命令，使用 npm 安装 hexo</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> E:</span><br><span class="line">mkdir Hexo</span><br><span class="line"><span class="built_in">cd</span> Hexo</span><br><span class="line">npm install -g hexo-cli</span><br><span class="line">hexo init</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>这样应该就安装好了，然后生成一下，再本地运行一下 server</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g   // generate 生成，md --&gt; html</span><br><span class="line">hexo s   // server， 本地运行</span><br></pre></td></tr></table></figure><p>浏览器输入 localhost:4000 ，就能看到初始的 hello world 网页了。</p><h3 id="3-GitHub-配置"><a href="#3-GitHub-配置" class="headerlink" title="3. GitHub 配置"></a>3. GitHub 配置</h3><ol><li><p>本地的 ssh-key 绑定到 GitHub 上</p></li><li><p>新建一个 repository，名字必须是 ${user}.github.io</p></li><li><p>在 Hexo 文件夹下的 _config.yml 文件中修改配置</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repository: git@github.com:$&#123;user&#125;&#x2F;$&#123;user&#125;.github.io.git</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure></li><li><p>用 hexo 上传到远程</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d    &#x2F;&#x2F; deploy</span><br></pre></td></tr></table></figure></li><li><p>此时浏览器键入 ${user}.github.io 就看到效果了</p></li></ol><h2 id="三、常用命令"><a href="#三、常用命令" class="headerlink" title="三、常用命令"></a>三、常用命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;name&quot;       # 新建文章</span><br><span class="line">hexo new page &quot;name&quot;  # 新建页面</span><br><span class="line">hexo g                # 生成页面</span><br><span class="line">hexo d                # 部署</span><br><span class="line">hexo g -d             # 生成页面并部署</span><br><span class="line">hexo s                # 本地预览</span><br><span class="line">hexo clean            # 清除缓存和已生成的静态文件</span><br><span class="line">hexo help             # 帮助</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;参考链接 &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/60578464&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/605
      
    
    </summary>
    
    
      <category term="教程" scheme="http://yoursite.com/categories/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/%E6%95%99%E7%A8%8B/Hexo/"/>
    
    
      <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Redis 源码阅读11_客户端和服务器_redisServer</title>
    <link href="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB11_%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8_redisServer/"/>
    <id>http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB11_%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8_redisServer/</id>
    <published>2020-03-11T12:25:46.351Z</published>
    <updated>2020-03-11T12:28:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>redis 单机服务器</p><ul><li><a href="#%e6%b6%89%e5%8f%8a%e6%96%87%e4%bb%b6">涉及文件</a></li><li><a href="#redis-server">redis server</a><ul><li><a href="#1-%e8%ae%be%e7%bd%ae%e5%90%84%e7%a7%8d%e4%b8%9c%e8%a5%bf">1. 设置各种东西</a></li><li><a href="#2-%e5%88%9d%e5%a7%8b%e5%8c%96%e6%9c%8d%e5%8a%a1%e5%99%a8">2. 初始化服务器</a></li><li><a href="#3-%e5%a6%82%e6%9e%9c%e6%9c%8d%e5%8a%a1%e5%99%a8%e4%bb%a5-sentinel-%e6%a8%a1%e5%bc%8f%e5%90%af%e5%8a%a8%e9%82%a3%e4%b9%88%e8%bf%9b%e8%a1%8c-sentinel-%e5%8a%9f%e8%83%bd%e7%9b%b8%e5%85%b3%e7%9a%84%e5%88%9d%e5%a7%8b%e5%8c%96">3. 如果服务器以 Sentinel 模式启动，那么进行 Sentinel 功能相关的初始化</a></li><li><a href="#4-%e8%af%bb%e5%91%bd%e4%bb%a4%e8%a1%8c%e7%94%a8%e6%88%b7%e8%be%93%e5%85%a5%e8%bf%9b%e8%a1%8c%e9%85%8d%e7%bd%ae">4. 读命令行用户输入，进行配置</a></li><li><a href="#5-%e5%b0%86%e6%9c%8d%e5%8a%a1%e5%99%a8%e8%ae%be%e7%bd%ae%e4%b8%ba%e5%ae%88%e6%8a%a4%e8%bf%9b%e7%a8%8b">5. 将服务器设置为守护进程</a></li><li><a href="#6-%e5%88%9b%e5%bb%ba%e5%b9%b6%e5%88%9d%e5%a7%8b%e5%8c%96%e6%9c%8d%e5%8a%a1%e5%99%a8%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84">6. 创建并初始化服务器数据结构</a></li><li><a href="#7-%e5%a6%82%e6%9e%9c%e6%9c%8d%e5%8a%a1%e5%99%a8%e6%98%af%e5%ae%88%e6%8a%a4%e8%bf%9b%e7%a8%8b%e9%82%a3%e4%b9%88%e5%88%9b%e5%bb%ba-pid-%e6%96%87%e4%bb%b6">7. 如果服务器是守护进程，那么创建 PID 文件</a></li><li><a href="#8-%e4%b8%ba%e6%9c%8d%e5%8a%a1%e5%99%a8%e8%bf%9b%e7%a8%8b%e8%ae%be%e7%bd%ae%e5%90%8d%e5%ad%97">8. 为服务器进程设置名字</a></li><li><a href="#9-%e6%89%93%e5%8d%b0-ascii-logo">9. 打印 ASCII LOGO</a></li><li><a href="#10-%e8%bd%bd%e5%85%a5-rdb-%e5%92%8c-aof-%e6%96%87%e4%bb%b6">10. 载入 rdb 和 aof 文件</a></li><li><a href="#11-%e8%ae%be%e7%bd%ae-before-sleep-%e6%96%b9%e6%b3%95">11. 设置 before sleep 方法</a></li><li><a href="#12-%e5%bc%80%e5%a7%8b%e4%b8%bb-loop">12. 开始主 loop</a></li><li><a href="#13-%e7%bb%93%e6%9d%9f%e6%b8%85%e7%90%86-loop">13. 结束，清理 loop</a></li></ul></li><li><a href="#%e5%85%b3%e4%ba%8e%e5%87%a0%e4%b8%aa%e6%96%87%e4%bb%b6%e4%ba%8b%e4%bb%b6%e5%a4%84%e7%90%86%e5%99%a8%e7%9a%84%e9%80%bb%e8%be%91%e5%85%b3%e7%b3%bb">关于几个文件事件处理器的逻辑关系</a></li><li><a href="#redis-%e4%b8%8d%e8%83%bd%e7%ae%80%e5%8d%95%e8%af%b4%e6%98%af%e4%b8%80%e4%b8%aa%e5%8d%95%e8%bf%9b%e7%a8%8b%e5%8d%95%e7%ba%bf%e7%a8%8b-reactor">redis 不能简单说是一个单进程单线程 reactor</a></li></ul><h2 id="涉及文件"><a href="#涉及文件" class="headerlink" title="涉及文件"></a>涉及文件</h2><p><code>redis.c</code></p><h2 id="redis-server"><a href="#redis-server" class="headerlink" title="redis server"></a>redis server</h2><p>main 函数在 redis.c 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We need to initialize our libraries, and the server configuration. */</span></span><br><span class="line">    <span class="comment">// 初始化库</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> INIT_SETPROCTITLE_REPLACEMENT</span></span><br><span class="line">    spt_init(argc, argv);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    setlocale(LC_COLLATE, <span class="string">""</span>);</span><br><span class="line">    zmalloc_enable_thread_safeness();</span><br><span class="line">    zmalloc_set_oom_handler(redisOutOfMemoryHandler);</span><br><span class="line">    srand(time(<span class="literal">NULL</span>) ^ getpid());</span><br><span class="line">    gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">    dictSetHashFunctionSeed(tv.tv_sec ^ tv.tv_usec ^ getpid());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查服务器是否以 Sentinel 模式启动</span></span><br><span class="line">    server.sentinel_mode = checkForSentinelMode(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化服务器</span></span><br><span class="line">    initServerConfig();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We need to init sentinel right now as parsing the configuration file</span></span><br><span class="line"><span class="comment">     * in sentinel mode will have the effect of populating the sentinel</span></span><br><span class="line"><span class="comment">     * data structures with master nodes to monitor. */</span></span><br><span class="line">    <span class="comment">// 如果服务器以 Sentinel 模式启动，那么进行 Sentinel 功能相关的初始化</span></span><br><span class="line">    <span class="comment">// 并为要监视的主服务器创建一些相应的数据结构</span></span><br><span class="line">    <span class="keyword">if</span> (server.sentinel_mode) &#123;</span><br><span class="line">        initSentinelConfig();</span><br><span class="line">        initSentinel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查用户是否指定了配置文件，或者配置选项</span></span><br><span class="line">    <span class="keyword">if</span> (argc &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">1</span>; <span class="comment">/* First option to parse in argv[] */</span></span><br><span class="line">        sds options = sdsempty();</span><br><span class="line">        <span class="keyword">char</span> *configfile = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Handle special options --help and --version */</span></span><br><span class="line">        <span class="comment">// 处理特殊选项 -h 、-v 和 --test-memory</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"-v"</span>) == <span class="number">0</span> ||</span><br><span class="line">            <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"--version"</span>) == <span class="number">0</span>)</span><br><span class="line">            version();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"--help"</span>) == <span class="number">0</span> ||</span><br><span class="line">            <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"-h"</span>) == <span class="number">0</span>)</span><br><span class="line">            usage();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"--test-memory"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (argc == <span class="number">3</span>) &#123;</span><br><span class="line">                memtest(atoi(argv[<span class="number">2</span>]), <span class="number">50</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Please specify the amount of memory to test in megabytes.\n"</span>);</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Example: ./redis-server --test-memory 4096\n\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* First argument is the config file name? */</span></span><br><span class="line">        <span class="comment">// 如果第一个参数（argv[1]）不是以 "--" 开头</span></span><br><span class="line">        <span class="comment">// 那么它应该是一个配置文件</span></span><br><span class="line">        <span class="keyword">if</span> (argv[j][<span class="number">0</span>] != <span class="string">'-'</span> || argv[j][<span class="number">1</span>] != <span class="string">'-'</span>)</span><br><span class="line">            configfile = argv[j++];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* All the other options are parsed and conceptually appended to the</span></span><br><span class="line"><span class="comment">         * configuration file. For instance --port 6380 will generate the</span></span><br><span class="line"><span class="comment">         * string "port 6380\n" to be parsed after the actual file name</span></span><br><span class="line"><span class="comment">         * is parsed, if any. */</span></span><br><span class="line">        <span class="comment">// 对用户给定的其余选项进行分析，并将分析所得的字符串追加稍后载入的配置文件的内容之后</span></span><br><span class="line">        <span class="comment">// 比如 --port 6380 会被分析为 "port 6380\n"</span></span><br><span class="line">        <span class="keyword">while</span> (j != argc) &#123;</span><br><span class="line">            <span class="keyword">if</span> (argv[j][<span class="number">0</span>] == <span class="string">'-'</span> &amp;&amp; argv[j][<span class="number">1</span>] == <span class="string">'-'</span>) &#123;</span><br><span class="line">                <span class="comment">/* Option name */</span></span><br><span class="line">                <span class="keyword">if</span> (sdslen(options)) options = sdscat(options, <span class="string">"\n"</span>);</span><br><span class="line">                options = sdscat(options, argv[j] + <span class="number">2</span>);</span><br><span class="line">                options = sdscat(options, <span class="string">" "</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* Option argument */</span></span><br><span class="line">                options = sdscatrepr(options, argv[j], <span class="built_in">strlen</span>(argv[j]));</span><br><span class="line">                options = sdscat(options, <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (configfile) server.configfile = getAbsolutePath(configfile);</span><br><span class="line">        <span class="comment">// 重置保存条件</span></span><br><span class="line">        resetServerSaveParams();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 载入配置文件， options 是前面分析出的给定选项</span></span><br><span class="line">        loadServerConfig(configfile, options);</span><br><span class="line">        sdsfree(options);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取配置文件的绝对路径</span></span><br><span class="line">        <span class="keyword">if</span> (configfile) server.configfile = getAbsolutePath(configfile);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisLog(REDIS_WARNING,</span><br><span class="line">                 <span class="string">"Warning: no config file specified, using the default config. In order to specify a config file use %s /path/to/%s.conf"</span>,</span><br><span class="line">                 argv[<span class="number">0</span>], server.sentinel_mode ? <span class="string">"sentinel"</span> : <span class="string">"redis"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将服务器设置为守护进程</span></span><br><span class="line">    <span class="keyword">if</span> (server.daemonize) daemonize();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并初始化服务器数据结构</span></span><br><span class="line">    initServer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果服务器是守护进程，那么创建 PID 文件</span></span><br><span class="line">    <span class="keyword">if</span> (server.daemonize) createPidFile();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为服务器进程设置名字</span></span><br><span class="line">    redisSetProcTitle(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印 ASCII LOGO</span></span><br><span class="line">    redisAsciiArt();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果服务器不是运行在 SENTINEL 模式，那么执行以下代码</span></span><br><span class="line">    <span class="keyword">if</span> (!server.sentinel_mode) &#123;</span><br><span class="line">        <span class="comment">/* Things not needed when running in Sentinel mode. */</span></span><br><span class="line">        <span class="comment">// 打印问候语</span></span><br><span class="line">        redisLog(REDIS_WARNING, <span class="string">"Server started, Redis version "</span> REDIS_VERSION);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __linux__</span></span><br><span class="line">        <span class="comment">// 打印内存警告</span></span><br><span class="line">        linuxOvercommitMemoryWarning();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">// 从 AOF 文件或者 RDB 文件中载入数据</span></span><br><span class="line">        loadDataFromDisk();</span><br><span class="line">        <span class="comment">// 启动集群？</span></span><br><span class="line">        <span class="keyword">if</span> (server.cluster_enabled) &#123;</span><br><span class="line">            <span class="keyword">if</span> (verifyClusterConfigWithData() == REDIS_ERR) &#123;</span><br><span class="line">                redisLog(REDIS_WARNING,</span><br><span class="line">                         <span class="string">"You can't have keys in a DB different than DB 0 when in "</span></span><br><span class="line">                         <span class="string">"Cluster mode. Exiting."</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印 TCP 端口</span></span><br><span class="line">        <span class="keyword">if</span> (server.ipfd_count &gt; <span class="number">0</span>)</span><br><span class="line">            redisLog(REDIS_NOTICE, <span class="string">"The server is now ready to accept connections on port %d"</span>, server.port);</span><br><span class="line">        <span class="comment">// 打印本地套接字端口</span></span><br><span class="line">        <span class="keyword">if</span> (server.sofd &gt; <span class="number">0</span>)</span><br><span class="line">            redisLog(REDIS_NOTICE, <span class="string">"The server is now ready to accept connections at %s"</span>, server.unixsocket);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sentinelIsRunning();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Warning the user about suspicious maxmemory setting. */</span></span><br><span class="line">    <span class="comment">// 检查不正常的 maxmemory 配置</span></span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory &gt; <span class="number">0</span> &amp;&amp; server.maxmemory &lt; <span class="number">1024</span> * <span class="number">1024</span>) &#123;</span><br><span class="line">        redisLog(REDIS_WARNING,</span><br><span class="line">                 <span class="string">"WARNING: You specified a maxmemory value that is less than 1MB (current value is %llu bytes). Are you sure this is what you really want?"</span>,</span><br><span class="line">                 server.maxmemory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行事件处理器，一直到服务器关闭为止</span></span><br><span class="line">    aeSetBeforeSleepProc(server.el, beforeSleep);</span><br><span class="line">    aeMain(server.el);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务器关闭，停止事件循环</span></span><br><span class="line">    aeDeleteEventLoop(server.el);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-设置各种东西"><a href="#1-设置各种东西" class="headerlink" title="1. 设置各种东西"></a>1. 设置各种东西</h3><pre><code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setlocale(LC_COLLATE, <span class="string">""</span>);  <span class="comment">// locale</span></span><br><span class="line">zmalloc_enable_thread_safeness();  <span class="comment">// zmalloc thread safe</span></span><br><span class="line">zmalloc_set_oom_handler(redisOutOfMemoryHandler);  <span class="comment">// 这个 handler 只是 log，基本啥也不干</span></span><br><span class="line">srand(time(<span class="literal">NULL</span>) ^ getpid());  <span class="comment">// 生成时间随机数种子，用于 hash 的种子</span></span><br><span class="line">gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">dictSetHashFunctionSeed(tv.tv_sec ^ tv.tv_usec ^ getpid());</span><br></pre></td></tr></table></figure></code></pre><h3 id="2-初始化服务器"><a href="#2-初始化服务器" class="headerlink" title="2. 初始化服务器"></a>2. 初始化服务器</h3><pre><code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">initServerConfig();</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>initServerConfig 实在太长，还是直接看源码吧。但是初始化 command 的部分有点意思，看一下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server.commands = dictCreate(&amp;commandTableDictType, <span class="literal">NULL</span>);</span><br><span class="line">server.orig_commands = dictCreate(&amp;commandTableDictType, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">populateCommandTable();</span><br><span class="line"></span><br><span class="line">server.delCommand = lookupCommandByCString(<span class="string">"del"</span>);</span><br><span class="line">server.multiCommand = lookupCommandByCString(<span class="string">"multi"</span>);</span><br><span class="line">server.lpushCommand = lookupCommandByCString(<span class="string">"lpush"</span>);</span><br><span class="line">server.lpopCommand = lookupCommandByCString(<span class="string">"lpop"</span>);</span><br><span class="line">server.rpopCommand = lookupCommandByCString(<span class="string">"rpop"</span>);</span><br></pre></td></tr></table></figure>这里又分为 3 个部分：- 首先创建两个字典 server.commands 和 server.orig_commands ，之所以要有两个的原因是，客户端可以通过 rename 操作把一些命令改个名字，所以要用 orig_commands 备份一份- 然后初始化命令列表 populateCommandTable()    <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> <span class="title">redisCommandTable</span>[] = &#123;</span></span><br><span class="line">&#123;<span class="string">"get"</span>,              getCommand,              <span class="number">2</span>,  <span class="string">"r"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"set"</span>,              setCommand,              <span class="number">-3</span>, <span class="string">"wm"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"setnx"</span>,            setnxCommand,            <span class="number">3</span>,  <span class="string">"wm"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"setex"</span>,            setexCommand,            <span class="number">4</span>,  <span class="string">"wm"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"psetex"</span>,           psetexCommand,           <span class="number">4</span>,  <span class="string">"wm"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"append"</span>,           appendCommand,           <span class="number">3</span>,  <span class="string">"wm"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"strlen"</span>,           strlenCommand,           <span class="number">2</span>,  <span class="string">"r"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"del"</span>,              delCommand,              <span class="number">-2</span>, <span class="string">"w"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"exists"</span>,           existsCommand,           <span class="number">2</span>,  <span class="string">"r"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"setbit"</span>,           setbitCommand,           <span class="number">4</span>,  <span class="string">"wm"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"getbit"</span>,           getbitCommand,           <span class="number">3</span>,  <span class="string">"r"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"setrange"</span>,         setrangeCommand,         <span class="number">4</span>,  <span class="string">"wm"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"getrange"</span>,         getrangeCommand,         <span class="number">4</span>,  <span class="string">"r"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"substr"</span>,           getrangeCommand,         <span class="number">4</span>,  <span class="string">"r"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"incr"</span>,             incrCommand,             <span class="number">2</span>,  <span class="string">"wm"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"decr"</span>,             decrCommand,             <span class="number">2</span>,  <span class="string">"wm"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"mget"</span>,             mgetCommand,             <span class="number">-2</span>, <span class="string">"r"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"rpush"</span>,            rpushCommand,            <span class="number">-3</span>, <span class="string">"wm"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"lpush"</span>,            lpushCommand,            <span class="number">-3</span>, <span class="string">"wm"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"rpushx"</span>,           rpushxCommand,           <span class="number">3</span>,  <span class="string">"wm"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"lpushx"</span>,           lpushxCommand,           <span class="number">3</span>,  <span class="string">"wm"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"linsert"</span>,          linsertCommand,          <span class="number">5</span>,  <span class="string">"wm"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"rpop"</span>,             rpopCommand,             <span class="number">2</span>,  <span class="string">"w"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"lpop"</span>,             lpopCommand,             <span class="number">2</span>,  <span class="string">"w"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"brpop"</span>,            brpopCommand,            <span class="number">-3</span>, <span class="string">"ws"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"brpoplpush"</span>,       brpoplpushCommand,       <span class="number">4</span>,  <span class="string">"wms"</span>,   <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">2</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"blpop"</span>,            blpopCommand,            <span class="number">-3</span>, <span class="string">"ws"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">-2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"llen"</span>,             llenCommand,             <span class="number">2</span>,  <span class="string">"r"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"lindex"</span>,           lindexCommand,           <span class="number">3</span>,  <span class="string">"r"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"lset"</span>,             lsetCommand,             <span class="number">4</span>,  <span class="string">"wm"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"lrange"</span>,           lrangeCommand,           <span class="number">4</span>,  <span class="string">"r"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"ltrim"</span>,            ltrimCommand,            <span class="number">4</span>,  <span class="string">"w"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"lrem"</span>,             lremCommand,             <span class="number">4</span>,  <span class="string">"w"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"rpoplpush"</span>,        rpoplpushCommand,        <span class="number">3</span>,  <span class="string">"wm"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">2</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"sadd"</span>,             saddCommand,             <span class="number">-3</span>, <span class="string">"wm"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"srem"</span>,             sremCommand,             <span class="number">-3</span>, <span class="string">"w"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"smove"</span>,            smoveCommand,            <span class="number">4</span>,  <span class="string">"w"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">2</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"sismember"</span>,        sismemberCommand,        <span class="number">3</span>,  <span class="string">"r"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"scard"</span>,            scardCommand,            <span class="number">2</span>,  <span class="string">"r"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"spop"</span>,             spopCommand,             <span class="number">2</span>,  <span class="string">"wRs"</span>,   <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"srandmember"</span>,      srandmemberCommand,      <span class="number">-2</span>, <span class="string">"rR"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"sinter"</span>,           sinterCommand,           <span class="number">-2</span>, <span class="string">"rS"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"sinterstore"</span>,      sinterstoreCommand,      <span class="number">-3</span>, <span class="string">"wm"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"sunion"</span>,           sunionCommand,           <span class="number">-2</span>, <span class="string">"rS"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"sunionstore"</span>,      sunionstoreCommand,      <span class="number">-3</span>, <span class="string">"wm"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"sdiff"</span>,            sdiffCommand,            <span class="number">-2</span>, <span class="string">"rS"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"sdiffstore"</span>,       sdiffstoreCommand,       <span class="number">-3</span>, <span class="string">"wm"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"smembers"</span>,         sinterCommand,           <span class="number">2</span>,  <span class="string">"rS"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"sscan"</span>,            sscanCommand,            <span class="number">-3</span>, <span class="string">"rR"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"zadd"</span>,             zaddCommand,             <span class="number">-4</span>, <span class="string">"wm"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"zincrby"</span>,          zincrbyCommand,          <span class="number">4</span>,  <span class="string">"wm"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"zrem"</span>,             zremCommand,             <span class="number">-3</span>, <span class="string">"w"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"zremrangebyscore"</span>, zremrangebyscoreCommand, <span class="number">4</span>,  <span class="string">"w"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"zremrangebyrank"</span>,  zremrangebyrankCommand,  <span class="number">4</span>,  <span class="string">"w"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"zremrangebylex"</span>,   zremrangebylexCommand,   <span class="number">4</span>,  <span class="string">"w"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"zunionstore"</span>,      zunionstoreCommand,      <span class="number">-4</span>, <span class="string">"wm"</span>,    <span class="number">0</span>, zunionInterGetKeys, <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"zinterstore"</span>,      zinterstoreCommand,      <span class="number">-4</span>, <span class="string">"wm"</span>,    <span class="number">0</span>, zunionInterGetKeys, <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"zrange"</span>,           zrangeCommand,           <span class="number">-4</span>, <span class="string">"r"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"zrangebyscore"</span>,    zrangebyscoreCommand,    <span class="number">-4</span>, <span class="string">"r"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"zrevrangebyscore"</span>, zrevrangebyscoreCommand, <span class="number">-4</span>, <span class="string">"r"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"zrangebylex"</span>,      zrangebylexCommand,      <span class="number">-4</span>, <span class="string">"r"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"zrevrangebylex"</span>,   zrevrangebylexCommand,   <span class="number">-4</span>, <span class="string">"r"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"zcount"</span>,           zcountCommand,           <span class="number">4</span>,  <span class="string">"r"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"zlexcount"</span>,        zlexcountCommand,        <span class="number">4</span>,  <span class="string">"r"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"zrevrange"</span>,        zrevrangeCommand,        <span class="number">-4</span>, <span class="string">"r"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"zcard"</span>,            zcardCommand,            <span class="number">2</span>,  <span class="string">"r"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"zscore"</span>,           zscoreCommand,           <span class="number">3</span>,  <span class="string">"r"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"zrank"</span>,            zrankCommand,            <span class="number">3</span>,  <span class="string">"r"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"zrevrank"</span>,         zrevrankCommand,         <span class="number">3</span>,  <span class="string">"r"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"zscan"</span>,            zscanCommand,            <span class="number">-3</span>, <span class="string">"rR"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"hset"</span>,             hsetCommand,             <span class="number">4</span>,  <span class="string">"wm"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"hsetnx"</span>,           hsetnxCommand,           <span class="number">4</span>,  <span class="string">"wm"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"hget"</span>,             hgetCommand,             <span class="number">3</span>,  <span class="string">"r"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"hmset"</span>,            hmsetCommand,            <span class="number">-4</span>, <span class="string">"wm"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"hmget"</span>,            hmgetCommand,            <span class="number">-3</span>, <span class="string">"r"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"hincrby"</span>,          hincrbyCommand,          <span class="number">4</span>,  <span class="string">"wm"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"hincrbyfloat"</span>,     hincrbyfloatCommand,     <span class="number">4</span>,  <span class="string">"wm"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"hdel"</span>,             hdelCommand,             <span class="number">-3</span>, <span class="string">"w"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"hlen"</span>,             hlenCommand,             <span class="number">2</span>,  <span class="string">"r"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"hkeys"</span>,            hkeysCommand,            <span class="number">2</span>,  <span class="string">"rS"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"hvals"</span>,            hvalsCommand,            <span class="number">2</span>,  <span class="string">"rS"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"hgetall"</span>,          hgetallCommand,          <span class="number">2</span>,  <span class="string">"r"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"hexists"</span>,          hexistsCommand,          <span class="number">3</span>,  <span class="string">"r"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"hscan"</span>,            hscanCommand,            <span class="number">-3</span>, <span class="string">"rR"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"incrby"</span>,           incrbyCommand,           <span class="number">3</span>,  <span class="string">"wm"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"decrby"</span>,           decrbyCommand,           <span class="number">3</span>,  <span class="string">"wm"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"incrbyfloat"</span>,      incrbyfloatCommand,      <span class="number">3</span>,  <span class="string">"wm"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"getset"</span>,           getsetCommand,           <span class="number">3</span>,  <span class="string">"wm"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"mset"</span>,             msetCommand,             <span class="number">-3</span>, <span class="string">"wm"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"msetnx"</span>,           msetnxCommand,           <span class="number">-3</span>, <span class="string">"wm"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"randomkey"</span>,        randomkeyCommand,        <span class="number">1</span>,  <span class="string">"rR"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"select"</span>,           selectCommand,           <span class="number">2</span>,  <span class="string">"rl"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"move"</span>,             moveCommand,             <span class="number">3</span>,  <span class="string">"w"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"rename"</span>,           renameCommand,           <span class="number">3</span>,  <span class="string">"w"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">2</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"renamenx"</span>,         renamenxCommand,         <span class="number">3</span>,  <span class="string">"w"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">2</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"expire"</span>,           expireCommand,           <span class="number">3</span>,  <span class="string">"w"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"expireat"</span>,         expireatCommand,         <span class="number">3</span>,  <span class="string">"w"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"pexpire"</span>,          pexpireCommand,          <span class="number">3</span>,  <span class="string">"w"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"pexpireat"</span>,        pexpireatCommand,        <span class="number">3</span>,  <span class="string">"w"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"keys"</span>,             keysCommand,             <span class="number">2</span>,  <span class="string">"rS"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"scan"</span>,             scanCommand,             <span class="number">-2</span>, <span class="string">"rR"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"dbsize"</span>,           dbsizeCommand,           <span class="number">1</span>,  <span class="string">"r"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"auth"</span>,             authCommand,             <span class="number">2</span>,  <span class="string">"rslt"</span>,  <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"ping"</span>,             pingCommand,             <span class="number">1</span>,  <span class="string">"rt"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"echo"</span>,             echoCommand,             <span class="number">2</span>,  <span class="string">"r"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"save"</span>,             saveCommand,             <span class="number">1</span>,  <span class="string">"ars"</span>,   <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"bgsave"</span>,           bgsaveCommand,           <span class="number">1</span>,  <span class="string">"ar"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"bgrewriteaof"</span>,     bgrewriteaofCommand,     <span class="number">1</span>,  <span class="string">"ar"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"shutdown"</span>,         shutdownCommand,         <span class="number">-1</span>, <span class="string">"arlt"</span>,  <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"lastsave"</span>,         lastsaveCommand,         <span class="number">1</span>,  <span class="string">"rR"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"type"</span>,             typeCommand,             <span class="number">2</span>,  <span class="string">"r"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"multi"</span>,            multiCommand,            <span class="number">1</span>,  <span class="string">"rs"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"exec"</span>,             execCommand,             <span class="number">1</span>,  <span class="string">"sM"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"discard"</span>,          discardCommand,          <span class="number">1</span>,  <span class="string">"rs"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"sync"</span>,             syncCommand,             <span class="number">1</span>,  <span class="string">"ars"</span>,   <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"psync"</span>,            syncCommand,             <span class="number">3</span>,  <span class="string">"ars"</span>,   <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"replconf"</span>,         replconfCommand,         <span class="number">-1</span>, <span class="string">"arslt"</span>, <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"flushdb"</span>,          flushdbCommand,          <span class="number">1</span>,  <span class="string">"w"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"flushall"</span>,         flushallCommand,         <span class="number">1</span>,  <span class="string">"w"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"sort"</span>,             sortCommand,             <span class="number">-2</span>, <span class="string">"wm"</span>,    <span class="number">0</span>, sortGetKeys,        <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"info"</span>,             infoCommand,             <span class="number">-1</span>, <span class="string">"rlt"</span>,   <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"monitor"</span>,          monitorCommand,          <span class="number">1</span>,  <span class="string">"ars"</span>,   <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"ttl"</span>,              ttlCommand,              <span class="number">2</span>,  <span class="string">"r"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"pttl"</span>,             pttlCommand,             <span class="number">2</span>,  <span class="string">"r"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"persist"</span>,          persistCommand,          <span class="number">2</span>,  <span class="string">"w"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"slaveof"</span>,          slaveofCommand,          <span class="number">3</span>,  <span class="string">"ast"</span>,   <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"debug"</span>,            debugCommand,            <span class="number">-2</span>, <span class="string">"as"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"config"</span>,           configCommand,           <span class="number">-2</span>, <span class="string">"art"</span>,   <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"subscribe"</span>,        subscribeCommand,        <span class="number">-2</span>, <span class="string">"rpslt"</span>, <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"unsubscribe"</span>,      unsubscribeCommand,      <span class="number">-1</span>, <span class="string">"rpslt"</span>, <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"psubscribe"</span>,       psubscribeCommand,       <span class="number">-2</span>, <span class="string">"rpslt"</span>, <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"punsubscribe"</span>,     punsubscribeCommand,     <span class="number">-1</span>, <span class="string">"rpslt"</span>, <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"publish"</span>,          publishCommand,          <span class="number">3</span>,  <span class="string">"pltr"</span>,  <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"pubsub"</span>,           pubsubCommand,           <span class="number">-2</span>, <span class="string">"pltrR"</span>, <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"watch"</span>,            watchCommand,            <span class="number">-2</span>, <span class="string">"rs"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"unwatch"</span>,          unwatchCommand,          <span class="number">1</span>,  <span class="string">"rs"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"cluster"</span>,          clusterCommand,          <span class="number">-2</span>, <span class="string">"ar"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"restore"</span>,          restoreCommand,          <span class="number">-4</span>, <span class="string">"awm"</span>,   <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"restore-asking"</span>,   restoreCommand,          <span class="number">-4</span>, <span class="string">"awmk"</span>,  <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"migrate"</span>,          migrateCommand,          <span class="number">-6</span>, <span class="string">"aw"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"asking"</span>,           askingCommand,           <span class="number">1</span>,  <span class="string">"r"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"readonly"</span>,         readonlyCommand,         <span class="number">1</span>,  <span class="string">"r"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"readwrite"</span>,        readwriteCommand,        <span class="number">1</span>,  <span class="string">"r"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"dump"</span>,             dumpCommand,             <span class="number">2</span>,  <span class="string">"ar"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"object"</span>,           objectCommand,           <span class="number">-2</span>, <span class="string">"r"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">2</span>, <span class="number">2</span>,  <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"client"</span>,           clientCommand,           <span class="number">-2</span>, <span class="string">"ar"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"eval"</span>,             evalCommand,             <span class="number">-3</span>, <span class="string">"s"</span>,     <span class="number">0</span>, evalGetKeys,        <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"evalsha"</span>,          evalShaCommand,          <span class="number">-3</span>, <span class="string">"s"</span>,     <span class="number">0</span>, evalGetKeys,        <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"slowlog"</span>,          slowlogCommand,          <span class="number">-2</span>, <span class="string">"r"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"script"</span>,           scriptCommand,           <span class="number">-2</span>, <span class="string">"ras"</span>,   <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"time"</span>,             timeCommand,             <span class="number">1</span>,  <span class="string">"rR"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"bitop"</span>,            bitopCommand,            <span class="number">-4</span>, <span class="string">"wm"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"bitcount"</span>,         bitcountCommand,         <span class="number">-2</span>, <span class="string">"r"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"bitpos"</span>,           bitposCommand,           <span class="number">-3</span>, <span class="string">"r"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"wait"</span>,             waitCommand,             <span class="number">3</span>,  <span class="string">"rs"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"pfselftest"</span>,       pfselftestCommand,       <span class="number">1</span>,  <span class="string">"r"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"pfadd"</span>,            pfaddCommand,            <span class="number">-2</span>, <span class="string">"wm"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"pfcount"</span>,          pfcountCommand,          <span class="number">-2</span>, <span class="string">"w"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"pfmerge"</span>,          pfmergeCommand,          <span class="number">-2</span>, <span class="string">"wm"</span>,    <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">"pfdebug"</span>,          pfdebugCommand,          <span class="number">-3</span>, <span class="string">"w"</span>,     <span class="number">0</span>, <span class="literal">NULL</span>,               <span class="number">0</span>, <span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">populateCommandTable</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 命令的数量</span></span><br><span class="line">    <span class="keyword">int</span> numcommands = <span class="keyword">sizeof</span>(redisCommandTable) / <span class="keyword">sizeof</span>(struct redisCommand);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numcommands; j++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定命令</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">c</span> = <span class="title">redisCommandTable</span> + <span class="title">j</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出字符串 FLAG</span></span><br><span class="line">        <span class="keyword">char</span> *f = c-&gt;sflags;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> retval1, retval2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据字符串 FLAG 生成实际 FLAG</span></span><br><span class="line">        <span class="keyword">while</span> (*f != <span class="string">'\0'</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (*f) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'w'</span>:</span><br><span class="line">                    c-&gt;flags |= REDIS_CMD_WRITE;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'r'</span>:</span><br><span class="line">                    c-&gt;flags |= REDIS_CMD_READONLY;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'m'</span>:</span><br><span class="line">                    c-&gt;flags |= REDIS_CMD_DENYOOM;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">                    c-&gt;flags |= REDIS_CMD_ADMIN;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'p'</span>:</span><br><span class="line">                    c-&gt;flags |= REDIS_CMD_PUBSUB;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">                    c-&gt;flags |= REDIS_CMD_NOSCRIPT;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'R'</span>:</span><br><span class="line">                    c-&gt;flags |= REDIS_CMD_RANDOM;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'S'</span>:</span><br><span class="line">                    c-&gt;flags |= REDIS_CMD_SORT_FOR_SCRIPT;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'l'</span>:</span><br><span class="line">                    c-&gt;flags |= REDIS_CMD_LOADING;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'t'</span>:</span><br><span class="line">                    c-&gt;flags |= REDIS_CMD_STALE;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'M'</span>:</span><br><span class="line">                    c-&gt;flags |= REDIS_CMD_SKIP_MONITOR;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'k'</span>:</span><br><span class="line">                    c-&gt;flags |= REDIS_CMD_ASKING;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    redisPanic(<span class="string">"Unsupported command flag"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            f++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将命令关联到命令表</span></span><br><span class="line">        retval1 = dictAdd(server.commands, sdsnew(c-&gt;name), c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将命令也关联到原始命令表, 原始命令表不会受 redis.conf 中命令改名的影响</span></span><br><span class="line">        retval2 = dictAdd(server.orig_commands, sdsnew(c-&gt;name), c);</span><br><span class="line"></span><br><span class="line">        redisAssert(retval1 == DICT_OK &amp;&amp; retval2 == DICT_OK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>    前面那个常常的数组就是 redis 的所有命令，populateCommandTable 函数的作用是把这些命令放到 table 里面- 最后把几个命令从 table 里查好记录一下，因为接下来 load config 的时候可能会用到    <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.delCommand = lookupCommandByCString(<span class="string">"del"</span>);</span><br><span class="line">server.multiCommand = lookupCommandByCString(<span class="string">"multi"</span>);</span><br><span class="line">server.lpushCommand = lookupCommandByCString(<span class="string">"lpush"</span>);</span><br><span class="line">server.lpopCommand = lookupCommandByCString(<span class="string">"lpop"</span>);</span><br><span class="line">server.rpopCommand = lookupCommandByCString(<span class="string">"rpop"</span>);</span><br></pre></td></tr></table></figure></code></pre><h3 id="3-如果服务器以-Sentinel-模式启动，那么进行-Sentinel-功能相关的初始化"><a href="#3-如果服务器以-Sentinel-模式启动，那么进行-Sentinel-功能相关的初始化" class="headerlink" title="3. 如果服务器以 Sentinel 模式启动，那么进行 Sentinel 功能相关的初始化"></a>3. 如果服务器以 Sentinel 模式启动，那么进行 Sentinel 功能相关的初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.sentinel_mode) &#123;</span><br><span class="line">    initSentinelConfig();</span><br><span class="line">    initSentinel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-读命令行用户输入，进行配置"><a href="#4-读命令行用户输入，进行配置" class="headerlink" title="4. 读命令行用户输入，进行配置"></a>4. 读命令行用户输入，进行配置</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (argc &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>; <span class="comment">/* First option to parse in argv[] */</span></span><br><span class="line">    sds options = sdsempty();</span><br><span class="line">    <span class="keyword">char</span> *configfile = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Handle special options --help and --version */</span></span><br><span class="line">    <span class="comment">// 处理特殊选项 -h 、-v 和 --test-memory</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"-v"</span>) == <span class="number">0</span> ||</span><br><span class="line">        <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"--version"</span>) == <span class="number">0</span>)</span><br><span class="line">        version();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"--help"</span>) == <span class="number">0</span> ||</span><br><span class="line">        <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"-h"</span>) == <span class="number">0</span>)</span><br><span class="line">        usage();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"--test-memory"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (argc == <span class="number">3</span>) &#123;</span><br><span class="line">            memtest(atoi(argv[<span class="number">2</span>]), <span class="number">50</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Please specify the amount of memory to test in megabytes.\n"</span>);</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Example: ./redis-server --test-memory 4096\n\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* First argument is the config file name? */</span></span><br><span class="line">    <span class="comment">// 如果第一个参数（argv[1]）不是以 "--" 开头</span></span><br><span class="line">    <span class="comment">// 那么它应该是一个配置文件</span></span><br><span class="line">    <span class="keyword">if</span> (argv[j][<span class="number">0</span>] != <span class="string">'-'</span> || argv[j][<span class="number">1</span>] != <span class="string">'-'</span>)</span><br><span class="line">        configfile = argv[j++];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* All the other options are parsed and conceptually appended to the</span></span><br><span class="line"><span class="comment">     * configuration file. For instance --port 6380 will generate the</span></span><br><span class="line"><span class="comment">     * string "port 6380\n" to be parsed after the actual file name</span></span><br><span class="line"><span class="comment">     * is parsed, if any. */</span></span><br><span class="line">    <span class="comment">// 对用户给定的其余选项进行分析，并将分析所得的字符串追加稍后载入的配置文件的内容之后</span></span><br><span class="line">    <span class="comment">// 比如 --port 6380 会被分析为 "port 6380\n"</span></span><br><span class="line">    <span class="keyword">while</span> (j != argc) &#123;</span><br><span class="line">        <span class="keyword">if</span> (argv[j][<span class="number">0</span>] == <span class="string">'-'</span> &amp;&amp; argv[j][<span class="number">1</span>] == <span class="string">'-'</span>) &#123;</span><br><span class="line">            <span class="comment">/* Option name */</span></span><br><span class="line">            <span class="keyword">if</span> (sdslen(options)) options = sdscat(options, <span class="string">"\n"</span>);</span><br><span class="line">            options = sdscat(options, argv[j] + <span class="number">2</span>);</span><br><span class="line">            options = sdscat(options, <span class="string">" "</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Option argument */</span></span><br><span class="line">            options = sdscatrepr(options, argv[j], <span class="built_in">strlen</span>(argv[j]));</span><br><span class="line">            options = sdscat(options, <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (configfile) server.configfile = getAbsolutePath(configfile);</span><br><span class="line">    <span class="comment">// 重置保存条件</span></span><br><span class="line">    resetServerSaveParams();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 载入配置文件， options 是前面分析出的给定选项</span></span><br><span class="line">    loadServerConfig(configfile, options);</span><br><span class="line">    sdsfree(options);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取配置文件的绝对路径</span></span><br><span class="line">    <span class="keyword">if</span> (configfile) server.configfile = getAbsolutePath(configfile);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    redisLog(REDIS_WARNING,</span><br><span class="line">             <span class="string">"Warning: no config file specified, using the default config. In order to specify a config file use %s /path/to/%s.conf"</span>,</span><br><span class="line">             argv[<span class="number">0</span>], server.sentinel_mode ? <span class="string">"sentinel"</span> : <span class="string">"redis"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没指定 argv 参数，那么就 redisLog 一下就完了，重点看有参数的情况处理</p><ol><li><p>几种特殊情况，直接干完以后 exit</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理特殊选项 -h 、-v 和 --test-memory</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"-v"</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"--version"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    version();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"--help"</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"-h"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    usage();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"--test-memory"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">3</span>) &#123;</span><br><span class="line">        memtest(atoi(argv[<span class="number">2</span>]), <span class="number">50</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Please specify the amount of memory to test in megabytes.\n"</span>);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Example: ./redis-server --test-memory 4096\n\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接下来看看怎么解析的</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>; <span class="comment">/* First option to parse in argv[] */</span></span><br><span class="line">sds options = sdsempty();</span><br><span class="line"><span class="keyword">char</span> *configfile = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li><p>如果第一个参数（argv[1]）不是以 “–” 开头, 那么它应该是一个配置文件</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (argv[j][<span class="number">0</span>] != <span class="string">'-'</span> || argv[j][<span class="number">1</span>] != <span class="string">'-'</span>) &#123;</span><br><span class="line">    configfile = argv[j++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接下来命令中的参数解析一下，拼到 options 后面</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对用户给定的其余选项进行分析，并将分析所得的字符串追加稍后载入的配置文件的内容之后</span></span><br><span class="line"><span class="comment">// 比如 --port 6380 会被分析为 "port 6380\n"</span></span><br><span class="line"><span class="keyword">while</span> (j != argc) &#123;</span><br><span class="line">    <span class="keyword">if</span> (argv[j][<span class="number">0</span>] == <span class="string">'-'</span> &amp;&amp; argv[j][<span class="number">1</span>] == <span class="string">'-'</span>) &#123;</span><br><span class="line">        <span class="comment">/* Option name */</span></span><br><span class="line">        <span class="keyword">if</span> (sdslen(options)) &#123;</span><br><span class="line">            options = sdscat(options, <span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        options = sdscat(options, argv[j] + <span class="number">2</span>);</span><br><span class="line">        options = sdscat(options, <span class="string">" "</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Option argument */</span></span><br><span class="line">        options = sdscatrepr(options, argv[j], <span class="built_in">strlen</span>(argv[j]));</span><br><span class="line">        options = sdscat(options, <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后如果有 config file 的话，把它打开，然后再把内容拼到字符串里面，再逐行拿出来配置 redis server 的参数</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 载入配置文件， options 是前面分析出的给定选项</span><br><span class="line">loadServerConfig(configfile, options);</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="5-将服务器设置为守护进程"><a href="#5-将服务器设置为守护进程" class="headerlink" title="5. 将服务器设置为守护进程"></a>5. 将服务器设置为守护进程</h3><p>fork 出一个子进程，然后把所有标准 io 重定向到 /dev/null，接下来的所有操作都在子进程里面了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">daemonize</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fork() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/* parent exits */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setsid(); <span class="comment">/* create a new session */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Every output goes to /dev/null. If Redis is daemonized but</span></span><br><span class="line"><span class="comment">     * the 'logfile' is set to 'stdout' in the configuration file</span></span><br><span class="line"><span class="comment">     * it will not log at all. */</span></span><br><span class="line">    <span class="keyword">if</span> ((fd = <span class="built_in">open</span>(<span class="string">"/dev/null"</span>, O_RDWR, <span class="number">0</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        dup2(fd, STDIN_FILENO);</span><br><span class="line">        dup2(fd, STDOUT_FILENO);</span><br><span class="line">        dup2(fd, STDERR_FILENO);</span><br><span class="line">        <span class="keyword">if</span> (fd &gt; STDERR_FILENO) &#123;</span><br><span class="line">            <span class="built_in">close</span>(fd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-创建并初始化服务器数据结构"><a href="#6-创建并初始化服务器数据结构" class="headerlink" title="6. 创建并初始化服务器数据结构"></a>6. 创建并初始化服务器数据结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置信号处理函数</span></span><br><span class="line">    signal(SIGHUP, SIG_IGN);</span><br><span class="line">    signal(SIGPIPE, SIG_IGN);</span><br><span class="line">    setupSignalHandlers();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 syslog</span></span><br><span class="line">    <span class="keyword">if</span> (server.syslog_enabled) &#123;</span><br><span class="line">        openlog(server.syslog_ident, LOG_PID | LOG_NDELAY | LOG_NOWAIT,</span><br><span class="line">                server.syslog_facility);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化并创建数据结构</span></span><br><span class="line">    server.current_client = <span class="literal">NULL</span>;</span><br><span class="line">    server.clients = listCreate();</span><br><span class="line">    server.clients_to_close = listCreate();</span><br><span class="line">    server.slaves = listCreate();</span><br><span class="line">    server.monitors = listCreate();</span><br><span class="line">    server.slaveseldb = <span class="number">-1</span>; <span class="comment">/* Force to emit the first SELECT command. */</span></span><br><span class="line">    server.unblocked_clients = listCreate();</span><br><span class="line">    server.ready_keys = listCreate();</span><br><span class="line">    server.clients_waiting_acks = listCreate();</span><br><span class="line">    server.get_ack_from_slaves = <span class="number">0</span>;</span><br><span class="line">    server.clients_paused = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建共享对象</span></span><br><span class="line">    createSharedObjects();</span><br><span class="line">    adjustOpenFilesLimit();</span><br><span class="line">    server.el = aeCreateEventLoop(server.maxclients + REDIS_EVENTLOOP_FDSET_INCR);</span><br><span class="line">    server.db = zmalloc(<span class="keyword">sizeof</span>(redisDb) * server.dbnum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Open the TCP listening socket for the user commands. */</span></span><br><span class="line">    <span class="comment">// 打开 TCP 监听端口，用于等待客户端的命令请求</span></span><br><span class="line">    <span class="keyword">if</span> (server.port != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        listenToPort(server.port, server.ipfd, &amp;server.ipfd_count) == REDIS_ERR)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Open the listening Unix domain socket. */</span></span><br><span class="line">    <span class="comment">// 打开 UNIX 本地端口</span></span><br><span class="line">    <span class="keyword">if</span> (server.unixsocket != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        unlink(server.unixsocket); <span class="comment">/* don't care if this fails */</span></span><br><span class="line">        server.sofd = anetUnixServer(server.neterr, server.unixsocket,</span><br><span class="line">                                     server.unixsocketperm, server.tcp_backlog);</span><br><span class="line">        <span class="keyword">if</span> (server.sofd == ANET_ERR) &#123;</span><br><span class="line">            redisLog(REDIS_WARNING, <span class="string">"Opening socket: %s"</span>, server.neterr);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        anetNonBlock(<span class="literal">NULL</span>, server.sofd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Abort if there are no listening sockets at all. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.ipfd_count == <span class="number">0</span> &amp;&amp; server.sofd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        redisLog(REDIS_WARNING, <span class="string">"Configured to not listen anywhere, exiting."</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create the Redis databases, and initialize other internal state. */</span></span><br><span class="line">    <span class="comment">// 创建并初始化数据库结构</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.dbnum; j++) &#123;</span><br><span class="line">        server.db[j].dict = dictCreate(&amp;dbDictType, <span class="literal">NULL</span>);</span><br><span class="line">        server.db[j].expires = dictCreate(&amp;keyptrDictType, <span class="literal">NULL</span>);</span><br><span class="line">        server.db[j].blocking_keys = dictCreate(&amp;keylistDictType, <span class="literal">NULL</span>);</span><br><span class="line">        server.db[j].ready_keys = dictCreate(&amp;setDictType, <span class="literal">NULL</span>);</span><br><span class="line">        server.db[j].watched_keys = dictCreate(&amp;keylistDictType, <span class="literal">NULL</span>);</span><br><span class="line">        server.db[j].eviction_pool = evictionPoolAlloc();</span><br><span class="line">        server.db[j].id = j;</span><br><span class="line">        server.db[j].avg_ttl = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 PUBSUB 相关结构</span></span><br><span class="line">    server.pubsub_channels = dictCreate(&amp;keylistDictType, <span class="literal">NULL</span>);</span><br><span class="line">    server.pubsub_patterns = listCreate();</span><br><span class="line">    listSetFreeMethod(server.pubsub_patterns, freePubsubPattern);</span><br><span class="line">    listSetMatchMethod(server.pubsub_patterns, listMatchPubsubPattern);</span><br><span class="line"></span><br><span class="line">    server.cronloops = <span class="number">0</span>;</span><br><span class="line">    server.rdb_child_pid = <span class="number">-1</span>;</span><br><span class="line">    server.aof_child_pid = <span class="number">-1</span>;</span><br><span class="line">    aofRewriteBufferReset();</span><br><span class="line">    server.aof_buf = sdsempty();</span><br><span class="line">    server.lastsave = time(<span class="literal">NULL</span>); <span class="comment">/* At startup we consider the DB saved. */</span></span><br><span class="line">    server.lastbgsave_try = <span class="number">0</span>;    <span class="comment">/* At startup we never tried to BGSAVE. */</span></span><br><span class="line">    server.rdb_save_time_last = <span class="number">-1</span>;</span><br><span class="line">    server.rdb_save_time_start = <span class="number">-1</span>;</span><br><span class="line">    server.dirty = <span class="number">0</span>;</span><br><span class="line">    resetServerStats();</span><br><span class="line">    <span class="comment">/* A few stats we don't want to reset: server startup time, and peak mem. */</span></span><br><span class="line">    server.stat_starttime = time(<span class="literal">NULL</span>);</span><br><span class="line">    server.stat_peak_memory = <span class="number">0</span>;</span><br><span class="line">    server.resident_set_size = <span class="number">0</span>;</span><br><span class="line">    server.lastbgsave_status = REDIS_OK;</span><br><span class="line">    server.aof_last_write_status = REDIS_OK;</span><br><span class="line">    server.aof_last_write_errno = <span class="number">0</span>;</span><br><span class="line">    server.repl_good_slaves_count = <span class="number">0</span>;</span><br><span class="line">    updateCachedTime();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create the serverCron() time event, that's our main way to process</span></span><br><span class="line"><span class="comment">     * background operations. */</span></span><br><span class="line">    <span class="comment">// 为 serverCron() 创建时间事件</span></span><br><span class="line">    <span class="keyword">if</span> (aeCreateTimeEvent(server.el, <span class="number">1</span>, serverCron, <span class="literal">NULL</span>, <span class="literal">NULL</span>) == AE_ERR) &#123;</span><br><span class="line">        redisPanic(<span class="string">"Can't create the serverCron time event."</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create an event handler for accepting new connections in TCP and Unix</span></span><br><span class="line"><span class="comment">     * domain sockets. */</span></span><br><span class="line">    <span class="comment">// 为 TCP 连接关联连接应答（accept）处理器</span></span><br><span class="line">    <span class="comment">// 用于接受并应答客户端的 connect() 调用</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.ipfd_count; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE,</span><br><span class="line">                              acceptTcpHandler, <span class="literal">NULL</span>) == AE_ERR) &#123;</span><br><span class="line">            redisPanic(</span><br><span class="line">                    <span class="string">"Unrecoverable error creating server.ipfd file event."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为本地套接字关联应答处理器</span></span><br><span class="line">    <span class="keyword">if</span> (server.sofd &gt; <span class="number">0</span> &amp;&amp; aeCreateFileEvent(server.el, server.sofd, AE_READABLE,</span><br><span class="line">                                             acceptUnixHandler, <span class="literal">NULL</span>) == AE_ERR)</span><br><span class="line">        redisPanic(<span class="string">"Unrecoverable error creating server.sofd file event."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Open the AOF file if needed. */</span></span><br><span class="line">    <span class="comment">// 如果 AOF 持久化功能已经打开，那么打开或创建一个 AOF 文件</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_state == REDIS_AOF_ON) &#123;</span><br><span class="line">        server.aof_fd = <span class="built_in">open</span>(server.aof_filename,</span><br><span class="line">                             O_WRONLY | O_APPEND | O_CREAT, <span class="number">0644</span>);</span><br><span class="line">        <span class="keyword">if</span> (server.aof_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">            redisLog(REDIS_WARNING, <span class="string">"Can't open the append-only file: %s"</span>,</span><br><span class="line">                     strerror(errno));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 32 bit instances are limited to 4GB of address space, so if there is</span></span><br><span class="line"><span class="comment">     * no explicit limit in the user provided configuration we set a limit</span></span><br><span class="line"><span class="comment">     * at 3 GB using maxmemory with 'noeviction' policy'. This avoids</span></span><br><span class="line"><span class="comment">     * useless crashes of the Redis instance for out of memory. */</span></span><br><span class="line">    <span class="comment">// 对于 32 位实例来说，默认将最大可用内存限制在 3 GB</span></span><br><span class="line">    <span class="keyword">if</span> (server.arch_bits == <span class="number">32</span> &amp;&amp; server.maxmemory == <span class="number">0</span>) &#123;</span><br><span class="line">        redisLog(REDIS_WARNING,</span><br><span class="line">                 <span class="string">"Warning: 32 bit instance detected but no memory limit set. Setting 3 GB maxmemory limit with 'noeviction' policy now."</span>);</span><br><span class="line">        server.maxmemory = <span class="number">3072L</span>L * (<span class="number">1024</span> * <span class="number">1024</span>); <span class="comment">/* 3 GB */</span></span><br><span class="line">        server.maxmemory_policy = REDIS_MAXMEMORY_NO_EVICTION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果服务器以 cluster 模式打开，那么初始化 cluster</span></span><br><span class="line">    <span class="keyword">if</span> (server.cluster_enabled) clusterInit();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化复制功能有关的脚本缓存</span></span><br><span class="line">    replicationScriptCacheInit();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化脚本系统</span></span><br><span class="line">    scriptingInit();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化慢查询功能</span></span><br><span class="line">    slowlogInit();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 BIO 系统</span></span><br><span class="line">    bioInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数很长，分段看一下。</p><ol><li><p>设置各种信号处理函数</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">signal(SIGHUP, SIG_IGN);</span><br><span class="line">signal(SIGPIPE, SIG_IGN);</span><br><span class="line"></span><br><span class="line">setupSignalHandlers();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setupSignalHandlers</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line"></span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    act.sa_handler = sigtermHandler;</span><br><span class="line">    sigaction(SIGTERM, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_BACKTRACE</span></span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags = SA_NODEFER | SA_RESETHAND | SA_SIGINFO;</span><br><span class="line">    act.sa_sigaction = sigsegvHandler;</span><br><span class="line"></span><br><span class="line">    sigaction(SIGSEGV, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    sigaction(SIGBUS, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    sigaction(SIGFPE, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    sigaction(SIGILL, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SIGTERM 信号的处理器</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sigtermHandler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">    REDIS_NOTUSED(sig);</span><br><span class="line"></span><br><span class="line">    redisLogFromHandler(REDIS_WARNING, <span class="string">"Received SIGTERM, scheduling shutdown..."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开关闭标识</span></span><br><span class="line">    server.shutdown_asap = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>设置 syslog</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.syslog_enabled) &#123;</span><br><span class="line">    openlog(server.syslog_ident, LOG_PID | LOG_NDELAY | LOG_NOWAIT,</span><br><span class="line">            server.syslog_facility);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>初始化并创建数据结构</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server.current_client = <span class="literal">NULL</span>;</span><br><span class="line">server.clients = listCreate();</span><br><span class="line">server.clients_to_close = listCreate();</span><br><span class="line">server.slaves = listCreate();</span><br><span class="line">server.monitors = listCreate();</span><br><span class="line">server.slaveseldb = <span class="number">-1</span>; <span class="comment">/* Force to emit the first SELECT command. */</span></span><br><span class="line">server.unblocked_clients = listCreate();</span><br><span class="line">server.ready_keys = listCreate();</span><br><span class="line">server.clients_waiting_acks = listCreate();</span><br><span class="line">server.get_ack_from_slaves = <span class="number">0</span>;</span><br><span class="line">server.clients_paused = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><p>创建共享对象</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createSharedObjects();</span><br></pre></td></tr></table></figure><p> 这个函数里面把 struct sharedObjectsStruct shared 构造好，这个结构体包含了常见的命令回复</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过复用来减少内存碎片，以及减少操作耗时的共享对象</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sharedObjectsStruct</span> &#123;</span></span><br><span class="line">    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,</span><br><span class="line">        *colon, *nullbulk, *nullmultibulk, *queued,</span><br><span class="line">        *emptymultibulk, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,</span><br><span class="line">        *outofrangeerr, *noscripterr, *loadingerr, *slowscripterr, *bgsaveerr,</span><br><span class="line">        *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noreplicaserr,</span><br><span class="line">        *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,</span><br><span class="line">        *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *rpop, *lpop,</span><br><span class="line">        *lpush, *emptyscan, *minstring, *maxstring,</span><br><span class="line">        *select[REDIS_SHARED_SELECT_CMDS],</span><br><span class="line">        *integers[REDIS_SHARED_INTEGERS],</span><br><span class="line">        *mbulkhdr[REDIS_SHARED_BULKHDR_LEN], <span class="comment">/* "*&lt;value&gt;\r\n" */</span></span><br><span class="line">        *bulkhdr[REDIS_SHARED_BULKHDR_LEN];  <span class="comment">/* "$&lt;value&gt;\r\n" */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>初始化事件处理器状态</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">server.el = aeCreateEventLoop(server.maxclients + REDIS_EVENTLOOP_FDSET_INCR);</span><br><span class="line"></span><br><span class="line"><span class="function">aeEventLoop *<span class="title">aeCreateEventLoop</span><span class="params">(<span class="keyword">int</span> setsize)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    aeEventLoop *eventLoop;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建事件状态结构</span></span><br><span class="line">    <span class="keyword">if</span> ((eventLoop = zmalloc(<span class="keyword">sizeof</span>(*eventLoop))) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化文件事件结构和已就绪文件事件结构数组</span></span><br><span class="line">    eventLoop-&gt;events = zmalloc(<span class="keyword">sizeof</span>(aeFileEvent) * setsize);</span><br><span class="line">    eventLoop-&gt;fired = zmalloc(<span class="keyword">sizeof</span>(aeFiredEvent) * setsize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eventLoop-&gt;events == <span class="literal">NULL</span> || eventLoop-&gt;fired == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置数组大小</span></span><br><span class="line">    eventLoop-&gt;setsize = setsize;</span><br><span class="line">    <span class="comment">// 初始化执行最近一次执行时间</span></span><br><span class="line">    eventLoop-&gt;lastTime = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化时间事件结构</span></span><br><span class="line">    eventLoop-&gt;timeEventHead = <span class="literal">NULL</span>;</span><br><span class="line">    eventLoop-&gt;timeEventNextId = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    eventLoop-&gt;<span class="built_in">stop</span> = <span class="number">0</span>;</span><br><span class="line">    eventLoop-&gt;maxfd = <span class="number">-1</span>;</span><br><span class="line">    eventLoop-&gt;beforesleep = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (aeApiCreate(eventLoop) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化监听事件</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; setsize; i++) &#123;</span><br><span class="line">        eventLoop-&gt;events[i].mask = AE_NONE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回事件循环</span></span><br><span class="line">    <span class="keyword">return</span> eventLoop;</span><br><span class="line"></span><br><span class="line">    err:</span><br><span class="line">    <span class="keyword">if</span> (eventLoop) &#123;</span><br><span class="line">        zfree(eventLoop-&gt;events);</span><br><span class="line">        zfree(eventLoop-&gt;fired);</span><br><span class="line">        zfree(eventLoop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这个方法之前看过，底层是 IO 多路复用库，创建一个 eventloop 来监听端口</p></li><li><p>打开 TCP 监听端口，用于等待客户端的命令请求</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">listenToPort(server.port, server.ipfd, &amp;server.ipfd_count);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listenToPort</span><span class="params">(<span class="keyword">int</span> port, <span class="keyword">int</span> *fds, <span class="keyword">int</span> *count)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.bindaddr_count == <span class="number">0</span>) server.bindaddr[<span class="number">0</span>] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.bindaddr_count || j == <span class="number">0</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (server.bindaddr[j] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            fds[*count] = anetTcp6Server(server.neterr, port, <span class="literal">NULL</span>, server.tcp_backlog);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fds[*count] != ANET_ERR) &#123;</span><br><span class="line">                anetNonBlock(<span class="literal">NULL</span>, fds[*count]);</span><br><span class="line">                (*count)++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fds[*count] = anetTcpServer(server.neterr, port, <span class="literal">NULL</span>, server.tcp_backlog);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fds[*count] != ANET_ERR) &#123;</span><br><span class="line">                anetNonBlock(<span class="literal">NULL</span>, fds[*count]);</span><br><span class="line">                (*count)++;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span> (*count) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strchr</span>(server.bindaddr[j], <span class="string">':'</span>)) &#123;</span><br><span class="line">        </span><br><span class="line">            fds[*count] = anetTcp6Server(server.neterr, port, server.bindaddr[j], server.tcp_backlog);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">            fds[*count] = anetTcpServer(server.neterr, port, server.bindaddr[j], server.tcp_backlog);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fds[*count] == ANET_ERR) &#123;</span><br><span class="line">            redisLog(REDIS_WARNING,</span><br><span class="line">                 <span class="string">"Creating Server TCP listening socket %s:%d: %s"</span>,</span><br><span class="line">                 server.bindaddr[j] ? server.bindaddr[j] : <span class="string">"*"</span>,</span><br><span class="line">                 port, server.neterr);</span><br><span class="line">            <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        anetNonBlock(<span class="literal">NULL</span>, fds[*count]);</span><br><span class="line">        (*count)++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这个方法初始化一组文件描述符以侦听指定的“端口”，绑定Redis服务器配置中指定的地址，并设置为非阻塞。</p></li><li><p>打开 UNIX 本地端口</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.unixsocket != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    unlink(server.unixsocket); <span class="comment">/* don't care if this fails */</span></span><br><span class="line">    server.sofd = anetUnixServer(server.neterr, server.unixsocket,</span><br><span class="line">                                 server.unixsocketperm, server.tcp_backlog);</span><br><span class="line">    <span class="keyword">if</span> (server.sofd == ANET_ERR) &#123;</span><br><span class="line">        redisLog(REDIS_WARNING, <span class="string">"Opening socket: %s"</span>, server.neterr);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    anetNonBlock(<span class="literal">NULL</span>, server.sofd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建并初始化数据库结构</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.dbnum; j++) &#123;</span><br><span class="line">    server.db[j].dict = dictCreate(&amp;dbDictType, <span class="literal">NULL</span>);</span><br><span class="line">    server.db[j].expires = dictCreate(&amp;keyptrDictType, <span class="literal">NULL</span>);</span><br><span class="line">    server.db[j].blocking_keys = dictCreate(&amp;keylistDictType, <span class="literal">NULL</span>);</span><br><span class="line">    server.db[j].ready_keys = dictCreate(&amp;setDictType, <span class="literal">NULL</span>);</span><br><span class="line">    server.db[j].watched_keys = dictCreate(&amp;keylistDictType, <span class="literal">NULL</span>);</span><br><span class="line">    server.db[j].eviction_pool = evictionPoolAlloc();</span><br><span class="line">    server.db[j].id = j;</span><br><span class="line">    server.db[j].avg_ttl = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建时间事件</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aeCreateTimeEvent(server.el, <span class="number">1</span>, serverCron, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><blockquote><p>注意到这里周期是 1ms，靠的是后面的 run_with_period 来控制具体周期</p></blockquote><p> 这里面的重点是 serverCron 函数，这个函数相当长，看看 run_with_period 挺好的：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">run_with_period(<span class="number">100</span>) &#123;</span><br><span class="line">    trackOperationsPerSecond();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> run_with_period(_ms_) <span class="meta-keyword">if</span> ((_ms_ &lt;= 1000/server.hz) || !(server.cronloops%((_ms_)/(1000/server.hz))))</span></span><br></pre></td></tr></table></figure><p> run_with_period 本身是一个宏，server.cronloops 每转一圈会自增。</p></li><li><p>为 TCP 连接关联连接应答（accept）处理器，用于接受并应答客户端的 connect() 调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.ipfd_count; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE,</span><br><span class="line">                          acceptTcpHandler, <span class="literal">NULL</span>) == AE_ERR) &#123;</span><br><span class="line">        redisPanic(</span><br><span class="line">                <span class="string">"Unrecoverable error creating server.ipfd file event."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>为本地套接字关联应答处理器</p><blockquote><p>注：例如 lua 脚本需要伪客户端</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.sofd &gt; <span class="number">0</span> &amp;&amp; aeCreateFileEvent(</span><br><span class="line">        server.el, server.sofd, AE_READABLE,</span><br><span class="line">        acceptUnixHandler, <span class="literal">NULL</span>) == AE_ERR) &#123;</span><br><span class="line">    redisPanic(<span class="string">"Unrecoverable error creating server.sofd file event."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果 AOF 持久化功能已经打开，那么打开或创建一个 AOF 文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.aof_state == REDIS_AOF_ON) &#123;</span><br><span class="line">    server.aof_fd = <span class="built_in">open</span>(server.aof_filename,</span><br><span class="line">                         O_WRONLY | O_APPEND | O_CREAT, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (server.aof_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        redisLog(REDIS_WARNING, <span class="string">"Can't open the append-only file: %s"</span>,</span><br><span class="line">                 strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>集群、复制功能相关</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.arch_bits == <span class="number">32</span> &amp;&amp; server.maxmemory == <span class="number">0</span>) &#123;</span><br><span class="line">    redisLog(REDIS_WARNING,</span><br><span class="line">             <span class="string">"Warning: 32 bit instance detected but no memory limit set. Setting 3 GB maxmemory limit with 'noeviction' policy now."</span>);</span><br><span class="line">    server.maxmemory = <span class="number">3072L</span>L * (<span class="number">1024</span> * <span class="number">1024</span>); <span class="comment">/* 3 GB */</span></span><br><span class="line">    server.maxmemory_policy = REDIS_MAXMEMORY_NO_EVICTION;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果服务器以 cluster 模式打开，那么初始化 cluster</span></span><br><span class="line"><span class="keyword">if</span> (server.cluster_enabled) &#123;</span><br><span class="line">    clusterInit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化复制功能有关的脚本缓存</span></span><br><span class="line">replicationScriptCacheInit();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化脚本系统</span></span><br><span class="line">scriptingInit();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化慢查询功能</span></span><br><span class="line">slowlogInit();</span><br></pre></td></tr></table></figure></li><li><p>初始化 BIO 系统</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bioInit();</span><br></pre></td></tr></table></figure><p>这个函数是用于初始化线程和临界区</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line"><span class="keyword">pthread_t</span> thread;</span><br><span class="line"><span class="keyword">size_t</span> stacksize;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialization of state vars and objects </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 初始化 job 队列，以及线程状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; REDIS_BIO_NUM_OPS; j++) &#123;</span><br><span class="line">    pthread_mutex_init(&amp;bio_mutex[j],<span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;bio_condvar[j],<span class="literal">NULL</span>);</span><br><span class="line">    bio_jobs[j] = listCreate();</span><br><span class="line">    bio_pending[j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set the stack size as by default it may be small in some system </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 设置栈大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">pthread_attr_init(&amp;attr);</span><br><span class="line">pthread_attr_getstacksize(&amp;attr,&amp;stacksize);</span><br><span class="line"><span class="keyword">if</span> (!stacksize) stacksize = <span class="number">1</span>; <span class="comment">/* The world is full of Solaris Fixes */</span></span><br><span class="line"><span class="keyword">while</span> (stacksize &lt; REDIS_THREAD_STACK_SIZE) stacksize *= <span class="number">2</span>;</span><br><span class="line">pthread_attr_setstacksize(&amp;attr, stacksize);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ready to spawn our threads. We use the single argument the thread</span></span><br><span class="line"><span class="comment"> * function accepts in order to pass the job ID the thread is</span></span><br><span class="line"><span class="comment"> * responsible of. </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 创建线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; REDIS_BIO_NUM_OPS; j++) &#123;</span><br><span class="line">    <span class="keyword">void</span> *arg = (<span class="keyword">void</span>*)(<span class="keyword">unsigned</span> <span class="keyword">long</span>) j;</span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;thread,&amp;attr,bioProcessBackgroundJobs,arg) != <span class="number">0</span>) &#123;</span><br><span class="line">        redisLog(REDIS_WARNING,<span class="string">"Fatal: Can't initialize Background Jobs."</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    bio_threads[j] = thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，<strong>Redis 不是完全的单线程</strong>，会<strong>开两个后台线程</strong>：</p><ul><li><p>后台线程的作用是</p><ul><li>aof 的 fsync 系统调用</li><li>文件的最后一个 owner 对文件进行 close</li></ul></li><li><p>实现方式是临界区放一个 list，生产者-消费者模式</p></li></ul></li></ol><h3 id="7-如果服务器是守护进程，那么创建-PID-文件"><a href="#7-如果服务器是守护进程，那么创建-PID-文件" class="headerlink" title="7. 如果服务器是守护进程，那么创建 PID 文件"></a>7. 如果服务器是守护进程，那么创建 PID 文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.daemonize) &#123;</span><br><span class="line">    createPidFile();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createPidFile</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Try to write the pid file in a best-effort way. */</span></span><br><span class="line">    FILE *fp = fopen(server.pidfile, <span class="string">"w"</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(fp, <span class="string">"%d\n"</span>, (<span class="keyword">int</span>) getpid());</span><br><span class="line">        fclose(fp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-为服务器进程设置名字"><a href="#8-为服务器进程设置名字" class="headerlink" title="8. 为服务器进程设置名字"></a>8. 为服务器进程设置名字</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">redisSetProcTitle(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">redisSetProcTitle</span><span class="params">(<span class="keyword">char</span> *title)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_SETPROCTITLE</span></span><br><span class="line">    <span class="keyword">char</span> *server_mode = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">if</span> (server.cluster_enabled) server_mode = <span class="string">" [cluster]"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (server.sentinel_mode) server_mode = <span class="string">" [sentinel]"</span>;</span><br><span class="line"></span><br><span class="line">    setproctitle(<span class="string">"%s %s:%d%s"</span>,</span><br><span class="line">        title,</span><br><span class="line">        server.bindaddr_count ? server.bindaddr[<span class="number">0</span>] : <span class="string">"*"</span>,</span><br><span class="line">        server.port,</span><br><span class="line">        server_mode);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    REDIS_NOTUSED(title);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-打印-ASCII-LOGO"><a href="#9-打印-ASCII-LOGO" class="headerlink" title="9. 打印 ASCII LOGO"></a>9. 打印 ASCII LOGO</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">redisAsciiArt</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"asciilogo.h"</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *buf = zmalloc(<span class="number">1024</span> * <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">char</span> *mode = <span class="string">"stand alone"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.cluster_enabled) &#123;</span><br><span class="line">        mode = <span class="string">"cluster"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (server.sentinel_mode) &#123;</span><br><span class="line">        mode = <span class="string">"sentinel"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="number">1024</span> * <span class="number">16</span>, ascii_logo,</span><br><span class="line">             REDIS_VERSION,</span><br><span class="line">             redisGitSHA1(),</span><br><span class="line">             strtol(redisGitDirty(), <span class="literal">NULL</span>, <span class="number">10</span>) &gt; <span class="number">0</span>,</span><br><span class="line">             (<span class="keyword">sizeof</span>(<span class="keyword">long</span>) == <span class="number">8</span>) ? <span class="string">"64"</span> : <span class="string">"32"</span>,</span><br><span class="line">             mode, server.port,</span><br><span class="line">             (<span class="keyword">long</span>) getpid()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    redisLogRaw(REDIS_NOTICE | REDIS_LOG_RAW, buf);</span><br><span class="line">    zfree(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-载入-rdb-和-aof-文件"><a href="#10-载入-rdb-和-aof-文件" class="headerlink" title="10. 载入 rdb 和 aof 文件"></a>10. 载入 rdb 和 aof 文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loadDataFromDisk();</span><br></pre></td></tr></table></figure><p>这里面分为 2 种， aof 和 rdb</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loadDataFromDisk</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> start = ustime();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AOF 持久化已打开？</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_state == REDIS_AOF_ON) &#123;</span><br><span class="line">        <span class="comment">// 尝试载入 AOF 文件</span></span><br><span class="line">        <span class="keyword">if</span> (loadAppendOnlyFile(server.aof_filename) == REDIS_OK)</span><br><span class="line">            <span class="comment">// 打印载入信息，并计算载入耗时长度</span></span><br><span class="line">            redisLog(REDIS_NOTICE, <span class="string">"DB loaded from append only file: %.3f seconds"</span>,</span><br><span class="line">                     (<span class="keyword">float</span>) (ustime() - start) / <span class="number">1000000</span>);</span><br><span class="line">        <span class="comment">// AOF 持久化未打开</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试载入 RDB 文件</span></span><br><span class="line">        <span class="keyword">if</span> (rdbLoad(server.rdb_filename) == REDIS_OK) &#123;</span><br><span class="line">            <span class="comment">// 打印载入信息，并计算载入耗时长度</span></span><br><span class="line">            redisLog(REDIS_NOTICE, <span class="string">"DB loaded from disk: %.3f seconds"</span>,</span><br><span class="line">                     (<span class="keyword">float</span>) (ustime() - start) / <span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (errno != ENOENT) &#123;</span><br><span class="line">            redisLog(REDIS_WARNING, <span class="string">"Fatal error loading the DB: %s. Exiting."</span>, strerror(errno));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-设置-before-sleep-方法"><a href="#11-设置-before-sleep-方法" class="headerlink" title="11. 设置 before sleep 方法"></a>11. 设置 before sleep 方法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aeSetBeforeSleepProc(server.el, beforeSleep);</span><br></pre></td></tr></table></figure><p>这个方法是每一圈 loop 之前执行的方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">beforeSleep</span><span class="params">(struct aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    REDIS_NOTUSED(eventLoop);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Run a fast expire cycle (the called function will return</span></span><br><span class="line"><span class="comment">     * ASAP if a fast cycle is not needed). */</span></span><br><span class="line">    <span class="comment">// 执行一次快速的主动过期检查</span></span><br><span class="line">    <span class="keyword">if</span> (server.active_expire_enabled &amp;&amp; server.masterhost == <span class="literal">NULL</span>)</span><br><span class="line">        activeExpireCycle(ACTIVE_EXPIRE_CYCLE_FAST);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Send all the slaves an ACK request if at least one client blocked</span></span><br><span class="line"><span class="comment">     * during the previous event loop iteration. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.get_ack_from_slaves) &#123;</span><br><span class="line">        robj *argv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        argv[<span class="number">0</span>] = createStringObject(<span class="string">"REPLCONF"</span>, <span class="number">8</span>);</span><br><span class="line">        argv[<span class="number">1</span>] = createStringObject(<span class="string">"GETACK"</span>, <span class="number">6</span>);</span><br><span class="line">        argv[<span class="number">2</span>] = createStringObject(<span class="string">"*"</span>, <span class="number">1</span>); <span class="comment">/* Not used argument. */</span></span><br><span class="line"></span><br><span class="line">        replicationFeedSlaves(server.slaves, server.slaveseldb, argv, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        decrRefCount(argv[<span class="number">0</span>]);</span><br><span class="line">        decrRefCount(argv[<span class="number">1</span>]);</span><br><span class="line">        decrRefCount(argv[<span class="number">2</span>]);</span><br><span class="line">        server.get_ack_from_slaves = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Unblock all the clients blocked for synchronous replication</span></span><br><span class="line"><span class="comment">     * in WAIT. */</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(server.clients_waiting_acks))</span><br><span class="line">        processClientsWaitingReplicas();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Try to process pending commands for clients that were just unblocked. */</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(server.unblocked_clients))</span><br><span class="line">        processUnblockedClients();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Write the AOF buffer on disk */</span></span><br><span class="line">    <span class="comment">// 将 AOF 缓冲区的内容写入到 AOF 文件</span></span><br><span class="line">    flushAppendOnlyFile(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Call the Redis Cluster before sleep function. */</span></span><br><span class="line">    <span class="comment">// 在进入下个事件循环前，执行一些集群收尾工作</span></span><br><span class="line">    <span class="keyword">if</span> (server.cluster_enabled) &#123;</span><br><span class="line">        clusterBeforeSleep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中一个重要的函数是 flushAppendOnlyFile ，用于将 AOF 缓冲区的内容写入到 AOF 文件。</p><h3 id="12-开始主-loop"><a href="#12-开始主-loop" class="headerlink" title="12. 开始主 loop"></a>12. 开始主 loop</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">aeMain(server.el);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 事件处理器的主循环</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    eventLoop-&gt;<span class="built_in">stop</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!eventLoop-&gt;<span class="built_in">stop</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有需要在事件处理前执行的函数，那么运行它</span></span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;beforesleep != <span class="literal">NULL</span>)</span><br><span class="line">            eventLoop-&gt;beforesleep(eventLoop);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始处理事件</span></span><br><span class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>aeProcessEvents 方法之前看过，典型的 reactor 模式</p><h3 id="13-结束，清理-loop"><a href="#13-结束，清理-loop" class="headerlink" title="13. 结束，清理 loop"></a>13. 结束，清理 loop</h3><p>aeMain 是一个 while 循环，如果能执行到这里说明结束了，回收一下空间就行了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeDeleteEventLoop</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    aeApiFree(eventLoop);</span><br><span class="line">    zfree(eventLoop-&gt;events);</span><br><span class="line">    zfree(eventLoop-&gt;fired);</span><br><span class="line">    zfree(eventLoop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="关于几个文件事件处理器的逻辑关系"><a href="#关于几个文件事件处理器的逻辑关系" class="headerlink" title="关于几个文件事件处理器的逻辑关系"></a>关于几个文件事件处理器的逻辑关系</h2><p>一共有 3 个：</p><ol><li><p>networking.c/acceptTcpHandler 函数是Redis的连接应答处理器，这个处理器用于对连接服务器监听套接字的客户端进行应答</p></li><li><p>networking.c/readQueryFromClient 函数是Redis的命令请求处理器，这个处理器负责从套接字中读入客户端发送的命令请求内容，具体实现为unistd.h/read函数的包装</p></li><li><p>networking.c/sendReplyToClient 函数是Redis的命令回复处理器，这个处理器负责将服务器执行命令后得到的命令回复通过套接字返回给客户端，具体实现为unistd.h/write函数的包装</p></li></ol><p>它们的逻辑关系是这样的：</p><ul><li><p>在 redis.c/initServer 中，redis server 的 main 方法在开始 EventLoop 之前，会进行一系列初始化，其中就包括了 initServer 一步，这个函数中的其中一个环节是开启 TCP 监听端口，注册了 acceptTcpHandler 到文件事件</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为 TCP 连接关联连接应答（accept）处理器</span></span><br><span class="line"><span class="comment">// 用于接受并应答客户端的 connect() 调用</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.ipfd_count; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE,</span><br><span class="line">                          acceptTcpHandler, <span class="literal">NULL</span>) == AE_ERR) &#123;</span><br><span class="line">        redisPanic(</span><br><span class="line">                <span class="string">"Unrecoverable error creating server.ipfd file event."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>一旦客户端 connect ，就会进入 acceptTcpHandler 方法，这个方法里会 accept 客户端连接，如果成功会进入 acceptCommonHandler 方法</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">max</span>--) &#123;</span><br><span class="line">    <span class="comment">// accept 客户端连接</span></span><br><span class="line">    cfd = anetTcpAccept(server.neterr, fd, cip, <span class="keyword">sizeof</span>(cip), &amp;cport);</span><br><span class="line">    <span class="keyword">if</span> (cfd == ANET_ERR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno != EWOULDBLOCK)</span><br><span class="line">            redisLog(REDIS_WARNING,</span><br><span class="line">                     <span class="string">"Accepting client connection: %s"</span>, server.neterr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    redisLog(REDIS_VERBOSE, <span class="string">"Accepted %s:%d"</span>, cip, cport);</span><br><span class="line">    <span class="comment">// 为客户端创建客户端状态（redisClient）</span></span><br><span class="line">    acceptCommonHandler(cfd, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>acceptCommonHandler 中会创建 redisClient</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((c = createClient(fd)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    redisLog(REDIS_WARNING,</span><br><span class="line">             <span class="string">"Error registering fd event for the new client: %s (fd=%d)"</span>,</span><br><span class="line">             strerror(errno), fd);</span><br><span class="line">    <span class="built_in">close</span>(fd); <span class="comment">/* May be already closed, just ignore errors */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在创建客户端的方法 createClient 中，会绑定读事件到事件 loop ，开始接收命令请求，并注册 readQueryFromClient 这一事件处理器</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fd != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="comment">// 非阻塞</span></span><br><span class="line">    anetNonBlock(<span class="literal">NULL</span>, fd);</span><br><span class="line">    <span class="comment">// 禁用 Nagle 算法</span></span><br><span class="line">    anetEnableTcpNoDelay(<span class="literal">NULL</span>, fd);</span><br><span class="line">    <span class="comment">// 设置 keep alive</span></span><br><span class="line">    <span class="keyword">if</span> (server.tcpkeepalive)</span><br><span class="line">        anetKeepAlive(<span class="literal">NULL</span>, fd, server.tcpkeepalive);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定读事件到事件 loop （开始接收命令请求）</span></span><br><span class="line">    <span class="keyword">if</span> (aeCreateFileEvent(server.el, fd, AE_READABLE, readQueryFromClient, c) == AE_ERR) &#123;</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        zfree(c);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>一旦客户端的请求到达，就会进入 readQueryFromClient 这一事件处理器，这个处理器里会读 client 的查询 buffer</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readQueryFromClient</span><span class="params">(aeEventLoop *el, <span class="keyword">int</span> fd, <span class="keyword">void</span> *privdata, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从查询缓存重读取内容，创建参数，并执行命令</span></span><br><span class="line">    <span class="comment">// 函数会执行到缓存中的所有内容都被处理完为止</span></span><br><span class="line">    processInputBuffer(c);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这个 processInputBuffer 方法会对请求的信息进行解析，变成 command 形式，然后执行这个 command</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInputBuffer</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (processCommand(c) == REDIS_OK)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行完 command 以后，会有执行结果，这个结果最终会返回给客户端，但是要客户端变得 WRITABLE 才行，所以要先放到 redis client 的 buffer 里面，这个过程要进行一堆函数调用</p><p>  <code>processCommand -&gt; addReply -&gt; _addReplyToBuffer -&gt; memcpy(c-&gt;buf + c-&gt;bufpos, s, len);</code></p></li><li><p>在 addReply 的时候，会绑定写事件到事件 loop ，注册 sendReplyToClient 这一事件处理器，当 fd 变得可写时触发</p><p>  <code>addReply -&gt; prepareClientToWrite -&gt; aeCreateFileEvent</code></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prepareClientToWrite</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一般情况，为客户端套接字安装写处理器到事件循环</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;bufpos == <span class="number">0</span> &amp;&amp; listLength(c-&gt;reply) == <span class="number">0</span> &amp;&amp; (c-&gt;replstate == REDIS_REPL_NONE ||</span><br><span class="line">     c-&gt;replstate == REDIS_REPL_ONLINE) &amp;&amp; aeCreateFileEvent(server.el, c-&gt;fd, AE_WRITABLE, sendReplyToClient, c) == AE_ERR)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="redis-不能简单说是一个单进程单线程-reactor"><a href="#redis-不能简单说是一个单进程单线程-reactor" class="headerlink" title="redis 不能简单说是一个单进程单线程 reactor"></a>redis 不能简单说是一个单进程单线程 reactor</h2><p>原因：</p><ul><li><p>执行 BGSAVE 、 BGREWRITEAOF 等命令时，会 fork 子进程</p></li><li><p>bio 会开两个后台线程，用于 aof 的 fsync 强制刷磁盘 和 文件的 close</p></li></ul><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;redis 单机服务器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%e6%b6%89%e5%8f%8a%e6%96%87%e4%bb%b6&quot;&gt;涉及文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#redis-server&quot;&gt;redis server&lt;/a&gt;&lt;ul&gt;
&lt;
      
    
    </summary>
    
    
      <category term="开源组件" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/"/>
    
      <category term="Redis" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/"/>
    
      <category term="源码阅读" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
      <category term="C" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Redis 源码阅读10_客户端和服务器_networking</title>
    <link href="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB10_%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8_networking/"/>
    <id>http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB10_%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8_networking/</id>
    <published>2020-03-11T12:25:46.335Z</published>
    <updated>2020-03-11T12:27:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 的网络连接库，负责发送命令回复和接受命令请求， 同时也负责创建/销毁客户端， 以及通信协议分析等工作。</p><ul><li><a href="#%e6%b6%89%e5%8f%8a%e6%96%87%e4%bb%b6">涉及文件</a></li><li><a href="#api">API</a><ul><li><a href="#redisclient-createclientint-fd">redisClient *createClient(int fd)</a></li><li><a href="#void-accepttcphandleraeeventloop-el-int-fd-void-privdata-int-mask">void acceptTcpHandler(aeEventLoop *el, int fd, void *privdata, int mask)</a></li><li><a href="#static-void-acceptcommonhandlerint-fd-int-flags">static void acceptCommonHandler(int fd, int flags)</a></li></ul></li></ul><h2 id="涉及文件"><a href="#涉及文件" class="headerlink" title="涉及文件"></a>涉及文件</h2><p><code>networking.c</code></p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><ul><li><p>redisClient *createClient(int fd)</p></li><li><p>int prepareClientToWrite(redisClient *c)</p></li><li><p>void acceptTcpHandler(aeEventLoop *el, int fd, void *privdata, int mask)</p></li><li><p>void acceptUnixHandler(aeEventLoop *el, int fd, void *privdata, int mask)</p></li><li><p>void freeClient(redisClient *c)</p></li><li><p>void sendReplyToClient(aeEventLoop *el, int fd, void *privdata, int mask)</p></li></ul><h3 id="redisClient-createClient-int-fd"><a href="#redisClient-createClient-int-fd" class="headerlink" title="redisClient *createClient(int fd)"></a>redisClient *createClient(int fd)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建一个新客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">redisClient *<span class="title">createClient</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配空间</span></span><br><span class="line">    redisClient *c = zmalloc(<span class="keyword">sizeof</span>(redisClient));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* passing -1 as fd it is possible to create a non connected client.</span></span><br><span class="line"><span class="comment">     * This is useful since all the Redis commands needs to be executed</span></span><br><span class="line"><span class="comment">     * in the context of a client. When commands are executed in other</span></span><br><span class="line"><span class="comment">     * contexts (for instance a Lua script) we need a non connected client. */</span></span><br><span class="line">    <span class="comment">// 当 fd 不为 -1 时，创建带网络连接的客户端</span></span><br><span class="line">    <span class="comment">// 如果 fd 为 -1 ，那么创建无网络连接的伪客户端</span></span><br><span class="line">    <span class="comment">// 因为 Redis 的命令必须在客户端的上下文中使用，所以在执行 Lua 环境中的命令时</span></span><br><span class="line">    <span class="comment">// 需要用到这种伪终端</span></span><br><span class="line">    <span class="keyword">if</span> (fd != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 非阻塞</span></span><br><span class="line">        anetNonBlock(<span class="literal">NULL</span>, fd);</span><br><span class="line">        <span class="comment">// 禁用 Nagle 算法</span></span><br><span class="line">        anetEnableTcpNoDelay(<span class="literal">NULL</span>, fd);</span><br><span class="line">        <span class="comment">// 设置 keep alive</span></span><br><span class="line">        <span class="keyword">if</span> (server.tcpkeepalive)</span><br><span class="line">            anetKeepAlive(<span class="literal">NULL</span>, fd, server.tcpkeepalive);</span><br><span class="line">        <span class="comment">// 绑定读事件到事件 loop （开始接收命令请求）</span></span><br><span class="line">        <span class="keyword">if</span> (aeCreateFileEvent(server.el, fd, AE_READABLE,</span><br><span class="line">                              readQueryFromClient, c) == AE_ERR) &#123;</span><br><span class="line">            <span class="built_in">close</span>(fd);</span><br><span class="line">            zfree(c);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化各个属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认数据库</span></span><br><span class="line">    selectDb(c, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 套接字</span></span><br><span class="line">    c-&gt;fd = fd;</span><br><span class="line">    <span class="comment">// 名字</span></span><br><span class="line">    c-&gt;name = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 回复缓冲区的偏移量</span></span><br><span class="line">    c-&gt;bufpos = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 查询缓冲区</span></span><br><span class="line">    c-&gt;querybuf = sdsempty();</span><br><span class="line">    <span class="comment">// 查询缓冲区峰值</span></span><br><span class="line">    c-&gt;querybuf_peak = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 命令请求的类型</span></span><br><span class="line">    c-&gt;reqtype = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 命令参数数量</span></span><br><span class="line">    c-&gt;argc = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 命令参数</span></span><br><span class="line">    c-&gt;argv = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 当前执行的命令和最近一次执行的命令</span></span><br><span class="line">    c-&gt;cmd = c-&gt;lastcmd = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 查询缓冲区中未读入的命令内容数量</span></span><br><span class="line">    c-&gt;multibulklen = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 读入的参数的长度</span></span><br><span class="line">    c-&gt;bulklen = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 已发送字节数</span></span><br><span class="line">    c-&gt;sentlen = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 状态 FLAG</span></span><br><span class="line">    c-&gt;flags = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 创建时间和最后一次互动时间</span></span><br><span class="line">    c-&gt;ctime = c-&gt;lastinteraction = server.unixtime;</span><br><span class="line">    <span class="comment">// 认证状态</span></span><br><span class="line">    c-&gt;authenticated = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 复制状态</span></span><br><span class="line">    c-&gt;replstate = REDIS_REPL_NONE;</span><br><span class="line">    <span class="comment">// 复制偏移量</span></span><br><span class="line">    c-&gt;reploff = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 通过 ACK 命令接收到的偏移量</span></span><br><span class="line">    c-&gt;repl_ack_off = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 通过 AKC 命令接收到偏移量的时间</span></span><br><span class="line">    c-&gt;repl_ack_time = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 客户端为从服务器时使用，记录了从服务器所使用的端口号</span></span><br><span class="line">    c-&gt;slave_listening_port = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 回复链表</span></span><br><span class="line">    c-&gt;reply = listCreate();</span><br><span class="line">    <span class="comment">// 回复链表的字节量</span></span><br><span class="line">    c-&gt;reply_bytes = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 回复缓冲区大小达到软限制的时间</span></span><br><span class="line">    c-&gt;obuf_soft_limit_reached_time = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 回复链表的释放和复制函数</span></span><br><span class="line">    listSetFreeMethod(c-&gt;reply, decrRefCountVoid);</span><br><span class="line">    listSetDupMethod(c-&gt;reply, dupClientReplyValue);</span><br><span class="line">    <span class="comment">// 阻塞类型</span></span><br><span class="line">    c-&gt;btype = REDIS_BLOCKED_NONE;</span><br><span class="line">    <span class="comment">// 阻塞超时</span></span><br><span class="line">    c-&gt;bpop.timeout = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 造成客户端阻塞的列表键</span></span><br><span class="line">    c-&gt;bpop.keys = dictCreate(&amp;setDictType, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 在解除阻塞时将元素推入到 target 指定的键中</span></span><br><span class="line">    <span class="comment">// BRPOPLPUSH 命令时使用</span></span><br><span class="line">    c-&gt;bpop.target = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;bpop.numreplicas = <span class="number">0</span>;</span><br><span class="line">    c-&gt;bpop.reploffset = <span class="number">0</span>;</span><br><span class="line">    c-&gt;woff = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 进行事务时监视的键</span></span><br><span class="line">    c-&gt;watched_keys = listCreate();</span><br><span class="line">    <span class="comment">// 订阅的频道和模式</span></span><br><span class="line">    c-&gt;pubsub_channels = dictCreate(&amp;setDictType, <span class="literal">NULL</span>);</span><br><span class="line">    c-&gt;pubsub_patterns = listCreate();</span><br><span class="line">    c-&gt;peerid = <span class="literal">NULL</span>;</span><br><span class="line">    listSetFreeMethod(c-&gt;pubsub_patterns, decrRefCountVoid);</span><br><span class="line">    listSetMatchMethod(c-&gt;pubsub_patterns, listMatchObjects);</span><br><span class="line">    <span class="comment">// 如果不是伪客户端，那么添加到服务器的客户端链表中</span></span><br><span class="line">    <span class="keyword">if</span> (fd != <span class="number">-1</span>) listAddNodeTail(server.clients, c);</span><br><span class="line">    <span class="comment">// 初始化客户端的事务状态</span></span><br><span class="line">    initClientMultiState(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回客户端</span></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>分配空间</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redisClient *c = zmalloc(<span class="keyword">sizeof</span>(redisClient));</span><br></pre></td></tr></table></figure></li><li><p>当 fd 非 -1 时，创建带网络连接的客户端</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fd != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="comment">// 非阻塞</span></span><br><span class="line">    anetNonBlock(<span class="literal">NULL</span>, fd);</span><br><span class="line">    <span class="comment">// 禁用 Nagle 算法</span></span><br><span class="line">    anetEnableTcpNoDelay(<span class="literal">NULL</span>, fd);</span><br><span class="line">    <span class="comment">// 设置 keep alive</span></span><br><span class="line">    <span class="keyword">if</span> (server.tcpkeepalive)</span><br><span class="line">        anetKeepAlive(<span class="literal">NULL</span>, fd, server.tcpkeepalive);</span><br><span class="line">    <span class="comment">// 绑定读事件到事件 loop （开始接收命令请求）</span></span><br><span class="line">    <span class="keyword">if</span> (aeCreateFileEvent(server.el, fd, AE_READABLE,</span><br><span class="line">                          readQueryFromClient, c) == AE_ERR) &#123;</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        zfree(c);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>首先把 fd 设置为非阻塞</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">anetNonBlock(<span class="literal">NULL</span>, fd);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetNonBlock</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((flags = fcntl(fd, F_GETFL)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        anetSetError(err, <span class="string">"fcntl(F_GETFL): %s"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> ANET_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fcntl(fd, F_SETFL, flags | O_NONBLOCK) == <span class="number">-1</span>) &#123;</span><br><span class="line">        anetSetError(err, <span class="string">"fcntl(F_SETFL,O_NONBLOCK): %s"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> ANET_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ANET_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后禁用 Nagle 算法（TCP?IP 协议中的一种算法）</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anetEnableTcpNoDelay(<span class="literal">NULL</span>, fd);</span><br></pre></td></tr></table></figure></li><li><p>设置 tcp 的 keep-alive 参数</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.tcpkeepalive)</span><br><span class="line">    anetKeepAlive(<span class="literal">NULL</span>, fd, server.tcpkeepalive);</span><br></pre></td></tr></table></figure></li><li><p>最后绑定 EventLoop</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aeCreateFileEvent(server.el, fd, AE_READABLE,</span><br><span class="line">                      readQueryFromClient, c)</span><br></pre></td></tr></table></figure><p>  在这里设置了回调函数 readQueryFromClient</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 读取客户端的查询缓冲区内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readQueryFromClient</span><span class="params">(aeEventLoop *el, <span class="keyword">int</span> fd, <span class="keyword">void</span> *privdata, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    redisClient *c = (redisClient *) privdata;</span><br><span class="line">    <span class="keyword">int</span> nread, readlen;</span><br><span class="line">    <span class="keyword">size_t</span> qblen;</span><br><span class="line">    </span><br><span class="line">    REDIS_NOTUSED(el);</span><br><span class="line">    REDIS_NOTUSED(mask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置服务器的当前客户端</span></span><br><span class="line">    server.current_client = c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入长度（默认为 16 MB）</span></span><br><span class="line">    readlen = REDIS_IOBUF_LEN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;reqtype == REDIS_REQ_MULTIBULK &amp;&amp; c-&gt;multibulklen &amp;&amp; c-&gt;bulklen != <span class="number">-1</span></span><br><span class="line">        &amp;&amp; c-&gt;bulklen &gt;= REDIS_MBULK_BIG_ARG) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> remaining = (<span class="keyword">unsigned</span>) (c-&gt;bulklen + <span class="number">2</span>) - sdslen(c-&gt;querybuf);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; readlen) readlen = remaining;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取查询缓冲区当前内容的长度</span></span><br><span class="line">    <span class="comment">// 如果读取出现 short read ，那么可能会有内容滞留在读取缓冲区里面</span></span><br><span class="line">    <span class="comment">// 这些滞留内容也许不能完整构成一个符合协议的命令，</span></span><br><span class="line">    qblen = sdslen(c-&gt;querybuf);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果有需要，更新缓冲区内容长度的峰值（peak）</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;querybuf_peak &lt; qblen) c-&gt;querybuf_peak = qblen;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为查询缓冲区分配空间</span></span><br><span class="line">    c-&gt;querybuf = sdsMakeRoomFor(c-&gt;querybuf, readlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入内容到查询缓存</span></span><br><span class="line">    nread = <span class="built_in">read</span>(fd, c-&gt;querybuf + qblen, readlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入出错</span></span><br><span class="line">    <span class="keyword">if</span> (nread == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EAGAIN) &#123;</span><br><span class="line">            nread = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            redisLog(REDIS_VERBOSE, <span class="string">"Reading from client: %s"</span>, strerror(errno));</span><br><span class="line">            freeClient(c);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遇到 EOF</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123;</span><br><span class="line">        redisLog(REDIS_VERBOSE, <span class="string">"Client closed connection"</span>);</span><br><span class="line">        freeClient(c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nread) &#123;</span><br><span class="line">        <span class="comment">// 根据内容，更新查询缓冲区（SDS） free 和 len 属性</span></span><br><span class="line">        <span class="comment">// 并将 '\0' 正确地放到内容的最后</span></span><br><span class="line">        sdsIncrLen(c-&gt;querybuf, nread);</span><br><span class="line">        <span class="comment">// 记录服务器和客户端最后一次互动的时间</span></span><br><span class="line">        c-&gt;lastinteraction = server.unixtime;</span><br><span class="line">        <span class="comment">// 如果客户端是 master 的话，更新它的复制偏移量</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; REDIS_MASTER) c-&gt;reploff += nread;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 在 nread == -1 且 errno == EAGAIN 时运行</span></span><br><span class="line">        server.current_client = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询缓冲区长度超出服务器最大缓冲区长度</span></span><br><span class="line">    <span class="comment">// 清空缓冲区并释放客户端</span></span><br><span class="line">    <span class="keyword">if</span> (sdslen(c-&gt;querybuf) &gt; server.client_max_querybuf_len) &#123;</span><br><span class="line">        sds ci = catClientInfoString(sdsempty(), c), bytes = sdsempty();</span><br><span class="line"></span><br><span class="line">        bytes = sdscatrepr(bytes, c-&gt;querybuf, <span class="number">64</span>);</span><br><span class="line">        redisLog(REDIS_WARNING, <span class="string">"Closing client that reached max query buffer length: %s (qbuf initial bytes: %s)"</span>, ci, bytes);</span><br><span class="line"></span><br><span class="line">        sdsfree(ci);</span><br><span class="line">        sdsfree(bytes);</span><br><span class="line">        freeClient(c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从查询缓存重读取内容，创建参数，并执行命令</span></span><br><span class="line">    <span class="comment">// 函数会执行到缓存中的所有内容都被处理完为止</span></span><br><span class="line">    processInputBuffer(c);</span><br><span class="line"></span><br><span class="line">    server.current_client = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这个回调函数又包括了几个环节</p><ul><li><p>首先把数据读入 client 的缓存区</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">redisClient *c = (redisClient *) privdata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nread, readlen;</span><br><span class="line"><span class="keyword">size_t</span> qblen;</span><br><span class="line">REDIS_NOTUSED(el);</span><br><span class="line">REDIS_NOTUSED(mask);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置服务器的当前客户端</span></span><br><span class="line">server.current_client = c;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读入长度（默认为 16 MB）</span></span><br><span class="line">readlen = REDIS_IOBUF_LEN;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (c-&gt;reqtype == REDIS_REQ_MULTIBULK</span><br><span class="line">    &amp;&amp; c-&gt;multibulklen &amp;&amp; c-&gt;bulklen != <span class="number">-1</span></span><br><span class="line">    &amp;&amp; c-&gt;bulklen &gt;= REDIS_MBULK_BIG_ARG) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> remaining = (<span class="keyword">unsigned</span>) (c-&gt;bulklen + <span class="number">2</span>) - sdslen(c-&gt;querybuf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (remaining &lt; readlen) &#123;</span><br><span class="line">        readlen = remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取查询缓冲区当前内容的长度</span></span><br><span class="line"><span class="comment">// 如果读取出现 short read ，那么可能会有内容滞留在读取缓冲区里面</span></span><br><span class="line"><span class="comment">// 这些滞留内容也许不能完整构成一个符合协议的命令，</span></span><br><span class="line">qblen = sdslen(c-&gt;querybuf);</span><br><span class="line"><span class="comment">// 如果有需要，更新缓冲区内容长度的峰值（peak）</span></span><br><span class="line"><span class="keyword">if</span> (c-&gt;querybuf_peak &lt; qblen) &#123;</span><br><span class="line">    c-&gt;querybuf_peak = qblen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为查询缓冲区分配空间</span></span><br><span class="line">c-&gt;querybuf = sdsMakeRoomFor(c-&gt;querybuf, readlen);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读入内容到查询缓存</span></span><br><span class="line">nread = <span class="built_in">read</span>(fd, c-&gt;querybuf + qblen, readlen);</span><br></pre></td></tr></table></figure><p>  if (nread) {</p><pre><code>// 根据内容，更新查询缓冲区（SDS） free 和 len 属性// 并将 &apos;\0&apos; 正确地放到内容的最后sdsIncrLen(c-&gt;querybuf, nread);// 记录服务器和客户端最后一次互动的时间c-&gt;lastinteraction = server.unixtime;// 如果客户端是 master 的话，更新它的复制偏移量if (c-&gt;flags &amp; REDIS_MASTER) {    c-&gt;reploff += nread;}</code></pre><p>  } else {</p><pre><code>// 在 nread == -1 且 errno == EAGAIN 时运行server.current_client = NULL;return;</code></pre><p>  }</p></li><li><p>如果缓冲区内容长度超过限制，则关闭 client</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sdslen(c-&gt;querybuf) &gt; server.client_max_querybuf_len) &#123;</span><br><span class="line"></span><br><span class="line">    sds ci = catClientInfoString(sdsempty(), c), bytes = sdsempty();</span><br><span class="line"></span><br><span class="line">    bytes = sdscatrepr(bytes, c-&gt;querybuf, <span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">    redisLog(REDIS_WARNING, <span class="string">"Closing client that reached max query buffer length: %s (qbuf initial bytes: %s)"</span>, ci, bytes);</span><br><span class="line"></span><br><span class="line">    sdsfree(ci);</span><br><span class="line">    sdsfree(bytes);</span><br><span class="line"></span><br><span class="line">    freeClient(c);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>从查询缓存重读取内容，创建参数，并执行命令，函数会执行到缓存中的所有内容都被处理完为止</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">processInputBuffer(c);</span><br></pre></td></tr></table></figure><p>  processInputBuffer 函数也很长，里面关键的部分有两个：</p><ul><li><p>读 redisClient.buffer 的内容，解析成命令和命令参数</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">processInlineBuffer</span><br><span class="line"></span><br><span class="line">processMultibulkBuffer</span><br></pre></td></tr></table></figure></li><li><p>执行命令并重置客户端</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">processCommand</span><br><span class="line"></span><br><span class="line">resetClient</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ol><h3 id="void-acceptTcpHandler-aeEventLoop-el-int-fd-void-privdata-int-mask"><a href="#void-acceptTcpHandler-aeEventLoop-el-int-fd-void-privdata-int-mask" class="headerlink" title="void acceptTcpHandler(aeEventLoop *el, int fd, void *privdata, int mask)"></a>void acceptTcpHandler(aeEventLoop *el, int fd, void *privdata, int mask)</h3><pre><code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 创建一个 TCP 连接处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acceptTcpHandler</span><span class="params">(aeEventLoop *el, <span class="keyword">int</span> fd, <span class="keyword">void</span> *privdata, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cport, cfd, <span class="built_in">max</span> = MAX_ACCEPTS_PER_CALL;</span><br><span class="line">    <span class="keyword">char</span> cip[REDIS_IP_STR_LEN];</span><br><span class="line">    REDIS_NOTUSED(el);</span><br><span class="line">    REDIS_NOTUSED(mask);</span><br><span class="line">    REDIS_NOTUSED(privdata);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">max</span>--) &#123;</span><br><span class="line">        <span class="comment">// accept 客户端连接</span></span><br><span class="line">        cfd = anetTcpAccept(server.neterr, fd, cip, <span class="keyword">sizeof</span>(cip), &amp;cport);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cfd == ANET_ERR) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno != EWOULDBLOCK)</span><br><span class="line">                redisLog(REDIS_WARNING,</span><br><span class="line">                         <span class="string">"Accepting client connection: %s"</span>, server.neterr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        redisLog(REDIS_VERBOSE, <span class="string">"Accepted %s:%d"</span>, cip, cport);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为客户端创建客户端状态（redisClient）</span></span><br><span class="line">        acceptCommonHandler(cfd, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h3 id="static-void-acceptCommonHandler-int-fd-int-flags"><a href="#static-void-acceptCommonHandler-int-fd-int-flags" class="headerlink" title="static void acceptCommonHandler(int fd, int flags)"></a>static void acceptCommonHandler(int fd, int flags)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * TCP 连接 accept 处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ACCEPTS_PER_CALL 1000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">acceptCommonHandler</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建客户端</span></span><br><span class="line">    redisClient *c;</span><br><span class="line">    <span class="keyword">if</span> ((c = createClient(fd)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        redisLog(REDIS_WARNING,</span><br><span class="line">                 <span class="string">"Error registering fd event for the new client: %s (fd=%d)"</span>,</span><br><span class="line">                 strerror(errno), fd);</span><br><span class="line">        <span class="built_in">close</span>(fd); <span class="comment">/* May be already closed, just ignore errors */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If maxclient directive is set and this is one client more... close the</span></span><br><span class="line"><span class="comment">     * connection. Note that we create the client instead to check before</span></span><br><span class="line"><span class="comment">     * for this condition, since now the socket is already set in non-blocking</span></span><br><span class="line"><span class="comment">     * mode and we can send an error for free using the Kernel I/O */</span></span><br><span class="line">    <span class="comment">// 如果新添加的客户端令服务器的最大客户端数量达到了</span></span><br><span class="line">    <span class="comment">// 那么向新客户端写入错误信息，并关闭新客户端</span></span><br><span class="line">    <span class="comment">// 先创建客户端，再进行数量检查是为了方便地进行错误信息写入</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(server.clients) &gt; server.maxclients) &#123;</span><br><span class="line">        <span class="keyword">char</span> *err = <span class="string">"-ERR max number of clients reached\r\n"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* That's a best effort error message, don't check write errors */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">write</span>(c-&gt;fd, err, <span class="built_in">strlen</span>(err)) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">/* Nothing to do, Just to avoid the warning... */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新拒绝连接数</span></span><br><span class="line">        server.stat_rejected_conn++;</span><br><span class="line">        freeClient(c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新连接次数</span></span><br><span class="line">    server.stat_numconnections++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 FLAG</span></span><br><span class="line">    c-&gt;flags |= flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面的重点在于 createClient，现在应该 accept 出了一个 fd，用这个 fd 来创建 redisClient</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Redis 的网络连接库，负责发送命令回复和接受命令请求， 同时也负责创建/销毁客户端， 以及通信协议分析等工作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%e6%b6%89%e5%8f%8a%e6%96%87%e4%bb%b6&quot;&gt;涉及文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="开源组件" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/"/>
    
      <category term="Redis" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/"/>
    
      <category term="源码阅读" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
      <category term="C" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Redis 源码阅读9_客户端和服务器_ae</title>
    <link href="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB9_%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8_ae/"/>
    <id>http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB9_%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8_ae/</id>
    <published>2020-03-11T12:25:46.319Z</published>
    <updated>2020-03-11T12:26:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 的事件处理器实现（基于 Reactor 模式）。</p><ul><li><a href="#%e6%b6%89%e5%8f%8a%e6%96%87%e4%bb%b6">涉及文件</a></li><li><a href="#%e7%bb%93%e6%9e%84%e4%bd%93">结构体</a><ul><li><a href="#aefileevent-%e6%96%87%e4%bb%b6%e4%ba%8b%e4%bb%b6">aeFileEvent 文件事件</a></li><li><a href="#aetimeevent-%e6%97%b6%e9%97%b4%e4%ba%8b%e4%bb%b6">aeTimeEvent 时间事件</a></li><li><a href="#aefiredevent-%e5%b7%b2%e5%b0%b1%e7%bb%aa%e4%ba%8b%e4%bb%b6">aeFiredEvent 已就绪事件</a></li><li><a href="#aeeventloop-%e4%ba%8b%e4%bb%b6%e5%a4%84%e7%90%86%e5%99%a8%e7%9a%84%e7%8a%b6%e6%80%81">aeEventLoop 事件处理器的状态</a></li><li><a href="#%e4%ba%8b%e4%bb%b6%e5%a4%84%e7%90%86%e5%99%a8%e6%8e%a5%e5%8f%a3">事件处理器接口</a></li></ul></li><li><a href="#api">API</a><ul><li><a href="#aeeventloop-aecreateeventloopint-setsize">aeEventLoop *aeCreateEventLoop(int setsize);</a></li><li><a href="#void-aedeleteeventloopaeeventloop-eventloop">void aeDeleteEventLoop(aeEventLoop *eventLoop)</a></li><li><a href="#void-aestopaeeventloop-eventloop">void aeStop(aeEventLoop *eventLoop)</a></li><li><a href="#int-aecreatefileeventaeeventloop-eventloop-int-fd-int-mask-aefileproc-proc-void-clientdata">int aeCreateFileEvent(aeEventLoop *eventLoop, int fd, int mask, aeFileProc *proc, void *clientData)</a></li><li><a href="#long-long-aecreatetimeeventaeeventloop-eventloop-long-long-milliseconds-aetimeproc-proc-void-clientdata-aeeventfinalizerproc-finalizerproc">long long aeCreateTimeEvent(aeEventLoop *eventLoop, long long milliseconds, aeTimeProc *proc, void *clientData, aeEventFinalizerProc *finalizerProc);</a></li><li><a href="#void-aemainaeeventloop-eventloop">void aeMain(aeEventLoop *eventLoop)</a></li></ul></li></ul><h2 id="涉及文件"><a href="#涉及文件" class="headerlink" title="涉及文件"></a>涉及文件</h2><p><code>ae.h</code></p><p><code>ae.c</code></p><p><code>ae_epoll.c</code></p><p><code>ae_evport.c</code></p><p><code>ae_kqueue.c</code></p><p><code>ae_select.c</code></p><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="aeFileEvent-文件事件"><a href="#aeFileEvent-文件事件" class="headerlink" title="aeFileEvent 文件事件"></a>aeFileEvent 文件事件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* File event structure</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 文件事件结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeFileEvent</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听事件类型掩码，</span></span><br><span class="line">    <span class="comment">// 值可以是 AE_READABLE 或 AE_WRITABLE ，</span></span><br><span class="line">    <span class="comment">// 或者 AE_READABLE | AE_WRITABLE</span></span><br><span class="line">    <span class="keyword">int</span> mask; <span class="comment">/* one of AE_(READABLE|WRITABLE) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读事件处理器</span></span><br><span class="line">    aeFileProc *rfileProc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写事件处理器</span></span><br><span class="line">    aeFileProc *wfileProc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多路复用库的私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *clientData;</span><br><span class="line"></span><br><span class="line">&#125; aeFileEvent;</span><br></pre></td></tr></table></figure><h3 id="aeTimeEvent-时间事件"><a href="#aeTimeEvent-时间事件" class="headerlink" title="aeTimeEvent 时间事件"></a>aeTimeEvent 时间事件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Time event structure</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 时间事件结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeTimeEvent</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时间事件的唯一标识符</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> id; <span class="comment">/* time event identifier. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件的到达时间</span></span><br><span class="line">    <span class="keyword">long</span> when_sec; <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="keyword">long</span> when_ms; <span class="comment">/* milliseconds */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件处理函数</span></span><br><span class="line">    aeTimeProc *timeProc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件释放函数</span></span><br><span class="line">    aeEventFinalizerProc *finalizerProc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多路复用库的私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *clientData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向下个时间事件结构，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">aeTimeEvent</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">&#125; aeTimeEvent;</span><br></pre></td></tr></table></figure><h3 id="aeFiredEvent-已就绪事件"><a href="#aeFiredEvent-已就绪事件" class="headerlink" title="aeFiredEvent 已就绪事件"></a>aeFiredEvent 已就绪事件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* A fired event</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 已就绪事件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeFiredEvent</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已就绪文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件类型掩码，</span></span><br><span class="line">    <span class="comment">// 值可以是 AE_READABLE 或 AE_WRITABLE</span></span><br><span class="line">    <span class="comment">// 或者是两者的或</span></span><br><span class="line">    <span class="keyword">int</span> mask;</span><br><span class="line"></span><br><span class="line">&#125; aeFiredEvent;</span><br></pre></td></tr></table></figure><h3 id="aeEventLoop-事件处理器的状态"><a href="#aeEventLoop-事件处理器的状态" class="headerlink" title="aeEventLoop 事件处理器的状态"></a>aeEventLoop 事件处理器的状态</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* State of an event based program </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 事件处理器的状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeEventLoop</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目前已注册的最大描述符</span></span><br><span class="line">    <span class="keyword">int</span> maxfd;   <span class="comment">/* highest file descriptor currently registered */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目前已追踪的最大描述符</span></span><br><span class="line">    <span class="keyword">int</span> setsize; <span class="comment">/* max number of file descriptors tracked */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于生成时间事件 id</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> timeEventNextId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一次执行时间事件的时间</span></span><br><span class="line">    <span class="keyword">time_t</span> lastTime;     <span class="comment">/* Used to detect system clock skew */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已注册的文件事件</span></span><br><span class="line">    aeFileEvent *events; <span class="comment">/* Registered events */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已就绪的文件事件</span></span><br><span class="line">    aeFiredEvent *fired; <span class="comment">/* Fired events */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时间事件</span></span><br><span class="line">    aeTimeEvent *timeEventHead;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件处理器的开关</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">stop</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多路复用库的私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *apidata; <span class="comment">/* This is used for polling API specific data */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在处理事件前要执行的函数</span></span><br><span class="line">    aeBeforeSleepProc *beforesleep;</span><br><span class="line"></span><br><span class="line">&#125; aeEventLoop;</span><br></pre></td></tr></table></figure><h3 id="事件处理器接口"><a href="#事件处理器接口" class="headerlink" title="事件处理器接口"></a>事件处理器接口</h3><ul><li><p>typedef void aeFileProc(struct aeEventLoop *eventLoop, int fd, void *clientData, int mask);</p></li><li><p>typedef int aeTimeProc(struct aeEventLoop *eventLoop, long long id, void *clientData);</p></li><li><p>typedef void aeEventFinalizerProc(struct aeEventLoop *eventLoop, void *clientData);</p></li><li><p>typedef void aeBeforeSleepProc(struct aeEventLoop *eventLoop);</p></li></ul><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>aeEventLoop *aeCreateEventLoop(int setsize);</p><p>void aeDeleteEventLoop(aeEventLoop *eventLoop);</p><p>void aeStop(aeEventLoop *eventLoop);</p><p>int aeCreateFileEvent(aeEventLoop *eventLoop, int fd, int mask,<br>                      aeFileProc *proc, void *clientData);</p><p>void aeDeleteFileEvent(aeEventLoop *eventLoop, int fd, int mask);</p><p>int aeGetFileEvents(aeEventLoop *eventLoop, int fd);</p><p>long long aeCreateTimeEvent(aeEventLoop *eventLoop, long long milliseconds,<br>                            aeTimeProc *proc, void *clientData,<br>                            aeEventFinalizerProc *finalizerProc);</p><p>int aeDeleteTimeEvent(aeEventLoop *eventLoop, long long id);</p><p>int aeProcessEvents(aeEventLoop *eventLoop, int flags);</p><p>int aeWait(int fd, int mask, long long milliseconds);</p><p>void aeMain(aeEventLoop *eventLoop);</p><p>char *aeGetApiName(void);</p><p>void aeSetBeforeSleepProc(aeEventLoop *eventLoop, aeBeforeSleepProc *beforesleep);</p><p>int aeGetSetSize(aeEventLoop *eventLoop);</p><p>int aeResizeSetSize(aeEventLoop *eventLoop, int setsize);</p><h3 id="aeEventLoop-aeCreateEventLoop-int-setsize"><a href="#aeEventLoop-aeCreateEventLoop-int-setsize" class="headerlink" title="aeEventLoop *aeCreateEventLoop(int setsize);"></a>aeEventLoop *aeCreateEventLoop(int setsize);</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 初始化事件处理器状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">aeEventLoop *<span class="title">aeCreateEventLoop</span><span class="params">(<span class="keyword">int</span> setsize)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    aeEventLoop *eventLoop;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建事件状态结构</span></span><br><span class="line">    <span class="keyword">if</span> ((eventLoop = zmalloc(<span class="keyword">sizeof</span>(*eventLoop))) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化文件事件结构和已就绪文件事件结构数组</span></span><br><span class="line">    eventLoop-&gt;events = zmalloc(<span class="keyword">sizeof</span>(aeFileEvent) * setsize);</span><br><span class="line">    eventLoop-&gt;fired = zmalloc(<span class="keyword">sizeof</span>(aeFiredEvent) * setsize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eventLoop-&gt;events == <span class="literal">NULL</span> || eventLoop-&gt;fired == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置数组大小</span></span><br><span class="line">    eventLoop-&gt;setsize = setsize;</span><br><span class="line">    <span class="comment">// 初始化执行最近一次执行时间</span></span><br><span class="line">    eventLoop-&gt;lastTime = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化时间事件结构</span></span><br><span class="line">    eventLoop-&gt;timeEventHead = <span class="literal">NULL</span>;</span><br><span class="line">    eventLoop-&gt;timeEventNextId = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    eventLoop-&gt;<span class="built_in">stop</span> = <span class="number">0</span>;</span><br><span class="line">    eventLoop-&gt;maxfd = <span class="number">-1</span>;</span><br><span class="line">    eventLoop-&gt;beforesleep = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (aeApiCreate(eventLoop) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Events with mask == AE_NONE are not set. So let's initialize the</span></span><br><span class="line"><span class="comment">     * vector with it. */</span></span><br><span class="line">    <span class="comment">// 初始化监听事件</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; setsize; i++) &#123;</span><br><span class="line">        eventLoop-&gt;events[i].mask = AE_NONE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回事件循环</span></span><br><span class="line">    <span class="keyword">return</span> eventLoop;</span><br><span class="line"></span><br><span class="line">    err:</span><br><span class="line">    <span class="keyword">if</span> (eventLoop) &#123;</span><br><span class="line">        zfree(eventLoop-&gt;events);</span><br><span class="line">        zfree(eventLoop-&gt;fired);</span><br><span class="line">        zfree(eventLoop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>首先是创建 aeEventLoop 对象，然后各种设置属性参数</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">aeEventLoop *eventLoop;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建事件状态结构</span></span><br><span class="line"><span class="keyword">if</span> ((eventLoop = zmalloc(<span class="keyword">sizeof</span>(*eventLoop))) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化文件事件结构和已就绪文件事件结构数组</span></span><br><span class="line">eventLoop-&gt;events = zmalloc(<span class="keyword">sizeof</span>(aeFileEvent) * setsize);</span><br><span class="line">eventLoop-&gt;fired = zmalloc(<span class="keyword">sizeof</span>(aeFiredEvent) * setsize);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (eventLoop-&gt;events == <span class="literal">NULL</span> || eventLoop-&gt;fired == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置数组大小</span></span><br><span class="line">eventLoop-&gt;setsize = setsize;</span><br><span class="line"><span class="comment">// 初始化执行最近一次执行时间</span></span><br><span class="line">eventLoop-&gt;lastTime = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化时间事件结构</span></span><br><span class="line">eventLoop-&gt;timeEventHead = <span class="literal">NULL</span>;</span><br><span class="line">eventLoop-&gt;timeEventNextId = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">eventLoop-&gt;<span class="built_in">stop</span> = <span class="number">0</span>;</span><br><span class="line">eventLoop-&gt;maxfd = <span class="number">-1</span>;</span><br><span class="line">eventLoop-&gt;beforesleep = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化监听事件</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; setsize; i++) &#123;</span><br><span class="line">    eventLoop-&gt;events[i].mask = AE_NONE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后进行各种底层 IO 多路复用库的初始化</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (aeApiCreate(eventLoop) == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 到底使用了哪种 IO 多路复用库，取决于系统有啥和 include 顺序</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_EVPORT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ae_evport.c"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_EPOLL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ae_epoll.c"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_KQUEUE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ae_kqueue.c"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ae_select.c"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p> 以 epoll 为例，</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 事件状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeApiState</span> &#123;</span></span><br><span class="line">    <span class="comment">// epoll_event 实例描述符</span></span><br><span class="line">    <span class="keyword">int</span> epfd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件槽</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">events</span>;</span></span><br><span class="line">&#125; aeApiState;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建一个新的 epoll 实例，并将它赋值给 eventLoop</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiCreate</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    aeApiState *state = zmalloc(<span class="keyword">sizeof</span>(aeApiState));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!state) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化事件槽空间</span></span><br><span class="line">    state-&gt;events = zmalloc(<span class="keyword">sizeof</span>(struct epoll_event) * eventLoop-&gt;setsize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!state-&gt;events) &#123;</span><br><span class="line">        zfree(state);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 epoll 实例</span></span><br><span class="line">    state-&gt;epfd = epoll_create(<span class="number">1024</span>); <span class="comment">/* 1024 is just a hint for the kernel */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (state-&gt;epfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        zfree(state-&gt;events);</span><br><span class="line">        zfree(state);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值给 eventLoop</span></span><br><span class="line">    eventLoop-&gt;apidata = state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 初始化以后，把 state 赋值给 eventLoop 的 apidata</p></li></ol><h3 id="void-aeDeleteEventLoop-aeEventLoop-eventLoop"><a href="#void-aeDeleteEventLoop-aeEventLoop-eventLoop" class="headerlink" title="void aeDeleteEventLoop(aeEventLoop *eventLoop)"></a>void aeDeleteEventLoop(aeEventLoop *eventLoop)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 删除事件处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeDeleteEventLoop</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    aeApiFree(eventLoop);</span><br><span class="line">    zfree(eventLoop-&gt;events);</span><br><span class="line">    zfree(eventLoop-&gt;fired);</span><br><span class="line">    zfree(eventLoop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以 epoll 为例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 释放 epoll 实例和事件槽</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">aeApiFree</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    aeApiState *state = eventLoop-&gt;apidata;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(state-&gt;epfd);</span><br><span class="line">    zfree(state-&gt;events);</span><br><span class="line">    zfree(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="void-aeStop-aeEventLoop-eventLoop"><a href="#void-aeStop-aeEventLoop-eventLoop" class="headerlink" title="void aeStop(aeEventLoop *eventLoop)"></a>void aeStop(aeEventLoop *eventLoop)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 停止事件处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeStop</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    eventLoop-&gt;<span class="built_in">stop</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="int-aeCreateFileEvent-aeEventLoop-eventLoop-int-fd-int-mask-aeFileProc-proc-void-clientData"><a href="#int-aeCreateFileEvent-aeEventLoop-eventLoop-int-fd-int-mask-aeFileProc-proc-void-clientData" class="headerlink" title="int aeCreateFileEvent(aeEventLoop *eventLoop, int fd, int mask, aeFileProc *proc, void *clientData)"></a>int aeCreateFileEvent(aeEventLoop *eventLoop, int fd, int mask, aeFileProc *proc, void *clientData)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 根据 mask 参数的值，监听 fd 文件的状态，</span></span><br><span class="line"><span class="comment"> * 当 fd 可用时，执行 proc 函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeCreateFileEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> mask,</span></span></span><br><span class="line"><span class="function"><span class="params">                      aeFileProc *proc, <span class="keyword">void</span> *clientData)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= eventLoop-&gt;setsize) &#123;</span><br><span class="line">        errno = ERANGE;</span><br><span class="line">        <span class="keyword">return</span> AE_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出文件事件结构</span></span><br><span class="line">    aeFileEvent *fe = &amp;eventLoop-&gt;events[fd];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听指定 fd 的指定事件</span></span><br><span class="line">    <span class="keyword">if</span> (aeApiAddEvent(eventLoop, fd, mask) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> AE_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置文件事件类型，以及事件的处理器</span></span><br><span class="line">    fe-&gt;mask |= mask;</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_READABLE) &#123;</span><br><span class="line">        fe-&gt;rfileProc = proc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_WRITABLE) &#123;</span><br><span class="line">        fe-&gt;wfileProc = proc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    fe-&gt;clientData = clientData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有需要，更新事件处理器的最大 fd</span></span><br><span class="line">    <span class="keyword">if</span> (fd &gt; eventLoop-&gt;maxfd) &#123;</span><br><span class="line">        eventLoop-&gt;maxfd = fd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> AE_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的目标是创建文件事件，具体要交给底层的 IO 多路复用组件，还是以 epoll 为例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 关联给定事件到 fd</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiAddEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    aeApiState *state = eventLoop-&gt;apidata;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ee</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the fd was already monitored for some event, we need a MOD</span></span><br><span class="line"><span class="comment">     * operation. Otherwise we need an ADD operation. </span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果 fd 没有关联任何事件，那么这是一个 ADD 操作。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果已经关联了某个/某些事件，那么这是一个 MOD 操作。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> op = eventLoop-&gt;events[fd].mask == AE_NONE ?</span><br><span class="line">             EPOLL_CTL_ADD : EPOLL_CTL_MOD;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册事件到 epoll</span></span><br><span class="line">    ee.events = <span class="number">0</span>;</span><br><span class="line">    mask |= eventLoop-&gt;events[fd].mask; <span class="comment">/* Merge old events */</span></span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_READABLE) &#123;</span><br><span class="line">        ee.events |= EPOLLIN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_WRITABLE) &#123;</span><br><span class="line">        ee.events |= EPOLLOUT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ee.data.u64 = <span class="number">0</span>; <span class="comment">/* avoid valgrind warning */</span></span><br><span class="line">    ee.data.fd = fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(state-&gt;epfd, op, fd, &amp;ee) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本思路是设置好各种 epoll 的参数，然后调用 epoll_ctl 向 epoll 添加文件事件</p><h3 id="long-long-aeCreateTimeEvent-aeEventLoop-eventLoop-long-long-milliseconds-aeTimeProc-proc-void-clientData-aeEventFinalizerProc-finalizerProc"><a href="#long-long-aeCreateTimeEvent-aeEventLoop-eventLoop-long-long-milliseconds-aeTimeProc-proc-void-clientData-aeEventFinalizerProc-finalizerProc" class="headerlink" title="long long aeCreateTimeEvent(aeEventLoop *eventLoop, long long milliseconds, aeTimeProc *proc, void *clientData, aeEventFinalizerProc *finalizerProc);"></a>long long aeCreateTimeEvent(aeEventLoop *eventLoop, long long milliseconds, aeTimeProc *proc, void *clientData, aeEventFinalizerProc *finalizerProc);</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建时间事件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">aeCreateTimeEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">long</span> <span class="keyword">long</span> milliseconds, aeTimeProc *proc, <span class="keyword">void</span> *clientData, aeEventFinalizerProc *finalizerProc)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新时间计数器</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> id = eventLoop-&gt;timeEventNextId++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建时间事件结构</span></span><br><span class="line">    aeTimeEvent *te;</span><br><span class="line"></span><br><span class="line">    te = zmalloc(<span class="keyword">sizeof</span>(*te));</span><br><span class="line">    <span class="keyword">if</span> (te == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> AE_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 ID</span></span><br><span class="line">    te-&gt;id = id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定处理事件的时间</span></span><br><span class="line">    aeAddMillisecondsToNow(milliseconds, &amp;te-&gt;when_sec, &amp;te-&gt;when_ms);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置事件处理器</span></span><br><span class="line">    te-&gt;timeProc = proc;</span><br><span class="line">    te-&gt;finalizerProc = finalizerProc;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置私有数据</span></span><br><span class="line">    te-&gt;clientData = clientData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将新事件放入表头</span></span><br><span class="line">    te-&gt;next = eventLoop-&gt;timeEventHead;</span><br><span class="line">    eventLoop-&gt;timeEventHead = te;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在当前时间上加上 milliseconds 毫秒，</span></span><br><span class="line"><span class="comment"> * 并且将加上之后的秒数和毫秒数分别保存在 sec 和 ms 指针中。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">aeAddMillisecondsToNow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> milliseconds, <span class="keyword">long</span> *sec, <span class="keyword">long</span> *ms)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> cur_sec, cur_ms, when_sec, when_ms;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前时间</span></span><br><span class="line">    aeGetTime(&amp;cur_sec, &amp;cur_ms);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算增加 milliseconds 之后的秒数和毫秒数</span></span><br><span class="line">    when_sec = cur_sec + milliseconds / <span class="number">1000</span>;</span><br><span class="line">    when_ms = cur_ms + milliseconds % <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进位：</span></span><br><span class="line">    <span class="comment">// 如果 when_ms 大于等于 1000</span></span><br><span class="line">    <span class="comment">// 那么将 when_sec 增大一秒</span></span><br><span class="line">    <span class="keyword">if</span> (when_ms &gt;= <span class="number">1000</span>) &#123;</span><br><span class="line">        when_sec++;</span><br><span class="line">        when_ms -= <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存到指针中</span></span><br><span class="line">    *sec = when_sec;</span><br><span class="line">    *ms = when_ms;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本逻辑是设置各种事件处理器、参数等，然后获取时间用于定时。时间事件是一个链表。</p><h3 id="void-aeMain-aeEventLoop-eventLoop"><a href="#void-aeMain-aeEventLoop-eventLoop" class="headerlink" title="void aeMain(aeEventLoop *eventLoop)"></a>void aeMain(aeEventLoop *eventLoop)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 事件处理器的主循环</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    eventLoop-&gt;<span class="built_in">stop</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!eventLoop-&gt;<span class="built_in">stop</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有需要在事件处理前执行的函数，那么运行它</span></span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;beforesleep != <span class="literal">NULL</span>)</span><br><span class="line">            eventLoop-&gt;beforesleep(eventLoop);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始处理事件</span></span><br><span class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个 while 循环，会一直进行下去。每次循环先执行注册好的 beforesleep 方法，然后开始处理事件 aeProcessEvents,参数是全部事件 AE_ALL_EVENTS。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Process every pending time event, then every pending file event</span></span><br><span class="line"><span class="comment"> * (that may be registered by time event callbacks just processed).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 处理所有已到达的时间事件，以及所有已就绪的文件事件。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Without special flags the function sleeps until some file event</span></span><br><span class="line"><span class="comment"> * fires, or when the next time event occurs (if any).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果不传入特殊 flags 的话，那么函数睡眠直到文件事件就绪，</span></span><br><span class="line"><span class="comment"> * 或者下个时间事件到达（如果有的话）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If flags is 0, the function does nothing and returns.</span></span><br><span class="line"><span class="comment"> * 如果 flags 为 0 ，那么函数不作动作，直接返回。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * if flags has AE_ALL_EVENTS set, all the kind of events are processed.</span></span><br><span class="line"><span class="comment"> * 如果 flags 包含 AE_ALL_EVENTS ，所有类型的事件都会被处理。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * if flags has AE_FILE_EVENTS set, file events are processed.</span></span><br><span class="line"><span class="comment"> * 如果 flags 包含 AE_FILE_EVENTS ，那么处理文件事件。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * if flags has AE_TIME_EVENTS set, time events are processed.</span></span><br><span class="line"><span class="comment"> * 如果 flags 包含 AE_TIME_EVENTS ，那么处理时间事件。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * if flags has AE_DONT_WAIT set the function returns ASAP until all</span></span><br><span class="line"><span class="comment"> * the events that's possible to process without to wait are processed.</span></span><br><span class="line"><span class="comment"> * 如果 flags 包含 AE_DONT_WAIT ，</span></span><br><span class="line"><span class="comment"> * 那么函数在处理完所有不许阻塞的事件之后，即刻返回。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function returns the number of events processed. </span></span><br><span class="line"><span class="comment"> * 函数的返回值为已处理事件的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeProcessEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> processed = <span class="number">0</span>, numevents;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Nothing to do? return ASAP */</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_FILE_EVENTS)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Note that we want call select() even if there are no</span></span><br><span class="line"><span class="comment">     * file events to process as long as we want to process time</span></span><br><span class="line"><span class="comment">     * events, in order to sleep until the next time event is ready</span></span><br><span class="line"><span class="comment">     * to fire. */</span></span><br><span class="line">    <span class="keyword">if</span> (eventLoop-&gt;maxfd != <span class="number">-1</span> ||</span><br><span class="line">        ((flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_DONT_WAIT))) &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        aeTimeEvent *shortest = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>, *<span class="title">tvp</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取最近的时间事件</span></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS &amp;&amp; !(flags &amp; AE_DONT_WAIT))</span><br><span class="line">            shortest = aeSearchNearestTimer(eventLoop);</span><br><span class="line">        <span class="keyword">if</span> (shortest) &#123;</span><br><span class="line">            <span class="comment">// 如果时间事件存在的话</span></span><br><span class="line">            <span class="comment">// 那么根据最近可执行时间事件和现在时间的时间差来决定文件事件的阻塞时间</span></span><br><span class="line">            <span class="keyword">long</span> now_sec, now_ms;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Calculate the time missing for the nearest</span></span><br><span class="line"><span class="comment">             * timer to fire. */</span></span><br><span class="line">            <span class="comment">// 计算距今最近的时间事件还要多久才能达到</span></span><br><span class="line">            <span class="comment">// 并将该时间距保存在 tv 结构中</span></span><br><span class="line">            aeGetTime(&amp;now_sec, &amp;now_ms);</span><br><span class="line">            tvp = &amp;tv;</span><br><span class="line">            tvp-&gt;tv_sec = shortest-&gt;when_sec - now_sec;</span><br><span class="line">            <span class="keyword">if</span> (shortest-&gt;when_ms &lt; now_ms) &#123;</span><br><span class="line">                tvp-&gt;tv_usec = ((shortest-&gt;when_ms + <span class="number">1000</span>) - now_ms) * <span class="number">1000</span>;</span><br><span class="line">                tvp-&gt;tv_sec--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tvp-&gt;tv_usec = (shortest-&gt;when_ms - now_ms) * <span class="number">1000</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 时间差小于 0 ，说明事件已经可以执行了，将秒和毫秒设为 0 （不阻塞）</span></span><br><span class="line">            <span class="keyword">if</span> (tvp-&gt;tv_sec &lt; <span class="number">0</span>) tvp-&gt;tv_sec = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (tvp-&gt;tv_usec &lt; <span class="number">0</span>) tvp-&gt;tv_usec = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行到这一步，说明没有时间事件</span></span><br><span class="line">            <span class="comment">// 那么根据 AE_DONT_WAIT 是否设置来决定是否阻塞，以及阻塞的时间长度</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If we have to check for events but need to return</span></span><br><span class="line"><span class="comment">             * ASAP because of AE_DONT_WAIT we need to set the timeout</span></span><br><span class="line"><span class="comment">             * to zero */</span></span><br><span class="line">            <span class="keyword">if</span> (flags &amp; AE_DONT_WAIT) &#123;</span><br><span class="line">                <span class="comment">// 设置文件事件不阻塞</span></span><br><span class="line">                tv.tv_sec = tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">                tvp = &amp;tv;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* Otherwise we can block */</span></span><br><span class="line">                <span class="comment">// 文件事件可以阻塞直到有事件到达为止</span></span><br><span class="line">                tvp = <span class="literal">NULL</span>; <span class="comment">/* wait forever */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理文件事件，阻塞时间由 tvp 决定</span></span><br><span class="line">        numevents = aeApiPoll(eventLoop, tvp);</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</span><br><span class="line">            <span class="comment">// 从已就绪数组中获取事件</span></span><br><span class="line">            aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> mask = eventLoop-&gt;fired[j].mask;</span><br><span class="line">            <span class="keyword">int</span> fd = eventLoop-&gt;fired[j].fd;</span><br><span class="line">            <span class="keyword">int</span> rfired = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* note the fe-&gt;mask &amp; mask &amp; ... code: maybe an already processed</span></span><br><span class="line"><span class="comment">              * event removed an element that fired and we still didn't</span></span><br><span class="line"><span class="comment">              * processed, so we check if the event is still valid. */</span></span><br><span class="line">            <span class="comment">// 读事件</span></span><br><span class="line">            <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</span><br><span class="line">                <span class="comment">// rfired 确保读/写事件只能执行其中一个</span></span><br><span class="line">                rfired = <span class="number">1</span>;</span><br><span class="line">                fe-&gt;rfileProc(eventLoop, fd, fe-&gt;clientData, mask);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 写事件</span></span><br><span class="line">            <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!rfired || fe-&gt;wfileProc != fe-&gt;rfileProc)</span><br><span class="line">                    fe-&gt;wfileProc(eventLoop, fd, fe-&gt;clientData, mask);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            processed++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check time events */</span></span><br><span class="line">    <span class="comment">// 执行时间事件</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS)</span><br><span class="line">        processed += processTimeEvents(eventLoop);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> processed; <span class="comment">/* return the number of processed file/time events */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>首先获取最近的时间事件</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取最近的时间事件</span></span><br><span class="line"><span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS &amp;&amp; !(flags &amp; AE_DONT_WAIT)) &#123;</span><br><span class="line">    shortest = aeSearchNearestTimer(eventLoop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找里目前时间最近的时间事件</span></span><br><span class="line"><span class="comment">// 因为链表是乱序的，所以查找复杂度为 O（N）</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> aeTimeEvent *<span class="title">aeSearchNearestTimer</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    aeTimeEvent *te = eventLoop-&gt;timeEventHead;</span><br><span class="line">    aeTimeEvent *nearest = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (te) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!nearest || te-&gt;when_sec &lt; nearest-&gt;when_sec ||</span><br><span class="line">            (te-&gt;when_sec == nearest-&gt;when_sec &amp;&amp;</span><br><span class="line">             te-&gt;when_ms &lt; nearest-&gt;when_ms))</span><br><span class="line">            nearest = te;</span><br><span class="line">        te = te-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nearest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 具体做法是从 eventLoop 的 timeEventHead 链表中遍历找最小值</p></li><li><p>接下来设置文件事件的阻塞时间，一共有 3 种情况</p><ul><li>0：时间事件已经到达，不阻塞</li><li>n：根据时间事件的到时时间设置一个大于 0 的值</li><li>null：无限制阻塞</li></ul></li><li><p>然后等待文件事件</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理文件事件，阻塞时间由 tvp 决定</span></span><br><span class="line">numevents = aeApiPoll(eventLoop, tvp);</span><br></pre></td></tr></table></figure><p> 还是以 epoll 为例</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取可执行事件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiPoll</span><span class="params">(aeEventLoop *eventLoop, struct timeval *tvp)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    aeApiState *state = eventLoop-&gt;apidata;</span><br><span class="line">    <span class="keyword">int</span> retval, numevents = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待时间</span></span><br><span class="line">    retval = epoll_wait(state-&gt;epfd, state-&gt;events, eventLoop-&gt;setsize,</span><br><span class="line">                        tvp ? (tvp-&gt;tv_sec * <span class="number">1000</span> + tvp-&gt;tv_usec / <span class="number">1000</span>) : <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有至少一个事件就绪？</span></span><br><span class="line">    <span class="keyword">if</span> (retval &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为已就绪事件设置相应的模式</span></span><br><span class="line">        <span class="comment">// 并加入到 eventLoop 的 fired 数组中</span></span><br><span class="line">    </span><br><span class="line">        numevents = retval;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">e</span> = <span class="title">state</span>-&gt;<span class="title">events</span> + <span class="title">j</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLIN) mask |= AE_READABLE;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLOUT) mask |= AE_WRITABLE;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLERR) mask |= AE_WRITABLE;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLHUP) mask |= AE_WRITABLE;</span><br><span class="line"></span><br><span class="line">            eventLoop-&gt;fired[j].fd = e-&gt;data.fd;</span><br><span class="line">            eventLoop-&gt;fired[j].mask = mask;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回已就绪事件个数</span></span><br><span class="line">    <span class="keyword">return</span> numevents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 底层是 epoll_wait 方法，用于阻塞一段时间，返回事件个数。然后把各种 fd、type 设置好以后返回</p></li><li><p>接下来处理文件事件</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</span><br><span class="line">    <span class="comment">// 从已就绪数组中获取事件</span></span><br><span class="line">    aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mask = eventLoop-&gt;fired[j].mask;</span><br><span class="line">    <span class="keyword">int</span> fd = eventLoop-&gt;fired[j].fd;</span><br><span class="line">    <span class="keyword">int</span> rfired = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读事件</span></span><br><span class="line">    <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</span><br><span class="line">        <span class="comment">// rfired 确保读/写事件只能执行其中一个</span></span><br><span class="line">        rfired = <span class="number">1</span>;</span><br><span class="line">        fe-&gt;rfileProc(eventLoop, fd, fe-&gt;clientData, mask);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写事件</span></span><br><span class="line">    <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!rfired || fe-&gt;wfileProc != fe-&gt;rfileProc)</span><br><span class="line">            fe-&gt;wfileProc(eventLoop, fd, fe-&gt;clientData, mask);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    processed++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 由于到底哪些 fd 被触发已经知道了，所以依次取，事件处理器交给注册好的 CallBack，同一 fd 的读写事件只处理读的</p></li><li><p>最后处理时间事件</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS) &#123;</span><br><span class="line">    processed += processTimeEvents(eventLoop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理所有已到达的时间事件</span></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">processTimeEvents</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> processed = <span class="number">0</span>;</span><br><span class="line">    aeTimeEvent *te;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> maxId;</span><br><span class="line">    <span class="keyword">time_t</span> now = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过重置事件的运行时间，防止因时间穿插（skew）而造成的事件处理混乱</span></span><br><span class="line">    <span class="keyword">if</span> (now &lt; eventLoop-&gt;lastTime) &#123;</span><br><span class="line">        te = eventLoop-&gt;timeEventHead;</span><br><span class="line">        <span class="keyword">while</span> (te) &#123;</span><br><span class="line">            te-&gt;when_sec = <span class="number">0</span>;</span><br><span class="line">            te = te-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新最后一次处理时间事件的时间</span></span><br><span class="line">    eventLoop-&gt;lastTime = now;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表, 执行那些已经到达的事件</span></span><br><span class="line">    te = eventLoop-&gt;timeEventHead;</span><br><span class="line">    maxId = eventLoop-&gt;timeEventNextId - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (te) &#123;</span><br><span class="line">        <span class="keyword">long</span> now_sec, now_ms;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> id;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跳过无效事件</span></span><br><span class="line">        <span class="keyword">if</span> (te-&gt;id &gt; maxId) &#123;</span><br><span class="line">            te = te-&gt;next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前时间</span></span><br><span class="line">        aeGetTime(&amp;now_sec, &amp;now_ms);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前时间等于或等于事件的执行时间，那么说明事件已到达，执行这个事件</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (now_sec &gt; te-&gt;when_sec ||</span><br><span class="line">            (now_sec == te-&gt;when_sec &amp;&amp; now_ms &gt;= te-&gt;when_ms)) &#123;</span><br><span class="line">            <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">            id = te-&gt;id;</span><br><span class="line">            <span class="comment">// 执行事件处理器，并获取返回值</span></span><br><span class="line">            retval = te-&gt;timeProc(eventLoop, id, te-&gt;clientData);</span><br><span class="line">            processed++;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// 记录是否有需要循环执行这个事件时间</span></span><br><span class="line">            <span class="keyword">if</span> (retval != AE_NOMORE) &#123;</span><br><span class="line">                <span class="comment">// 是的， retval 毫秒之后继续执行这个时间事件</span></span><br><span class="line">                aeAddMillisecondsToNow(retval, &amp;te-&gt;when_sec, &amp;te-&gt;when_ms);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不，将这个事件删除</span></span><br><span class="line">                aeDeleteTimeEvent(eventLoop, id);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 因为执行事件之后，事件列表可能已经被改变了</span></span><br><span class="line">            <span class="comment">// 因此需要将 te 放回表头，继续开始执行事件</span></span><br><span class="line">            te = eventLoop-&gt;timeEventHead;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            te = te-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 逻辑比较简单，基本上就是把链表里的时间事件扫一遍，把到时间的时间事件，执行一下处理器回调函数，然后根据返回值，决定把是否把时间事件重新放回链表，还是删除这个时间事件。</p></li></ol><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Redis 的事件处理器实现（基于 Reactor 模式）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%e6%b6%89%e5%8f%8a%e6%96%87%e4%bb%b6&quot;&gt;涉及文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%e7%bb%93%e6%9e%8
      
    
    </summary>
    
    
      <category term="开源组件" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/"/>
    
      <category term="Redis" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/"/>
    
      <category term="源码阅读" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
      <category term="C" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Redis 源码阅读8_数据库实现相关_rdb</title>
    <link href="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB8_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E7%8E%B0%E7%9B%B8%E5%85%B3_rdb/"/>
    <id>http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB8_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E7%8E%B0%E7%9B%B8%E5%85%B3_rdb/</id>
    <published>2020-03-11T12:21:42.921Z</published>
    <updated>2020-03-11T12:24:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 的 RDB 持久化实现代码。</p><ul><li><a href="#%e6%b6%89%e5%8f%8a%e7%9a%84%e6%96%87%e4%bb%b6">涉及的文件</a></li><li><a href="#api">API</a><ul><li><a href="#int-rdbsavechar-filename">int rdbSave(char *filename)</a></li><li><a href="#int-rdbsavebackgroundchar-filename">int rdbSaveBackground(char *filename)</a></li></ul></li></ul><h2 id="涉及的文件"><a href="#涉及的文件" class="headerlink" title="涉及的文件"></a>涉及的文件</h2><p><code>rdb.h</code></p><p><code>rdb.c</code></p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSaveType</span><span class="params">(rio *rdb, <span class="keyword">unsigned</span> <span class="keyword">char</span> type)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbLoadType</span><span class="params">(rio *rdb)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSaveTime</span><span class="params">(rio *rdb, <span class="keyword">time_t</span> t)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">time_t</span> <span class="title">rdbLoadTime</span><span class="params">(rio *rdb)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSaveLen</span><span class="params">(rio *rdb, <span class="keyword">uint32_t</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">rdbLoadLen</span><span class="params">(rio *rdb, <span class="keyword">int</span> *isencoded)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSaveObjectType</span><span class="params">(rio *rdb, robj *o)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbLoadObjectType</span><span class="params">(rio *rdb)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbLoad</span><span class="params">(<span class="keyword">char</span> *filename)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSaveBackground</span><span class="params">(<span class="keyword">char</span> *filename)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rdbRemoveTempFile</span><span class="params">(<span class="keyword">pid_t</span> childpid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSave</span><span class="params">(<span class="keyword">char</span> *filename)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSaveObject</span><span class="params">(rio *rdb, robj *o)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">off_t</span> <span class="title">rdbSavedObjectLen</span><span class="params">(robj *o)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">off_t</span> <span class="title">rdbSavedObjectPages</span><span class="params">(robj *o)</span></span>;</span><br><span class="line"><span class="function">robj *<span class="title">rdbLoadObject</span><span class="params">(<span class="keyword">int</span> type, rio *rdb)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backgroundSaveDoneHandler</span><span class="params">(<span class="keyword">int</span> exitcode, <span class="keyword">int</span> bysignal)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSaveKeyValuePair</span><span class="params">(rio *rdb, robj *key, robj *val, <span class="keyword">long</span> <span class="keyword">long</span> expiretime, <span class="keyword">long</span> <span class="keyword">long</span> now)</span></span>;</span><br><span class="line"><span class="function">robj *<span class="title">rdbLoadStringObject</span><span class="params">(rio *rdb)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="int-rdbSave-char-filename"><a href="#int-rdbSave-char-filename" class="headerlink" title="int rdbSave(char *filename)"></a>int rdbSave(char *filename)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Save the DB on disk. Return REDIS_ERR on error, REDIS_OK on success </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 将数据库保存到磁盘上。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 保存成功返回 REDIS_OK ，出错/失败返回 REDIS_ERR 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSave</span><span class="params">(<span class="keyword">char</span> *filename)</span> </span>&#123;</span><br><span class="line">    dictIterator *di = <span class="literal">NULL</span>;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="keyword">char</span> tmpfile[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">char</span> magic[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> now = mstime();</span><br><span class="line">    FILE *fp;</span><br><span class="line">    rio rdb;</span><br><span class="line">    <span class="keyword">uint64_t</span> cksum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建临时文件</span></span><br><span class="line">    <span class="built_in">snprintf</span>(tmpfile, <span class="number">256</span>, <span class="string">"temp-%d.rdb"</span>, (<span class="keyword">int</span>) getpid());</span><br><span class="line">    fp = fopen(tmpfile, <span class="string">"w"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fp) &#123;</span><br><span class="line">        redisLog(REDIS_WARNING, <span class="string">"Failed opening .rdb for saving: %s"</span>,</span><br><span class="line">                 strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 I/O</span></span><br><span class="line">    rioInitWithFile(&amp;rdb, fp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置校验和函数</span></span><br><span class="line">    <span class="keyword">if</span> (server.rdb_checksum)</span><br><span class="line">        rdb.update_cksum = rioGenericUpdateChecksum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入 RDB 版本号</span></span><br><span class="line">    <span class="built_in">snprintf</span>(magic, <span class="keyword">sizeof</span>(magic), <span class="string">"REDIS%04d"</span>, REDIS_RDB_VERSION);</span><br><span class="line">    <span class="keyword">if</span> (rdbWriteRaw(&amp;rdb, magic, <span class="number">9</span>) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有数据库</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.dbnum; j++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指向数据库</span></span><br><span class="line">        redisDb *db = server.db + j;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指向数据库键空间</span></span><br><span class="line">        dict *d = db-&gt;dict;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跳过空数据库</span></span><br><span class="line">        <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建键空间迭代器</span></span><br><span class="line">        di = dictGetSafeIterator(d);</span><br><span class="line">        <span class="keyword">if</span> (!di) &#123;</span><br><span class="line">            fclose(fp);</span><br><span class="line">            <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Write the SELECT DB opcode </span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 写入 DB 选择器</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (rdbSaveType(&amp;rdb, REDIS_RDB_OPCODE_SELECTDB) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">        <span class="keyword">if</span> (rdbSaveLen(&amp;rdb, j) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Iterate this DB writing every entry </span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 遍历数据库，并写入每个键值对的数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> ((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            sds keystr = dictGetKey(de);</span><br><span class="line">            robj key, *o = dictGetVal(de);</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> expire;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据 keystr ，在栈中创建一个 key 对象</span></span><br><span class="line">            initStaticStringObject(key, keystr);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取键的过期时间</span></span><br><span class="line">            expire = getExpire(db, &amp;key);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 保存键值对数据</span></span><br><span class="line">            <span class="keyword">if</span> (rdbSaveKeyValuePair(&amp;rdb, &amp;key, o, expire, now) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">        &#125;</span><br><span class="line">        dictReleaseIterator(di);</span><br><span class="line">    &#125;</span><br><span class="line">    di = <span class="literal">NULL</span>; <span class="comment">/* So that we don't release it again on error. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* EOF opcode </span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 写入 EOF 代码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (rdbSaveType(&amp;rdb, REDIS_RDB_OPCODE_EOF) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* CRC64 checksum. It will be zero if checksum computation is disabled, the</span></span><br><span class="line"><span class="comment">     * loading code skips the check in this case. </span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * CRC64 校验和。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果校验和功能已关闭，那么 rdb.cksum 将为 0 ，</span></span><br><span class="line"><span class="comment">     * 在这种情况下， RDB 载入时会跳过校验和检查。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    cksum = rdb.cksum;</span><br><span class="line">    memrev64ifbe(&amp;cksum);</span><br><span class="line">    rioWrite(&amp;rdb, &amp;cksum, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure data will not remain on the OS's output buffers */</span></span><br><span class="line">    <span class="comment">// 冲洗缓存，确保数据已写入磁盘</span></span><br><span class="line">    <span class="keyword">if</span> (fflush(fp) == EOF) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">if</span> (fsync(fileno(fp)) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">if</span> (fclose(fp) == EOF) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Use RENAME to make sure the DB file is changed atomically only</span></span><br><span class="line"><span class="comment">     * if the generate DB file is ok. </span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 使用 RENAME ，原子性地对临时文件进行改名，覆盖原来的 RDB 文件。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (rename(tmpfile, filename) == <span class="number">-1</span>) &#123;</span><br><span class="line">        redisLog(REDIS_WARNING, <span class="string">"Error moving temp DB file on the final destination: %s"</span>, strerror(errno));</span><br><span class="line">        unlink(tmpfile);</span><br><span class="line">        <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入完成，打印日志</span></span><br><span class="line">    redisLog(REDIS_NOTICE, <span class="string">"DB saved on disk"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清零数据库脏状态</span></span><br><span class="line">    server.dirty = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录最后一次完成 SAVE 的时间</span></span><br><span class="line">    server.lastsave = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录最后一次执行 SAVE 的状态</span></span><br><span class="line">    server.lastbgsave_status = REDIS_OK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> REDIS_OK;</span><br><span class="line"></span><br><span class="line">    werr:</span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="comment">// 删除文件</span></span><br><span class="line">    unlink(tmpfile);</span><br><span class="line"></span><br><span class="line">    redisLog(REDIS_WARNING, <span class="string">"Write error saving DB on disk: %s"</span>, strerror(errno));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (di) dictReleaseIterator(di);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>首先创建临时文件</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> tmpfile[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">snprintf</span>(tmpfile, <span class="number">256</span>, <span class="string">"temp-%d.rdb"</span>, (<span class="keyword">int</span>) getpid());</span><br><span class="line">fp = fopen(tmpfile, <span class="string">"w"</span>);</span><br><span class="line"><span class="keyword">if</span> (!fp) &#123;</span><br><span class="line">    redisLog(REDIS_WARNING, <span class="string">"Failed opening .rdb for saving: %s"</span>,</span><br><span class="line">             strerror(errno));</span><br><span class="line">    <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后初始化 IO</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">FILE *fp;</span><br><span class="line">rio rdb;</span><br><span class="line"></span><br><span class="line">rioInitWithFile(&amp;rdb, fp);</span><br><span class="line"><span class="keyword">if</span> (server.rdb_checksum) &#123;</span><br><span class="line">    rdb.update_cksum = rioGenericUpdateChecksum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 初始化文件流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rioInitWithFile</span><span class="params">(rio *r, FILE *fp)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    *r = rioFileIO;</span><br><span class="line">    r-&gt;io.file.fp = fp;</span><br><span class="line">    r-&gt;io.file.buffered = <span class="number">0</span>;</span><br><span class="line">    r-&gt;io.file.autosync = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>rio 的结构是这样的：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">rio</span> <span class="title">rio</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * RIO API 接口和状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">rio</span> &#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">size_t</span> (*<span class="built_in">read</span>)(struct _rio *, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len);</span><br><span class="line">        <span class="keyword">size_t</span> (*<span class="built_in">write</span>)(struct _rio *, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len);</span><br><span class="line">        <span class="keyword">off_t</span> (*tell)(struct _rio *);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> (*update_cksum)(struct _rio *, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前校验和</span></span><br><span class="line">        <span class="keyword">uint64_t</span> cksum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* number of bytes read or written */</span></span><br><span class="line">        <span class="keyword">size_t</span> processed_bytes;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* maximum single read or write chunk size */</span></span><br><span class="line">        <span class="keyword">size_t</span> max_processing_chunk;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">union</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                <span class="comment">// 缓存指针</span></span><br><span class="line">                sds ptr;</span><br><span class="line">                <span class="comment">// 偏移量</span></span><br><span class="line">                <span class="keyword">off_t</span> pos;</span><br><span class="line">            &#125; <span class="built_in">buffer</span>;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                <span class="comment">// 被打开文件的指针</span></span><br><span class="line">                FILE *fp;</span><br><span class="line">                <span class="comment">// 最近一次 fsync() 以来，写入的字节量</span></span><br><span class="line">                <span class="keyword">off_t</span> buffered; <span class="comment">/* Bytes written since last fsync. */</span></span><br><span class="line">                <span class="comment">// 写入多少字节之后，才会自动执行一次 fsync()</span></span><br><span class="line">                <span class="keyword">off_t</span> autosync; <span class="comment">/* fsync after 'autosync' bytes written. */</span></span><br><span class="line">            &#125; file;</span><br><span class="line">        &#125; io;</span><br><span class="line">    &#125;;</span><br><span class="line">    ```    </span><br><span class="line"></span><br><span class="line">    这里面主要是一些函数指针和变量</span><br><span class="line"></span><br><span class="line">- 接下来对 rdb 进行赋值, rioFileIO 是一个 <span class="keyword">static</span> <span class="keyword">const</span> 常量<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    ```c</span><br><span class="line">    *r = rioFileIO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 流为文件时所使用的结构</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> rio rioFileIO = &#123;</span><br><span class="line">        rioFileRead,    <span class="comment">// 读函数</span></span><br><span class="line">        rioFileWrite,   <span class="comment">// 写函数</span></span><br><span class="line">        rioFileTell,    <span class="comment">// 偏移量函数</span></span><br><span class="line">        <span class="literal">NULL</span>,           <span class="comment">/* update_checksum */</span></span><br><span class="line">        <span class="number">0</span>,              <span class="comment">/* current checksum */</span></span><br><span class="line">        <span class="number">0</span>,              <span class="comment">/* bytes read or written */</span></span><br><span class="line">        <span class="number">0</span>,              <span class="comment">/* read/write chunk size */</span></span><br><span class="line">        &#123; &#123; <span class="literal">NULL</span>, <span class="number">0</span> &#125; &#125; <span class="comment">/* union for io-specific vars */</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>  几个函数指针是一层封装</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 从文件 r 中读取 len 字节到 buf 中。返回值为读取的字节数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="title">rioFileRead</span><span class="params">(rio *r, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fread(buf, len, <span class="number">1</span>, r-&gt;io.file.fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns 1 or 0 for success/failure. </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 将长度为 len 的内容 buf 写入到文件 r 中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 成功返回 1 ，失败返回 0 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="title">rioFileWrite</span><span class="params">(rio *r, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> retval;</span><br><span class="line"></span><br><span class="line">    retval = fwrite(buf, len, <span class="number">1</span>, r-&gt;io.file.fp);</span><br><span class="line">    r-&gt;io.file.buffered += len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查写入的字节数，看是否需要执行自动 sync</span></span><br><span class="line">    <span class="keyword">if</span> (r-&gt;io.file.autosync &amp;&amp;</span><br><span class="line">        r-&gt;io.file.buffered &gt;= r-&gt;io.file.autosync) &#123;</span><br><span class="line"></span><br><span class="line">        fflush(r-&gt;io.file.fp);</span><br><span class="line">        aof_fsync(fileno(r-&gt;io.file.fp));</span><br><span class="line">        r-&gt;io.file.buffered = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns read/write position in file. </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回文件当前的偏移量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">off_t</span> <span class="title">rioFileTell</span><span class="params">(rio *r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ftello(r-&gt;io.file.fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后再把 rdb 的几个字段填充上</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r-&gt;io.file.fp = fp;</span><br><span class="line">r-&gt;io.file.buffered = <span class="number">0</span>;</span><br><span class="line">r-&gt;io.file.autosync = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>经过这一通操作， rio 对象和文件 File 就绑定上了。</p></li></ul></li><li><p>写入 RDB 版本号</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> magic[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">snprintf</span>(magic, <span class="keyword">sizeof</span>(magic), <span class="string">"REDIS%04d"</span>, REDIS_RDB_VERSION);</span><br><span class="line"><span class="keyword">if</span> (rdbWriteRaw(&amp;rdb, magic, <span class="number">9</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">goto</span> werr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>首先把版本号写到字符串里面</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">snprintf</span>(magic, <span class="keyword">sizeof</span>(magic), <span class="string">"REDIS%04d"</span>,</span><br></pre></td></tr></table></figure></li><li><p>然后把字符串写到 rdb 文件中</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将长度为 len 的字符数组 p 写入到 rdb 中。写入成功返回 len ，失败返回 -1 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rdbWriteRaw</span><span class="params">(rio *rdb, <span class="keyword">void</span> *p, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rdb &amp;&amp; rioWrite(rdb, p, len) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将 buf 中的 len 字节写入到 r 中。写入成功返回实际写入的字节数，写入失败返回 -1 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">size_t</span> <span class="title">rioWrite</span><span class="params">(rio *r, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (len) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> bytes_to_write = (r-&gt;max_processing_chunk &amp;&amp; r-&gt;max_processing_chunk &lt; len) ? r-&gt;max_processing_chunk : len;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (r-&gt;update_cksum) &#123;</span><br><span class="line">            r-&gt;update_cksum(r,buf,bytes_to_write);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r-&gt;<span class="built_in">write</span>(r,buf,bytes_to_write) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        buf = (<span class="keyword">char</span>*)buf + bytes_to_write;</span><br><span class="line">        len -= bytes_to_write;</span><br><span class="line">        r-&gt;processed_bytes += bytes_to_write;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  rioWrite 这个方法本身逻辑也挺简单的，主要是委托给了 <code>r-&gt;write(r, buf, bytes_to_write) == 0</code> 做底层的写操作。这个方法的主要作用是控制一次写 bytes 的数量不能大于 chunk_size</p></li></ul></li><li><p>遍历数据库</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.dbnum; j++) &#123;</span><br><span class="line">    redisDb *db = server.db + j;</span><br><span class="line">    dict *d = db-&gt;dict;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    di = dictGetSafeIterator(d);</span><br><span class="line">    <span class="keyword">if</span> (!di) &#123;</span><br><span class="line">        fclose(fp);</span><br><span class="line">        <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rdbSaveType(&amp;rdb, REDIS_RDB_OPCODE_SELECTDB) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> werr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rdbSaveLen(&amp;rdb, j) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> werr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历数据库，并写入每个键值对的数据</span></span><br><span class="line">    <span class="keyword">while</span> ((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        sds keystr = dictGetKey(de);</span><br><span class="line">        robj key, *o = dictGetVal(de);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> expire;</span><br><span class="line"></span><br><span class="line">        initStaticStringObject(key, keystr);</span><br><span class="line"></span><br><span class="line">        expire = getExpire(db, &amp;key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rdbSaveKeyValuePair(&amp;rdb, &amp;key, o, expire, now) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> werr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dictReleaseIterator(di);</span><br><span class="line">&#125;</span><br><span class="line">di = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p> 基本逻辑是把数据库中的每个键值对遍历一遍，然后写入，重点看 rdbSaveKeyValuePair 方法</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 将键值对的键、值、过期时间和类型写入到 RDB 中。</span></span><br><span class="line"><span class="comment"> * 出错返回 -1 。成功保存返回 1 ，当键已经过期时，返回 0 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSaveKeyValuePair</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    rio *rdb, robj *key, robj *val,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">long</span> <span class="keyword">long</span> expiretime, <span class="keyword">long</span> <span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  保存键的过期时间</span></span><br><span class="line">    <span class="keyword">if</span> (expiretime != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 不写入已经过期的键</span></span><br><span class="line">        <span class="keyword">if</span> (expiretime &lt; now) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rdbSaveType(rdb, REDIS_RDB_OPCODE_EXPIRETIME_MS) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rdbSaveMillisecondTime(rdb, expiretime) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存类型，键，值</span></span><br><span class="line">    <span class="keyword">if</span> (rdbSaveObjectType(rdb, val) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rdbSaveStringObject(rdb, key) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rdbSaveObject(rdb, val) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>保存键的 expire 时间</p><ul><li>rdbSaveType(rdb, REDIS_RDB_OPCODE_EXPIRETIME_MS)</li><li>rdbSaveMillisecondTime(rdb, expiretime)</li></ul></li><li><p>保存键的 type</p><p>  <code>rdbSaveObjectType(rdb, val)</code></p></li><li><p>保存键</p><p>  <code>rdbSaveStringObject(rdb, key)</code></p></li><li><p>保存值</p><p>  <code>rdbSaveObject(rdb, val)</code></p><p>要注意的是，到目前未知，所有 write 的过程，底层调用的都是这个方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="title">rioFileWrite</span><span class="params">(rio *r, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> retval;</span><br><span class="line"></span><br><span class="line">    retval = fwrite(buf, len, <span class="number">1</span>, r-&gt;io.file.fp);</span><br><span class="line">    r-&gt;io.file.buffered += len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查写入的字节数，看是否需要执行自动 sync</span></span><br><span class="line">    <span class="keyword">if</span> (r-&gt;io.file.autosync &amp;&amp;</span><br><span class="line">        r-&gt;io.file.buffered &gt;= r-&gt;io.file.autosync) &#123;</span><br><span class="line"></span><br><span class="line">        fflush(r-&gt;io.file.fp);</span><br><span class="line">        aof_fsync(fileno(r-&gt;io.file.fp));</span><br><span class="line">        r-&gt;io.file.buffered = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，是否强制操作系统 fsync 取决于 开了 autosync + 待写字节数够了</p></li></ul></li><li><p>写入 EOF 信息</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写入 EOF 代码</span></span><br><span class="line"><span class="keyword">if</span> (rdbSaveType(&amp;rdb, REDIS_RDB_OPCODE_EOF) == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">goto</span> werr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>写校验和</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cksum = rdb.cksum;</span><br><span class="line">memrev64ifbe(&amp;cksum);</span><br><span class="line">rioWrite(&amp;rdb, &amp;cksum, <span class="number">8</span>);</span><br></pre></td></tr></table></figure></li><li><p>冲洗缓存，确保数据已写入磁盘</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fflush(fp) == EOF) &#123;</span><br><span class="line">    <span class="keyword">goto</span> werr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (fsync(fileno(fp)) == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">goto</span> werr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (fclose(fp) == EOF) &#123;</span><br><span class="line">    <span class="keyword">goto</span> werr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 RENAME ，原子性地对临时文件进行改名，覆盖原来的 RDB 文件</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rename(tmpfile, filename) == <span class="number">-1</span>) &#123;</span><br><span class="line">    redisLog(REDIS_WARNING, <span class="string">"Error moving temp DB file on the final destination: %s"</span>, strerror(errno));</span><br><span class="line">    unlink(tmpfile);</span><br><span class="line">    <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后设置一些参数</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清零数据库脏状态</span></span><br><span class="line">server.dirty = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录最后一次完成 SAVE 的时间</span></span><br><span class="line">server.lastsave = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录最后一次执行 SAVE 的状态</span></span><br><span class="line">server.lastbgsave_status = REDIS_OK;</span><br></pre></td></tr></table></figure></li></ol><h3 id="int-rdbSaveBackground-char-filename"><a href="#int-rdbSaveBackground-char-filename" class="headerlink" title="int rdbSaveBackground(char *filename)"></a>int rdbSaveBackground(char *filename)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSaveBackground</span><span class="params">(<span class="keyword">char</span> *filename)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> childpid;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 BGSAVE 已经在执行，那么出错</span></span><br><span class="line">    <span class="keyword">if</span> (server.rdb_child_pid != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录 BGSAVE 执行前的数据库被修改次数</span></span><br><span class="line">    server.dirty_before_bgsave = server.dirty;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最近一次尝试执行 BGSAVE 的时间</span></span><br><span class="line">    server.lastbgsave_try = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fork() 开始前的时间，记录 fork() 返回耗时用</span></span><br><span class="line">    start = ustime();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((childpid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Child */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭网络连接 fd</span></span><br><span class="line">        closeListeningSockets(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置进程的标题，方便识别</span></span><br><span class="line">        redisSetProcTitle(<span class="string">"redis-rdb-bgsave"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行保存操作</span></span><br><span class="line">        retval = rdbSave(filename);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印 copy-on-write 时使用的内存数</span></span><br><span class="line">        <span class="keyword">if</span> (retval == REDIS_OK) &#123;</span><br><span class="line">            <span class="keyword">size_t</span> private_dirty = zmalloc_get_private_dirty();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (private_dirty) &#123;</span><br><span class="line">                redisLog(REDIS_NOTICE,</span><br><span class="line">                         <span class="string">"RDB: %zu MB of memory used by copy-on-write"</span>,</span><br><span class="line">                         private_dirty / (<span class="number">1024</span> * <span class="number">1024</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向父进程发送信号</span></span><br><span class="line">        exitFromChild((retval == REDIS_OK) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Parent */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算 fork() 执行的时间</span></span><br><span class="line">        server.stat_fork_time = ustime() - start;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 fork() 出错，那么报告错误</span></span><br><span class="line">        <span class="keyword">if</span> (childpid == <span class="number">-1</span>) &#123;</span><br><span class="line">            server.lastbgsave_status = REDIS_ERR;</span><br><span class="line">            redisLog(REDIS_WARNING, <span class="string">"Can't save in background: fork: %s"</span>,</span><br><span class="line">                     strerror(errno));</span><br><span class="line">            <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印 BGSAVE 开始的日志</span></span><br><span class="line">        redisLog(REDIS_NOTICE, <span class="string">"Background saving started by pid %d"</span>, childpid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录数据库开始 BGSAVE 的时间</span></span><br><span class="line">        server.rdb_save_time_start = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录负责执行 BGSAVE 的子进程 ID</span></span><br><span class="line">        server.rdb_child_pid = childpid;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭自动 rehash</span></span><br><span class="line">        updateDictResizePolicy();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> REDIS_OK; <span class="comment">/* unreached */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>先记录各种参数</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 BGSAVE 已经在执行，那么出错</span></span><br><span class="line"><span class="keyword">if</span> (server.rdb_child_pid != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录 BGSAVE 执行前的数据库被修改次数</span></span><br><span class="line">server.dirty_before_bgsave = server.dirty;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最近一次尝试执行 BGSAVE 的时间</span></span><br><span class="line">server.lastbgsave_try = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// fork() 开始前的时间，记录 fork() 返回耗时用</span></span><br><span class="line">start = ustime();</span><br></pre></td></tr></table></figure></li><li><p>fork 出子进程用于 BGSAVE</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((childpid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Child */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭网络连接 fd</span></span><br><span class="line">    closeListeningSockets(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置进程的标题，方便识别</span></span><br><span class="line">    redisSetProcTitle(<span class="string">"redis-rdb-bgsave"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行保存操作</span></span><br><span class="line">    retval = rdbSave(filename);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印 copy-on-write 时使用的内存数</span></span><br><span class="line">    <span class="keyword">if</span> (retval == REDIS_OK) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> private_dirty = zmalloc_get_private_dirty();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (private_dirty) &#123;</span><br><span class="line">            redisLog(REDIS_NOTICE,</span><br><span class="line">                     <span class="string">"RDB: %zu MB of memory used by copy-on-write"</span>,</span><br><span class="line">                     private_dirty / (<span class="number">1024</span> * <span class="number">1024</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向父进程发送信号</span></span><br><span class="line">    exitFromChild((retval == REDIS_OK) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>关闭网络连接 fd</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">closeListeningSockets(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭监听套接字</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">closeListeningSockets</span><span class="params">(<span class="keyword">int</span> unlink_unix_socket)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.ipfd_count; j++) &#123;</span><br><span class="line">        <span class="built_in">close</span>(server.ipfd[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.sofd != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">close</span>(server.sofd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.cluster_enabled) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.cfd_count; j++) &#123;</span><br><span class="line">            <span class="built_in">close</span>(server.cfd[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlink_unix_socket &amp;&amp; server.unixsocket) &#123;</span><br><span class="line">        redisLog(REDIS_NOTICE, <span class="string">"Removing the unix socket file."</span>);</span><br><span class="line">        unlink(server.unixsocket); <span class="comment">/* don't care if this fails */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  关的 fd 包括 connfd, listenfd, 和 用于集群的 fd</p></li><li><p>设置进程的标题，方便识别</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redisSetProcTitle(<span class="string">"redis-rdb-bgsave"</span>);</span><br></pre></td></tr></table></figure></li><li><p>在子进程中执行保存 rdb 文件的操作</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retval = rdbSave(filename);</span><br></pre></td></tr></table></figure><p>  这个和直接执行 SAVE 操作的方法是同一个，只不过放到了子进程中</p></li><li><p>向父进程发送信号</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">exitFromChild((retval == REDIS_OK) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exitFromChild</span><span class="params">(<span class="keyword">int</span> retcode)</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> COVERAGE_TEST</span></span><br><span class="line">        <span class="built_in">exit</span>(retcode);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        _exit(retcode);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>backgroundSaveDoneHandler 函数用于处理 BGSAVE 完成时发送的信号</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backgroundSaveDoneHandler</span><span class="params">(<span class="keyword">int</span> exitcode, <span class="keyword">int</span> bysignal)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BGSAVE 成功</span></span><br><span class="line">    <span class="keyword">if</span> (!bysignal &amp;&amp; exitcode == <span class="number">0</span>) &#123;</span><br><span class="line">        redisLog(REDIS_NOTICE,</span><br><span class="line">                 <span class="string">"Background saving terminated with success"</span>);</span><br><span class="line">        server.dirty = server.dirty - server.dirty_before_bgsave;</span><br><span class="line">        server.lastsave = time(<span class="literal">NULL</span>);</span><br><span class="line">        server.lastbgsave_status = REDIS_OK;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// BGSAVE 出错</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!bysignal &amp;&amp; exitcode != <span class="number">0</span>) &#123;</span><br><span class="line">        redisLog(REDIS_WARNING, <span class="string">"Background saving error"</span>);</span><br><span class="line">        server.lastbgsave_status = REDIS_ERR;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// BGSAVE 被中断</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisLog(REDIS_WARNING,</span><br><span class="line">             <span class="string">"Background saving terminated by signal %d"</span>, bysignal);</span><br><span class="line">        <span class="comment">// 移除临时文件</span></span><br><span class="line">        rdbRemoveTempFile(server.rdb_child_pid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bysignal != SIGUSR1)</span><br><span class="line">            server.lastbgsave_status = REDIS_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新服务器状态</span></span><br><span class="line">    server.rdb_child_pid = <span class="number">-1</span>;</span><br><span class="line">    server.rdb_save_time_last = time(<span class="literal">NULL</span>) - server.rdb_save_time_start;</span><br><span class="line">    server.rdb_save_time_start = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理正在等待 BGSAVE 完成的那些 slave</span></span><br><span class="line">    updateSlavesWaitingBgsave(exitcode == <span class="number">0</span> ? REDIS_OK : REDIS_ERR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这里面一共分了三种情况：</p><ul><li><p>返回值为 0，且没有被中断 </p></li><li><p>返回值非 0，且没有被中断 </p></li><li><p>被中断：此时要释放 tmp file</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rdbRemoveTempFile(server.rdb_child_pid);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 移除 BGSAVE 所产生的临时文件，BGSAVE 执行被中断时使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rdbRemoveTempFile</span><span class="params">(<span class="keyword">pid_t</span> childpid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> tmpfile[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(tmpfile, <span class="number">256</span>, <span class="string">"temp-%d.rdb"</span>, (<span class="keyword">int</span>) childpid);</span><br><span class="line">    unlink(tmpfile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>父进程比较简单，基本上都是统计性质的工作</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parent */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 fork() 执行的时间</span></span><br><span class="line">    server.stat_fork_time = ustime() - start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 fork() 出错，那么报告错误</span></span><br><span class="line">    <span class="keyword">if</span> (childpid == <span class="number">-1</span>) &#123;</span><br><span class="line">        server.lastbgsave_status = REDIS_ERR;</span><br><span class="line">        redisLog(REDIS_WARNING, <span class="string">"Can't save in background: fork: %s"</span>,</span><br><span class="line">                 strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印 BGSAVE 开始的日志</span></span><br><span class="line">    redisLog(REDIS_NOTICE, <span class="string">"Background saving started by pid %d"</span>, childpid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录数据库开始 BGSAVE 的时间</span></span><br><span class="line">    server.rdb_save_time_start = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录负责执行 BGSAVE 的子进程 ID</span></span><br><span class="line">    server.rdb_child_pid = childpid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭自动 rehash</span></span><br><span class="line">    updateDictResizePolicy();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Redis 的 RDB 持久化实现代码。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%e6%b6%89%e5%8f%8a%e7%9a%84%e6%96%87%e4%bb%b6&quot;&gt;涉及的文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#api&quot;&gt;API&lt;/a&gt;&lt;ul&gt;

      
    
    </summary>
    
    
      <category term="开源组件" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/"/>
    
      <category term="Redis" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/"/>
    
      <category term="源码阅读" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
      <category term="C" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Redis 源码阅读7_数据库实现相关_db</title>
    <link href="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB7_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E7%8E%B0%E7%9B%B8%E5%85%B3_db/"/>
    <id>http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB7_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E7%8E%B0%E7%9B%B8%E5%85%B3_db/</id>
    <published>2020-03-11T12:21:42.905Z</published>
    <updated>2020-03-11T12:22:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 的数据库实现。</p><ul><li><a href="#%e6%b6%89%e5%8f%8a%e6%96%87%e4%bb%b6">涉及文件</a></li><li><a href="#%e7%bb%93%e6%9e%84%e4%bd%93">结构体</a></li><li><a href="#api">API</a><ul><li><a href="#robj-lookupkeyreadorreplyredisclient-c-robj-key-robj-reply">robj *lookupKeyReadOrReply(redisClient *c, robj *key, robj *reply)</a></li><li><a href="#robj-lookupkeywriteorreplyredisclient-c-robj-key-robj-reply">robj *lookupKeyWriteOrReply(redisClient *c, robj *key, robj *reply)</a></li><li><a href="#void-delcommandredisclient-c">void delCommand(redisClient *c)</a></li></ul></li></ul><h2 id="涉及文件"><a href="#涉及文件" class="headerlink" title="涉及文件"></a>涉及文件</h2><p><code>redis.h</code></p><p><code>db.c</code></p><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库键空间，保存着数据库中的所有键值对</span></span><br><span class="line">    dict *dict;                 <span class="comment">/* The keyspace for this DB */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键的过期时间，字典的键为键，字典的值为过期事件 UNIX 时间戳</span></span><br><span class="line">    dict *expires;              <span class="comment">/* Timeout of keys with a timeout set */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正处于阻塞状态的键</span></span><br><span class="line">    dict *blocking_keys;        <span class="comment">/* Keys with clients waiting for data (BLPOP) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以解除阻塞的键</span></span><br><span class="line">    dict *ready_keys;           <span class="comment">/* Blocked keys that received a PUSH */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正在被 WATCH 命令监视的键</span></span><br><span class="line">    dict *watched_keys;         <span class="comment">/* WATCHED keys for MULTI/EXEC CAS */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> *<span class="title">eviction_pool</span>;</span>    <span class="comment">/* Eviction pool of keys */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库号码</span></span><br><span class="line">    <span class="keyword">int</span> id;                     <span class="comment">/* Database ID */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库的键的平均 TTL ，统计信息</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl;          <span class="comment">/* Average TTL, just for stats */</span></span><br><span class="line"></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><ul><li><p>robj *lookupKeyReadOrReply(redisClient *c, robj *key, robj *reply)</p></li><li><p>robj *lookupKeyWriteOrReply(redisClient *c, robj *key, robj *reply)</p></li><li><p>void setKey(redisDb *db, robj *key, robj *val)</p></li><li><p>void setExpire(redisDb *db, robj *key, long long when)</p></li><li><p>void xxxCommand(redisClient* c);</p></li></ul><h3 id="robj-lookupKeyReadOrReply-redisClient-c-robj-key-robj-reply"><a href="#robj-lookupKeyReadOrReply-redisClient-c-robj-key-robj-reply" class="headerlink" title="robj *lookupKeyReadOrReply(redisClient *c, robj *key, robj *reply)"></a>robj *lookupKeyReadOrReply(redisClient *c, robj *key, robj *reply)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 为执行读取操作而从数据库中查找返回 key 的值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果 key 存在，那么返回 key 的值对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果 key 不存在，那么向客户端发送 reply 参数中的信息，并返回 NULL 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">robj *<span class="title">lookupKeyReadOrReply</span><span class="params">(redisClient *c, robj *key, robj *reply)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找</span></span><br><span class="line">    robj *o = lookupKeyRead(c-&gt;db, key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 决定是否发送信息</span></span><br><span class="line">    <span class="keyword">if</span> (!o) &#125;&#123;</span><br><span class="line">        addReply(c, reply);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>addReply 在 “../3_数据类型实现/2_t_xxx.md” 看过了，这里重点看 lookupKeyRead：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 为执行读取操作而取出键 key 在数据库 db 中的值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 并根据是否成功找到值，更新服务器的命中/不命中信息。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 找到时返回值对象，没找到返回 NULL 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">robj *<span class="title">lookupKeyRead</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    robj *val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 key 释放已经过期</span></span><br><span class="line">    expireIfNeeded(db, key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从数据库中取出键的值</span></span><br><span class="line">    val = lookupKey(db, key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新命中/不命中信息</span></span><br><span class="line">    <span class="keyword">if</span> (val == <span class="literal">NULL</span>)</span><br><span class="line">        server.stat_keyspace_misses++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        server.stat_keyspace_hits++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回值</span></span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>expireIfNeeded 也看过了， lookupKey 也挺简单的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 从数据库 db 中取出键 key 的值（对象）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果 key 的值存在，那么返回该值；否则，返回 NULL 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">robj *<span class="title">lookupKey</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找键空间</span></span><br><span class="line">    dictEntry *de = dictFind(db-&gt;dict, key-&gt;ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点存在</span></span><br><span class="line">    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">        <span class="comment">// 取出值</span></span><br><span class="line">        robj *val = dictGetVal(de);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Update the access time for the ageing algorithm.</span></span><br><span class="line"><span class="comment">         * Don't do it if we have a saving child, as this will trigger</span></span><br><span class="line"><span class="comment">         * a copy on write madness. */</span></span><br><span class="line">        <span class="comment">// 更新时间信息（只在不存在子进程时执行，防止破坏 copy-on-write 机制）</span></span><br><span class="line">        <span class="keyword">if</span> (server.rdb_child_pid == <span class="number">-1</span> &amp;&amp; server.aof_child_pid == <span class="number">-1</span>)</span><br><span class="line">            val-&gt;lru = LRU_CLOCK();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回值</span></span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 节点不存在</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="robj-lookupKeyWriteOrReply-redisClient-c-robj-key-robj-reply"><a href="#robj-lookupKeyWriteOrReply-redisClient-c-robj-key-robj-reply" class="headerlink" title="robj *lookupKeyWriteOrReply(redisClient *c, robj *key, robj *reply)"></a>robj *lookupKeyWriteOrReply(redisClient *c, robj *key, robj *reply)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 为执行写入操作而从数据库中查找返回 key 的值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果 key 存在，那么返回 key 的值对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果 key 不存在，那么向客户端发送 reply 参数中的信息，并返回 NULL 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">robj *<span class="title">lookupKeyWriteOrReply</span><span class="params">(redisClient *c, robj *key, robj *reply)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    robj *o = lookupKeyWrite(c-&gt;db, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!o) &#123;</span><br><span class="line">        addReply(c, reply);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 为执行写入操作而取出键 key 在数据库 db 中的值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 和 lookupKeyRead 不同，这个函数不会更新服务器的命中/不命中信息。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 找到时返回值对象，没找到返回 NULL 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">robj *<span class="title">lookupKeyWrite</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除过期键</span></span><br><span class="line">    expireIfNeeded(db, key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找并返回 key 的值对象</span></span><br><span class="line">    <span class="keyword">return</span> lookupKey(db, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 lookupKeyReadOrReply 基本上是一样的，唯一的不同是 read 的情况下要更新 命中/不命中 信息</p><h3 id="void-delCommand-redisClient-c"><a href="#void-delCommand-redisClient-c" class="headerlink" title="void delCommand(redisClient *c)"></a>void delCommand(redisClient *c)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> deleted = <span class="number">0</span>, j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有输入键</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先删除过期的键</span></span><br><span class="line">        expireIfNeeded(c-&gt;db, c-&gt;argv[j]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试删除键</span></span><br><span class="line">        <span class="keyword">if</span> (dbDelete(c-&gt;db, c-&gt;argv[j])) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 删除键成功，发送通知</span></span><br><span class="line">            signalModifiedKey(c-&gt;db, c-&gt;argv[j]);</span><br><span class="line">            notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,</span><br><span class="line">                                <span class="string">"del"</span>, c-&gt;argv[j], c-&gt;db-&gt;id);</span><br><span class="line"></span><br><span class="line">            server.dirty++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 成功删除才增加 deleted 计数器的值</span></span><br><span class="line">            deleted++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回被删除键的数量</span></span><br><span class="line">    addReplyLongLong(c, deleted);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>首先看看 dbDelete 方法，逻辑是删除 expires 和 dict 的 key</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Delete a key, value, and associated expiration entry if any, from the DB </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 从数据库中删除给定的键，键的值，以及键的过期时间。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 删除成功返回 1 ，因为键不存在而导致删除失败时，返回 0 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dbDelete</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Deleting an entry from the expires dict will not free the sds of</span></span><br><span class="line"><span class="comment">     * the key, because it is shared with the main dictionary. */</span></span><br><span class="line">    <span class="comment">// 删除键的过期时间</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        dictDelete(db-&gt;expires, key-&gt;ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除键值对</span></span><br><span class="line">    <span class="keyword">if</span> (dictDelete(db-&gt;dict, key-&gt;ptr) == DICT_OK) &#123;</span><br><span class="line">        <span class="comment">// 如果开启了集群模式，那么从槽中删除给定的键</span></span><br><span class="line">        <span class="keyword">if</span> (server.cluster_enabled) &#123;</span><br><span class="line">            slotToKeyDel(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 键不存在</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后发送通知，一个通知事务 WATCH ，一个通知 pub-subscribe ，具体没细看</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">signalModifiedKey(c-&gt;db, c-&gt;argv[j]);</span><br><span class="line">notifyKeyspaceEvent(</span><br><span class="line">    REDIS_NOTIFY_GENERIC, <span class="string">"del"</span>, c-&gt;argv[j], c-&gt;db-&gt;id);</span><br></pre></td></tr></table></figure></li><li><p>最后把删除键的数目 addReply</p></li></ul><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Redis 的数据库实现。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%e6%b6%89%e5%8f%8a%e6%96%87%e4%bb%b6&quot;&gt;涉及文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%e7%bb%93%e6%9e%84%e4%bd%93&quot;&gt;结构体&lt;/
      
    
    </summary>
    
    
      <category term="开源组件" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/"/>
    
      <category term="Redis" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/"/>
    
      <category term="源码阅读" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
      <category term="C" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Redis 源码阅读6_数据类型_键类型</title>
    <link href="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB6_%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B_%E9%94%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB6_%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B_%E9%94%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-03-11T12:19:58.954Z</published>
    <updated>2020-03-11T12:20:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>总共有 5 个相关文件</p><table><thead><tr><th align="center">文件</th><th align="center">内容</th></tr></thead><tbody><tr><td align="center">t_string.c</td><td align="center">字符串键的实现</td></tr><tr><td align="center">t_list.c</td><td align="center">列表键的实现</td></tr><tr><td align="center">t_hash.c</td><td align="center">散列键的实现</td></tr><tr><td align="center">t_set.c</td><td align="center">集合键的实现</td></tr><tr><td align="center">t_zset.c 中除 zsl 开头的函数之外的所有函数。</td><td align="center">有序集合键的实现</td></tr></tbody></table><p>这 5 个文件里面实现的是各种 Redis 的命令的具体实现，仔细看一个：</p><p><code>t_string.c</code></p><p><code>SET key value [NX] [XX] [EX &lt;seconds&gt;] [PX &lt;milliseconds&gt;]</code></p><p>这个命令的意思是：</p><ul><li>对 key 设置值为 value</li><li>EX 和 PX 指定了 expire 的时间</li><li>NX 选项代表只在键不存在时，才对键进行设置操作。执行 SET key value NX 的效果等同于执行 SETNX key value</li><li>XX 选项代表只在键已经存在时， 才对键进行设置操作</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    robj *expire = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> unit = UNIT_SECONDS;</span><br><span class="line">    <span class="keyword">int</span> flags = REDIS_SET_NO_FLAGS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置选项参数</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">3</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        <span class="keyword">char</span> *a = c-&gt;argv[j]-&gt;ptr;</span><br><span class="line">        robj *next = (j == c-&gt;argc - <span class="number">1</span>) ? <span class="literal">NULL</span> : c-&gt;argv[j + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((a[<span class="number">0</span>] == <span class="string">'n'</span> || a[<span class="number">0</span>] == <span class="string">'N'</span>) &amp;&amp;</span><br><span class="line">            (a[<span class="number">1</span>] == <span class="string">'x'</span> || a[<span class="number">1</span>] == <span class="string">'X'</span>) &amp;&amp; a[<span class="number">2</span>] == <span class="string">'\0'</span>) &#123;</span><br><span class="line">            flags |= REDIS_SET_NX;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((a[<span class="number">0</span>] == <span class="string">'x'</span> || a[<span class="number">0</span>] == <span class="string">'X'</span>) &amp;&amp;</span><br><span class="line">                   (a[<span class="number">1</span>] == <span class="string">'x'</span> || a[<span class="number">1</span>] == <span class="string">'X'</span>) &amp;&amp; a[<span class="number">2</span>] == <span class="string">'\0'</span>) &#123;</span><br><span class="line">            flags |= REDIS_SET_XX;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((a[<span class="number">0</span>] == <span class="string">'e'</span> || a[<span class="number">0</span>] == <span class="string">'E'</span>) &amp;&amp;</span><br><span class="line">                   (a[<span class="number">1</span>] == <span class="string">'x'</span> || a[<span class="number">1</span>] == <span class="string">'X'</span>) &amp;&amp; a[<span class="number">2</span>] == <span class="string">'\0'</span> &amp;&amp; next) &#123;</span><br><span class="line">            unit = UNIT_SECONDS;</span><br><span class="line">            expire = next;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((a[<span class="number">0</span>] == <span class="string">'p'</span> || a[<span class="number">0</span>] == <span class="string">'P'</span>) &amp;&amp;</span><br><span class="line">                   (a[<span class="number">1</span>] == <span class="string">'x'</span> || a[<span class="number">1</span>] == <span class="string">'X'</span>) &amp;&amp; a[<span class="number">2</span>] == <span class="string">'\0'</span> &amp;&amp; next) &#123;</span><br><span class="line">            unit = UNIT_MILLISECONDS;</span><br><span class="line">            expire = next;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addReply(c, shared.syntaxerr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试对值对象进行编码</span></span><br><span class="line">    c-&gt;argv[<span class="number">2</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    setGenericCommand(c, flags, c-&gt;argv[<span class="number">1</span>], c-&gt;argv[<span class="number">2</span>], expire, unit, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>首先是把命令中的参数解析一下，设置 expire , unit 和 flags 三个变量。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置选项参数</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">3</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">    <span class="keyword">char</span> *a = c-&gt;argv[j]-&gt;ptr;</span><br><span class="line">    robj *next = (j == c-&gt;argc - <span class="number">1</span>) ? <span class="literal">NULL</span> : c-&gt;argv[j + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((a[<span class="number">0</span>] == <span class="string">'n'</span> || a[<span class="number">0</span>] == <span class="string">'N'</span>) &amp;&amp;</span><br><span class="line">        (a[<span class="number">1</span>] == <span class="string">'x'</span> || a[<span class="number">1</span>] == <span class="string">'X'</span>) &amp;&amp; a[<span class="number">2</span>] == <span class="string">'\0'</span>) &#123;</span><br><span class="line">        flags |= REDIS_SET_NX;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((a[<span class="number">0</span>] == <span class="string">'x'</span> || a[<span class="number">0</span>] == <span class="string">'X'</span>) &amp;&amp;</span><br><span class="line">               (a[<span class="number">1</span>] == <span class="string">'x'</span> || a[<span class="number">1</span>] == <span class="string">'X'</span>) &amp;&amp; a[<span class="number">2</span>] == <span class="string">'\0'</span>) &#123;</span><br><span class="line">        flags |= REDIS_SET_XX;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((a[<span class="number">0</span>] == <span class="string">'e'</span> || a[<span class="number">0</span>] == <span class="string">'E'</span>) &amp;&amp;</span><br><span class="line">               (a[<span class="number">1</span>] == <span class="string">'x'</span> || a[<span class="number">1</span>] == <span class="string">'X'</span>) &amp;&amp; a[<span class="number">2</span>] == <span class="string">'\0'</span> &amp;&amp; next) &#123;</span><br><span class="line">        unit = UNIT_SECONDS;</span><br><span class="line">        expire = next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((a[<span class="number">0</span>] == <span class="string">'p'</span> || a[<span class="number">0</span>] == <span class="string">'P'</span>) &amp;&amp;</span><br><span class="line">               (a[<span class="number">1</span>] == <span class="string">'x'</span> || a[<span class="number">1</span>] == <span class="string">'X'</span>) &amp;&amp; a[<span class="number">2</span>] == <span class="string">'\0'</span> &amp;&amp; next) &#123;</span><br><span class="line">        unit = UNIT_MILLISECONDS;</span><br><span class="line">        expire = next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addReply(c, shared.syntaxerr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后进入了 setGenericCommand 函数，这个 setGenericCommand() 函数实现了 SET 、 SETEX 、 PSETEX 和 SETNX 命令。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setGenericCommand</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    redisClient *c,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> flags, robj *key, robj *val,</span></span></span><br><span class="line"><span class="function"><span class="params">    robj *expire, <span class="keyword">int</span> unit,</span></span></span><br><span class="line"><span class="function"><span class="params">    robj *ok_reply, robj *abort_reply)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> milliseconds = <span class="number">0</span>; <span class="comment">/* initialized to avoid any harmness warning */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出过期时间</span></span><br><span class="line">    <span class="keyword">if</span> (expire) &#123;</span><br><span class="line">        <span class="comment">// 取出 expire 参数的值</span></span><br><span class="line">        <span class="comment">// T = O(N)</span></span><br><span class="line">        <span class="keyword">if</span> (getLongLongFromObjectOrReply(c, expire, &amp;milliseconds, <span class="literal">NULL</span>) != REDIS_OK)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// expire 参数的值不正确时报错</span></span><br><span class="line">        <span class="keyword">if</span> (milliseconds &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            addReplyError(c, <span class="string">"invalid expire time in SETEX"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不论输入的过期时间是秒还是毫秒</span></span><br><span class="line">        <span class="comment">// Redis 实际都以毫秒的形式保存过期时间</span></span><br><span class="line">        <span class="comment">// 如果输入的过期时间为秒，那么将它转换为毫秒</span></span><br><span class="line">        <span class="keyword">if</span> (unit == UNIT_SECONDS) milliseconds *= <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果设置了 NX 或者 XX 参数，那么检查条件是否不符合这两个设置</span></span><br><span class="line">    <span class="comment">// 在条件不符合时报错，报错的内容由 abort_reply 参数决定</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; REDIS_SET_NX &amp;&amp; lookupKeyWrite(c-&gt;db, key) != <span class="literal">NULL</span>) ||</span><br><span class="line">        (flags &amp; REDIS_SET_XX &amp;&amp; lookupKeyWrite(c-&gt;db, key) == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        addReply(c, abort_reply ? abort_reply : shared.nullbulk);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将键值关联到数据库</span></span><br><span class="line">    setKey(c-&gt;db, key, val);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数据库设为脏</span></span><br><span class="line">    server.dirty++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为键设置过期时间</span></span><br><span class="line">    <span class="keyword">if</span> (expire) &#123;</span><br><span class="line">        setExpire(c-&gt;db, key, mstime() + milliseconds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送事件通知</span></span><br><span class="line">    notifyKeyspaceEvent(REDIS_NOTIFY_STRING, <span class="string">"set"</span>, key, c-&gt;db-&gt;id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送事件通知</span></span><br><span class="line">    <span class="keyword">if</span> (expire) &#123;</span><br><span class="line">        notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,</span><br><span class="line">                            <span class="string">"expire"</span>, key, c-&gt;db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置成功，向客户端发送回复</span></span><br><span class="line">    <span class="comment">// 回复的内容由 ok_reply 决定</span></span><br><span class="line">    addReply(c, ok_reply ? ok_reply : shared.ok);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>首先把 expire 时间取出来，转换成 ms 形式</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expire) &#123;</span><br><span class="line">    <span class="comment">// 取出 expire 参数的值</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    <span class="keyword">if</span> (getLongLongFromObjectOrReply(</span><br><span class="line">            c, expire, &amp;milliseconds, <span class="literal">NULL</span>) != REDIS_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// expire 参数的值不正确时报错</span></span><br><span class="line">    <span class="keyword">if</span> (milliseconds &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        addReplyError(c, <span class="string">"invalid expire time in SETEX"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不论输入的过期时间是秒还是毫秒</span></span><br><span class="line">    <span class="comment">// Redis 实际都以毫秒的形式保存过期时间</span></span><br><span class="line">    <span class="comment">// 如果输入的过期时间为秒，那么将它转换为毫秒</span></span><br><span class="line">    <span class="keyword">if</span> (unit == UNIT_SECONDS) &#123;</span><br><span class="line">        milliseconds *= <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 尝试从对象 o 中取出整数值，</span></span><br><span class="line"><span class="comment"> * 或者尝试将对象 o 中的值转换为整数值，</span></span><br><span class="line"><span class="comment"> * 并将这个得出的整数值保存到 *target 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果取出/转换成功的话，返回 REDIS_OK 。</span></span><br><span class="line"><span class="comment"> * 否则，返回 REDIS_ERR ，并向客户端发送一条出错回复。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLongLongFromObjectOrReply</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    redisClient *c, robj *o, <span class="keyword">long</span> <span class="keyword">long</span> *target, <span class="keyword">const</span> <span class="keyword">char</span> *msg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    <span class="keyword">if</span> (getLongLongFromObject(o, &amp;value) != REDIS_OK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            addReplyError(c, (<span class="keyword">char</span> *) msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addReplyError(c, <span class="string">"value is not an integer or out of range"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *target = value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 尝试从对象 o 中取出整数值，</span></span><br><span class="line"><span class="comment"> * 或者尝试将对象 o 所保存的值转换为整数值，</span></span><br><span class="line"><span class="comment"> * 并将这个整数值保存到 *target 中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果 o 为 NULL ，那么将 *target 设为 0 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果对象 o 中的值不是整数，并且不能转换为整数，那么函数返回 REDIS_ERR 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 成功取出或者成功进行转换时，返回 REDIS_OK 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLongLongFromObject</span><span class="params">(robj *o, <span class="keyword">long</span> <span class="keyword">long</span> *target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value;</span><br><span class="line">    <span class="keyword">char</span> *eptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// o 为 NULL 时，将值设为 0 。</span></span><br><span class="line">        value = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保对象为 REDIS_STRING 类型</span></span><br><span class="line">        redisAssertWithInfo(<span class="literal">NULL</span>, o, o-&gt;type == REDIS_STRING);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sdsEncodedObject(o)) &#123;</span><br><span class="line">            errno = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// T = O(N)</span></span><br><span class="line">            value = strtoll(o-&gt;ptr, &amp;eptr, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isspace</span>(((<span class="keyword">char</span> *) o-&gt;ptr)[<span class="number">0</span>]) || eptr[<span class="number">0</span>] != <span class="string">'\0'</span> || errno == ERANGE)</span><br><span class="line">                <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_INT) &#123;</span><br><span class="line">            <span class="comment">// 对于 REDIS_ENCODING_INT 编码的整数值</span></span><br><span class="line">            <span class="comment">// 直接将它的值保存到 value 中</span></span><br><span class="line">            value = (<span class="keyword">long</span>) o-&gt;ptr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            redisPanic(<span class="string">"Unknown string encoding"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存值到指针</span></span><br><span class="line">    <span class="keyword">if</span> (target) &#123;</span><br><span class="line">        *target = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回结果标识符</span></span><br><span class="line">    <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这个函数没啥可看的，就是把字符串转为数字</p></li><li><p>如果设置了 NX 或者 XX 参数，那么要进行条件检查</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((flags &amp; REDIS_SET_NX &amp;&amp; lookupKeyWrite(c-&gt;db, key) != <span class="literal">NULL</span>) ||</span><br><span class="line">    (flags &amp; REDIS_SET_XX &amp;&amp; lookupKeyWrite(c-&gt;db, key) == <span class="literal">NULL</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    addReply(c, abort_reply ? abort_reply : shared.nullbulk);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 为执行写入操作而取出键 key 在数据库 db 中的值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 和 lookupKeyRead 不同，这个函数不会更新服务器的命中/不命中信息。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 找到时返回值对象，没找到返回 NULL 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">robj *<span class="title">lookupKeyWrite</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 删除过期键</span></span><br><span class="line">    expireIfNeeded(db, key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找并返回 key 的值对象</span></span><br><span class="line">    <span class="keyword">return</span> lookupKey(db, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>删除过期键</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mstime_t</span> when = getExpire(db, key);</span><br><span class="line">    <span class="keyword">mstime_t</span> now;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (when &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* No expire for this key */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.loading) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    now = server.lua_caller ? server.lua_time_start : mstime();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> now &gt; when;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (now &lt;= when) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server.stat_expiredkeys++;</span><br><span class="line"></span><br><span class="line">    propagateExpire(db, key);</span><br><span class="line"></span><br><span class="line">    notifyKeyspaceEvent(REDIS_NOTIFY_EXPIRED, <span class="string">"expired"</span>, key, db-&gt;id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dbDelete(db, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 原理是 redisServer 有两个字典，过期字典报错过期信息，用于读；然后进行各种情况判断，如果确定过期且该删除键的话，把键从 redisServer 真正的字典中删除</p></li><li><p>寻找 key 的值对象</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 从数据库 db 中取出键 key 的值（对象）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果 key 的值存在，那么返回该值；否则，返回 NULL 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">robj *<span class="title">lookupKey</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找键空间</span></span><br><span class="line">    dictEntry *de = dictFind(db-&gt;dict, key-&gt;ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点存在</span></span><br><span class="line">    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">        <span class="comment">// 取出值</span></span><br><span class="line">        robj *val = dictGetVal(de);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新时间信息（只在不存在子进程时执行，防止破坏 copy-on-write 机制）</span></span><br><span class="line">        <span class="keyword">if</span> (server.rdb_child_pid == <span class="number">-1</span> &amp;&amp; server.aof_child_pid == <span class="number">-1</span>)</span><br><span class="line">            val-&gt;lru = LRU_CLOCK();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回值</span></span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 节点不存在</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> dictFind 方法在字典里研究过，这里注意的是由于访问过，所以会更新 lru 信息</p></li></ol></li><li><p>在数据库中设置键值</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">setKey(c-&gt;db, key, val);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setKey</span><span class="params">(redisDb *db, robj *key, robj *val)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加或覆写数据库中的键值对</span></span><br><span class="line">    <span class="keyword">if</span> (lookupKeyWrite(db, key) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        dbAdd(db, key, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dbOverwrite(db, key, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    incrRefCount(val);</span><br><span class="line"></span><br><span class="line">    removeExpire(db, key);</span><br><span class="line"></span><br><span class="line">    signalModifiedKey(db, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这个方法里面主要干了几件大事：</p><ul><li>添加或覆写数据库中的键值对 (dictAdd 或 dictReplace)</li><li>值对象的引用计数会被增加</li><li>移除键的过期时间</li><li>监视键 key 的客户端会收到键已经被修改的通知</li></ul></li><li><p>将数据库设为脏</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.dirty++;</span><br></pre></td></tr></table></figure></li><li><p>为键设置过期时间</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expire) &#123;</span><br><span class="line">    setExpire(c-&gt;db, key, mstime() + milliseconds);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setExpire</span><span class="params">(redisDb *db, robj *key, <span class="keyword">long</span> <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    dictEntry *kde, *de;</span><br><span class="line"></span><br><span class="line">    kde = dictFind(db-&gt;dict, key-&gt;ptr);</span><br><span class="line"></span><br><span class="line">    redisAssertWithInfo(<span class="literal">NULL</span>, key, kde != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    de = dictReplaceRaw(db-&gt;expires, dictGetKey(kde));</span><br><span class="line"></span><br><span class="line">    dictSetSignedIntegerVal(de, when);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>发送事件通知，针对的是 发布-订阅 高级功能</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送事件通知</span></span><br><span class="line">notifyKeyspaceEvent(REDIS_NOTIFY_STRING, <span class="string">"set"</span>, key, c-&gt;db-&gt;id);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送事件通知</span></span><br><span class="line"><span class="keyword">if</span> (expire) &#123;</span><br><span class="line">    notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,</span><br><span class="line">                        <span class="string">"expire"</span>, key, c-&gt;db-&gt;id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>向客户端发送回复</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">addReply(c, ok_reply ? ok_reply : shared.ok);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addReply</span><span class="params">(redisClient *c, robj *obj)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prepareClientToWrite(c) != REDIS_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sdsEncodedObject(obj)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_addReplyToBuffer(c, obj-&gt;ptr, sdslen(obj-&gt;ptr)) != REDIS_OK)</span><br><span class="line">            _addReplyObjectToList(c, obj);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj-&gt;encoding == REDIS_ENCODING_INT) &#123;</span><br><span class="line">        <span class="keyword">if</span> (listLength(c-&gt;reply) == <span class="number">0</span> &amp;&amp; (<span class="keyword">sizeof</span>(c-&gt;buf) - c-&gt;bufpos) &gt;= <span class="number">32</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">            len = ll2string(buf, <span class="keyword">sizeof</span>(buf), (<span class="keyword">long</span>) obj-&gt;ptr);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_addReplyToBuffer(c, buf, len) == REDIS_OK)</span><br><span class="line">                <span class="keyword">return</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        obj = getDecodedObject(obj);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (_addReplyToBuffer(c, obj-&gt;ptr, sdslen(obj-&gt;ptr)) != REDIS_OK)</span><br><span class="line">            _addReplyObjectToList(c, obj);</span><br><span class="line"></span><br><span class="line">        decrRefCount(obj);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">"Wrong obj-&gt;encoding in addReply()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 回复的内容可以往两个位置写，一个是空间较小的固定 buffer，一个是链表。</p><ol><li><p>首先尝试向固定大小的 buffer 中写</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 尝试将回复添加到 c-&gt;buf 中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> _addReplyToBuffer(redisClient *c, <span class="keyword">char</span> *s, <span class="keyword">size_t</span> len) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">available</span> = <span class="keyword">sizeof</span>(c-&gt;buf) - c-&gt;bufpos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; REDIS_CLOSE_AFTER_REPLY) &#123;</span><br><span class="line">        <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listLength(c-&gt;reply) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="built_in">available</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制内容到 c-&gt;buf 里面</span></span><br><span class="line">    <span class="built_in">memcpy</span>(c-&gt;buf + c-&gt;bufpos, s, len);</span><br><span class="line">    c-&gt;bufpos += len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这是固定 buffer 的结构： <code>char buf[REDIS_REPLY_CHUNK_BYTES]</code>; RedisClient 里面有个 bufpos 指示可用的位置，只有空间足够时才往里面写</p></li><li><p>尝试失败了，就向链表式 buffer 里写</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将回复对象（一个 SDS ）添加到 c-&gt;reply 回复链表中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> _addReplyObjectToList(redisClient *c, robj *o) &#123;</span><br><span class="line">    robj *tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端即将被关闭，无须再发送回复</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; REDIS_CLOSE_AFTER_REPLY) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表中无缓冲块，直接将对象追加到链表中</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(c-&gt;reply) == <span class="number">0</span>) &#123;</span><br><span class="line">        incrRefCount(o);</span><br><span class="line">        listAddNodeTail(c-&gt;reply, o);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 链表中已有缓冲块，尝试将回复添加到块内</span></span><br><span class="line">        <span class="comment">// 如果当前的块不能容纳回复的话，那么新建一个块</span></span><br><span class="line">        c-&gt;reply_bytes += getStringObjectSdsUsedMemory(o);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 取出表尾的 SDS</span></span><br><span class="line">        tail = listNodeValue(listLast(c-&gt;reply));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Append to this object when possible. */</span></span><br><span class="line">        <span class="comment">// 如果表尾 SDS 的已用空间加上对象的长度，小于 REDIS_REPLY_CHUNK_BYTES</span></span><br><span class="line">        <span class="comment">// 那么将新对象的内容拼接到表尾 SDS 的末尾</span></span><br><span class="line">        <span class="keyword">if</span> (tail-&gt;ptr != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">            tail-&gt;encoding == REDIS_ENCODING_RAW &amp;&amp;</span><br><span class="line">            sdslen(tail-&gt;ptr) + sdslen(o-&gt;ptr) &lt;= REDIS_REPLY_CHUNK_BYTES) &#123;</span><br><span class="line"></span><br><span class="line">            c-&gt;reply_bytes -= zmalloc_size_sds(tail-&gt;ptr);</span><br><span class="line">            tail = dupLastObjectIfNeeded(c-&gt;reply);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 拼接</span></span><br><span class="line">            tail-&gt;ptr = sdscatlen(tail-&gt;ptr, o-&gt;ptr, sdslen(o-&gt;ptr));</span><br><span class="line">            c-&gt;reply_bytes += zmalloc_size_sds(tail-&gt;ptr);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 直接将对象追加到末尾</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            incrRefCount(o);</span><br><span class="line">            listAddNodeTail(c-&gt;reply, o);</span><br><span class="line">            c-&gt;reply_bytes += getStringObjectSdsUsedMemory(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查回复缓冲区的大小，如果超过系统限制的话，那么关闭客户端</span></span><br><span class="line">    asyncCloseClientOnOutputBufferLimitReached(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这是链表 buffer 的结构 <code>list *reply;</code>，和 固定 buffer 不同的是，固定 buffer 只是一个数组，链表里可能有多个元素，每个元素都是一个 sds。</p><p> 逻辑是：尽量复用链表尾的 sds，如果它空间不够的话，那就再开个 sds</p><p>要注意的是 addReply 只负责把要回复的内容往 buffer 中写好，socket 发的过程跟它无关。</p></li></ol></li></ol><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;总共有 5 个相关文件&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;文件&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;内容&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;
      
    
    </summary>
    
    
      <category term="开源组件" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/"/>
    
      <category term="Redis" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/"/>
    
      <category term="源码阅读" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
      <category term="C" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Redis 源码阅读5_数据类型_object</title>
    <link href="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB5_%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B_object/"/>
    <id>http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB5_%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B_object/</id>
    <published>2020-03-11T12:18:28.175Z</published>
    <updated>2020-03-11T12:19:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 的对象（类型）系统实现。</p><ul><li><a href="#%e6%b6%89%e5%8f%8a%e6%96%87%e4%bb%b6">涉及文件</a></li><li><a href="#%e7%bb%93%e6%9e%84%e4%bd%93">结构体</a></li><li><a href="#api">API</a><ul><li><a href="#%e9%80%9a%e7%94%a8">通用</a><ul><li><a href="#robj-createobjectint-type-void-ptr">robj *createObject(int type, void *ptr);</a></li></ul></li><li><a href="#string">STRING</a></li><li><a href="#list">LIST</a></li><li><a href="#%e5%90%84%e7%a7%8d-free-%e6%96%b9%e6%b3%95">各种 free 方法</a><ul><li><a href="#void-freestringobjectrobj-o">void freeStringObject(robj *o);</a></li><li><a href="#void-freelistobjectrobj-o">void freeListObject(robj *o);</a></li><li><a href="#void-freesetobjectrobj-o">void freeSetObject(robj *o);</a></li><li><a href="#void-freezsetobjectrobj-o">void freeZsetObject(robj *o);</a></li><li><a href="#void-freehashobjectrobj-o">void freeHashObject(robj *o);</a></li></ul></li></ul></li></ul><h2 id="涉及文件"><a href="#涉及文件" class="headerlink" title="涉及文件"></a>涉及文件</h2><p><code>object.c</code></p><p><code>redis.h</code></p><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_LRU_BITS 24</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象最后一次被访问的时间</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:REDIS_LRU_BITS; <span class="comment">/* lru time (relative to server.lruclock) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向实际值的指针</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>使用了 c 语言中的按位分配变量，节省空间</p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h3><h4 id="robj-createObject-int-type-void-ptr"><a href="#robj-createObject-int-type-void-ptr" class="headerlink" title="robj *createObject(int type, void *ptr);"></a>robj *createObject(int type, void *ptr);</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建一个新 robj 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">robj *<span class="title">createObject</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    robj *o = zmalloc(<span class="keyword">sizeof</span>(*o));</span><br><span class="line"></span><br><span class="line">    o-&gt;type = type;</span><br><span class="line">    o-&gt;encoding = REDIS_ENCODING_RAW;</span><br><span class="line">    o-&gt;ptr = ptr;</span><br><span class="line">    o-&gt;refcount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the LRU to the current lruclock (minutes resolution). */</span></span><br><span class="line">    o-&gt;lru = LRU_CLOCK();</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="STRING"><a href="#STRING" class="headerlink" title="STRING"></a>STRING</h3><ul><li>robj *createStringObject(char *ptr, size_t len)</li><li>robj *createRawStringObject(char *ptr, size_t len)</li><li>robj *createEmbeddedStringObject(char *ptr, size_t len)</li><li>robj *createStringObjectFromLongLong(long long value)</li><li>robj *createStringObjectFromLongDouble(long double value)</li><li>robj *dupStringObject(robj *o)</li></ul><p>STRING 类型的底层结构一共有三种：</p><ul><li>REDIS_ENCODING_RAW: SDS</li><li>REDIS_ENCODING_EMBSTR：SDS，但是经过了 embstr 编码</li><li>REDIS_ENCODING_INT:整数值</li></ul><p>随便看一个</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 REDIS_ENCODING_EMBSTR 编码的字符对象</span></span><br><span class="line"><span class="comment">// 这个字符串对象中的 sds 会和字符串对象的 redisObject 结构一起分配</span></span><br><span class="line"><span class="comment">// 因此这个字符也是不可修改的</span></span><br><span class="line"><span class="function">robj *<span class="title">createEmbeddedStringObject</span><span class="params">(<span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    robj *o = zmalloc(<span class="keyword">sizeof</span>(robj) + <span class="keyword">sizeof</span>(struct sdshdr) + len + <span class="number">1</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span> *) (<span class="title">o</span> + 1);</span></span><br><span class="line"></span><br><span class="line">    o-&gt;type = REDIS_STRING;</span><br><span class="line">    o-&gt;encoding = REDIS_ENCODING_EMBSTR;</span><br><span class="line">    o-&gt;ptr = sh + <span class="number">1</span>;</span><br><span class="line">    o-&gt;refcount = <span class="number">1</span>;</span><br><span class="line">    o-&gt;lru = LRU_CLOCK();</span><br><span class="line"></span><br><span class="line">    sh-&gt;len = len;</span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(sh-&gt;buf, ptr, len);</span><br><span class="line">        sh-&gt;buf[len] = <span class="string">'\0'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">memset</span>(sh-&gt;buf, <span class="number">0</span>, len + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法把字符串对象和sds的内存分配到一起，然后把字符串拷贝到 sds 的 buf 中</p><h3 id="LIST"><a href="#LIST" class="headerlink" title="LIST"></a>LIST</h3><ul><li>robj *createListObject(void)</li><li>robj *createZiplistObject(void)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建一个 LINKEDLIST 编码的列表对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">robj *<span class="title">createListObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span> *l = listCreate();</span><br><span class="line"></span><br><span class="line">    robj *o = createObject(REDIS_LIST, l);</span><br><span class="line"></span><br><span class="line">    listSetFreeMethod(l, decrRefCountVoid);</span><br><span class="line"></span><br><span class="line">    o-&gt;encoding = REDIS_ENCODING_LINKEDLIST;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 作用于特定数据结构的释放函数包装</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrRefCountVoid</span><span class="params">(<span class="keyword">void</span> *o)</span> </span>&#123;</span><br><span class="line">    decrRefCount(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 为对象的引用计数减一</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当对象的引用计数降为 0 时，释放对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrRefCount</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;refcount &lt;= <span class="number">0</span>) redisPanic(<span class="string">"decrRefCount against refcount &lt;= 0"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放对象</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;refcount == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (o-&gt;type) &#123;</span><br><span class="line">            <span class="keyword">case</span> REDIS_STRING:</span><br><span class="line">                freeStringObject(o);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> REDIS_LIST:</span><br><span class="line">                freeListObject(o);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> REDIS_SET:</span><br><span class="line">                freeSetObject(o);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> REDIS_ZSET:</span><br><span class="line">                freeZsetObject(o);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> REDIS_HASH:</span><br><span class="line">                freeHashObject(o);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                redisPanic(<span class="string">"Unknown object type"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        zfree(o);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 减少计数</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        o-&gt;refcount--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>挺简单的，重点是把 释放对象 的函数设置好</p><hr><p>各种 Create 基本大同小异，大概都是先 new 一个底层结构，然后设置好 type 和 encoding。</p><p>看看 SET 的字典实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建一个 SET 编码的集合对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">robj *<span class="title">createSetObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    dict *d = dictCreate(&amp;setDictType, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    robj *o = createObject(REDIS_SET, d);</span><br><span class="line"></span><br><span class="line">    o-&gt;encoding = REDIS_ENCODING_HT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建一个新的字典</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">dict *<span class="title">dictCreate</span><span class="params">(dictType *type, <span class="keyword">void</span> *privDataPtr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    dict *d = zmalloc(<span class="keyword">sizeof</span>(*d));</span><br><span class="line"></span><br><span class="line">    _dictInit(d, type, privDataPtr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> dictType setDictType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Sets type hash table */</span></span><br><span class="line">dictType setDictType = &#123;</span><br><span class="line">        dictEncObjHash,            <span class="comment">/* hash function */</span></span><br><span class="line">        <span class="literal">NULL</span>,                      <span class="comment">/* key dup */</span></span><br><span class="line">        <span class="literal">NULL</span>,                      <span class="comment">/* val dup */</span></span><br><span class="line">        dictEncObjKeyCompare,      <span class="comment">/* key compare */</span></span><br><span class="line">        dictRedisObjectDestructor, <span class="comment">/* key destructor */</span></span><br><span class="line">        <span class="literal">NULL</span>                       <span class="comment">/* val destructor */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="各种-free-方法"><a href="#各种-free-方法" class="headerlink" title="各种 free 方法"></a>各种 free 方法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 为对象的引用计数减一</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当对象的引用计数降为 0 时，释放对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrRefCount</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;refcount &lt;= <span class="number">0</span>) redisPanic(<span class="string">"decrRefCount against refcount &lt;= 0"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放对象</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;refcount == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (o-&gt;type) &#123;</span><br><span class="line">            <span class="keyword">case</span> REDIS_STRING:</span><br><span class="line">                freeStringObject(o);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> REDIS_LIST:</span><br><span class="line">                freeListObject(o);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> REDIS_SET:</span><br><span class="line">                freeSetObject(o);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> REDIS_ZSET:</span><br><span class="line">                freeZsetObject(o);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> REDIS_HASH:</span><br><span class="line">                freeHashObject(o);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                redisPanic(<span class="string">"Unknown object type"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        zfree(o);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 减少计数</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        o-&gt;refcount--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="void-freeStringObject-robj-o"><a href="#void-freeStringObject-robj-o" class="headerlink" title="void freeStringObject(robj *o);"></a>void freeStringObject(robj *o);</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 释放字符串对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeStringObject</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_RAW) &#123;</span><br><span class="line">        sdsfree(o-&gt;ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfree</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    zfree(s - <span class="keyword">sizeof</span>(struct sdshdr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="void-freeListObject-robj-o"><a href="#void-freeListObject-robj-o" class="headerlink" title="void freeListObject(robj *o);"></a>void freeListObject(robj *o);</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 释放列表对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeListObject</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (o-&gt;encoding) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> REDIS_ENCODING_LINKEDLIST:</span><br><span class="line">            listRelease((<span class="built_in">list</span> *) o-&gt;ptr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> REDIS_ENCODING_ZIPLIST:</span><br><span class="line">            zfree(o-&gt;ptr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            redisPanic(<span class="string">"Unknown list encoding type"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 释放整个链表，以及链表中所有节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRelease</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    listNode *current, *next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向头指针</span></span><br><span class="line">    current = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="comment">// 遍历整个链表</span></span><br><span class="line">    len = <span class="built_in">list</span>-&gt;len;</span><br><span class="line">    <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">        next = current-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有设置值释放函数，那么调用它</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;<span class="built_in">free</span>) &#123;</span><br><span class="line">            <span class="built_in">list</span>-&gt;<span class="built_in">free</span>(current-&gt;value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放节点结构</span></span><br><span class="line">        zfree(current);</span><br><span class="line"></span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放链表结构</span></span><br><span class="line">    zfree(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="void-freeSetObject-robj-o"><a href="#void-freeSetObject-robj-o" class="headerlink" title="void freeSetObject(robj *o);"></a>void freeSetObject(robj *o);</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 释放集合对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeSetObject</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (o-&gt;encoding) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> REDIS_ENCODING_HT:</span><br><span class="line">            dictRelease((dict *) o-&gt;ptr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> REDIS_ENCODING_INTSET:</span><br><span class="line">            zfree(o-&gt;ptr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            redisPanic(<span class="string">"Unknown set encoding type"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 删除并释放整个字典</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictRelease</span><span class="params">(dict *d)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 删除并清空两个哈希表</span></span><br><span class="line">    _dictClear(d, &amp;d-&gt;ht[<span class="number">0</span>], <span class="literal">NULL</span>);</span><br><span class="line">    _dictClear(d, &amp;d-&gt;ht[<span class="number">1</span>], <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 释放节点结构</span></span><br><span class="line">    zfree(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _dictClear(dict *d, dictht *ht, <span class="keyword">void</span>(callback)(<span class="keyword">void</span> *)) &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Free all the elements */</span></span><br><span class="line">    <span class="comment">// 遍历整个哈希表</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ht-&gt;<span class="built_in">size</span> &amp;&amp; ht-&gt;used &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">        dictEntry *he, *nextHe;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (callback &amp;&amp; (i &amp; <span class="number">65535</span>) == <span class="number">0</span>) callback(d-&gt;privdata);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跳过空索引</span></span><br><span class="line">        <span class="keyword">if</span> ((he = ht-&gt;table[i]) == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历整个链表</span></span><br><span class="line">        <span class="comment">// T = O(1)</span></span><br><span class="line">        <span class="keyword">while</span> (he) &#123;</span><br><span class="line">            nextHe = he-&gt;next;</span><br><span class="line">            <span class="comment">// 删除键</span></span><br><span class="line">            dictFreeKey(d, he);</span><br><span class="line">            <span class="comment">// 删除值</span></span><br><span class="line">            dictFreeVal(d, he);</span><br><span class="line">            <span class="comment">// 释放节点</span></span><br><span class="line">            zfree(he);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新已使用节点计数</span></span><br><span class="line">            ht-&gt;used--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理下个节点</span></span><br><span class="line">            he = nextHe;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Free the table and the allocated cache structure */</span></span><br><span class="line">    <span class="comment">// 释放哈希表结构</span></span><br><span class="line">    zfree(ht-&gt;table);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Re-initialize the table */</span></span><br><span class="line">    <span class="comment">// 重置哈希表属性</span></span><br><span class="line">    _dictReset(ht);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DICT_OK; <span class="comment">/* never fails */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="void-freeZsetObject-robj-o"><a href="#void-freeZsetObject-robj-o" class="headerlink" title="void freeZsetObject(robj *o);"></a>void freeZsetObject(robj *o);</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 释放有序集合对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeZsetObject</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    zset *zs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (o-&gt;encoding) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> REDIS_ENCODING_SKIPLIST:</span><br><span class="line">            zs = o-&gt;ptr;</span><br><span class="line">            dictRelease(zs-&gt;dict);</span><br><span class="line">            zslFree(zs-&gt;zsl);</span><br><span class="line">            zfree(zs);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> REDIS_ENCODING_ZIPLIST:</span><br><span class="line">            zfree(o-&gt;ptr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            redisPanic(<span class="string">"Unknown sorted set encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 释放给定跳跃表，以及表中的所有节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zslFree</span><span class="params">(zskiplist *zsl)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    zskiplistNode *node = zsl-&gt;header-&gt;level[<span class="number">0</span>].forward, *next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放表头</span></span><br><span class="line">    zfree(zsl-&gt;header);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放表中所有节点</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line"></span><br><span class="line">        next = node-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line"></span><br><span class="line">        zslFreeNode(node);</span><br><span class="line"></span><br><span class="line">        node = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放跳跃表结构</span></span><br><span class="line">    zfree(zsl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="void-freeHashObject-robj-o"><a href="#void-freeHashObject-robj-o" class="headerlink" title="void freeHashObject(robj *o);"></a>void freeHashObject(robj *o);</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 释放哈希对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeHashObject</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (o-&gt;encoding) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> REDIS_ENCODING_HT:</span><br><span class="line">            dictRelease((dict *) o-&gt;ptr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> REDIS_ENCODING_ZIPLIST:</span><br><span class="line">            zfree(o-&gt;ptr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            redisPanic(<span class="string">"Unknown hash encoding type"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Redis 的对象（类型）系统实现。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%e6%b6%89%e5%8f%8a%e6%96%87%e4%bb%b6&quot;&gt;涉及文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%e7%bb%93%e6%9e%84%e4%bd%93&quot;&gt;
      
    
    </summary>
    
    
      <category term="开源组件" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/"/>
    
      <category term="Redis" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/"/>
    
      <category term="源码阅读" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
      <category term="C" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Redis 源码阅读4_数据结构_skiplist</title>
    <link href="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB4_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_skiplist/"/>
    <id>http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB4_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_skiplist/</id>
    <published>2020-03-11T12:16:37.455Z</published>
    <updated>2020-03-11T12:17:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>跳跃表</p><ul><li><a href="#%e6%b6%89%e5%8f%8a%e6%96%87%e4%bb%b6">涉及文件</a></li><li><a href="#%e7%bb%93%e6%9e%84%e4%bd%93">结构体</a><ul><li><a href="#zskiplistnode">zskiplistNode</a></li><li><a href="#zskiplist">zskiplist</a></li></ul></li><li><a href="#api">API</a></li><li><a href="#zskiplist-zslcreatevoid">zskiplist *zslCreate(void);</a></li><li><a href="#zskiplistnode-zslinsertzskiplist-zsl-double-score-robj-obj">zskiplistNode *zslInsert(zskiplist *zsl, double score, robj *obj);</a></li><li><a href="#int-zsldeletezskiplist-zsl-double-score-robj-obj">int zslDelete(zskiplist *zsl, double score, robj *obj);</a></li></ul><h2 id="涉及文件"><a href="#涉及文件" class="headerlink" title="涉及文件"></a>涉及文件</h2><p><code>redis.h</code></p><p><code>t_zset.c</code></p><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="zskiplistNode"><a href="#zskiplistNode" class="headerlink" title="zskiplistNode"></a>zskiplistNode</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 跳跃表节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line"></span><br><span class="line">    &#125; level[];</span><br><span class="line"></span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure><h3 id="zskiplist"><a href="#zskiplist" class="headerlink" title="zskiplist"></a>zskiplist</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 跳跃表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表头节点和表尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表中节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表中层数最大的节点的层数</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line"></span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>zskiplist *zslCreate(void);</p><p>void zslFree(zskiplist *zsl);</p><p>zskiplistNode *zslInsert(zskiplist *zsl, double score, robj *obj);</p><p>unsigned char *zzlInsert(unsigned char *zl, robj *ele, double score);</p><p>int zslDelete(zskiplist *zsl, double score, robj *obj);</p><h2 id="zskiplist-zslCreate-void"><a href="#zskiplist-zslCreate-void" class="headerlink" title="zskiplist *zslCreate(void);"></a>zskiplist *zslCreate(void);</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建并返回一个新的跳跃表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">zskiplist *<span class="title">zslCreate</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配空间</span></span><br><span class="line">    zsl = zmalloc(<span class="keyword">sizeof</span>(*zsl));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置高度和起始层数</span></span><br><span class="line">    zsl-&gt;level = <span class="number">1</span>;</span><br><span class="line">    zsl-&gt;length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化表头节点</span></span><br><span class="line">    <span class="comment">// T = O(1)</span></span><br><span class="line">    zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; ZSKIPLIST_MAXLEVEL; j++) &#123;</span><br><span class="line">        zsl-&gt;header-&gt;level[j].forward = <span class="literal">NULL</span>;</span><br><span class="line">        zsl-&gt;header-&gt;level[j].span = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    zsl-&gt;header-&gt;backward = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置表尾</span></span><br><span class="line">    zsl-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> zsl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建一个层数为 level 的跳跃表节点，</span></span><br><span class="line"><span class="comment"> * 并将节点的成员对象设置为 obj ，分值设置为 score 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值为新创建的跳跃表节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslCreateNode</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">double</span> score, robj *obj)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配空间</span></span><br><span class="line">    zskiplistNode *zn = zmalloc(<span class="keyword">sizeof</span>(*zn) + level * <span class="keyword">sizeof</span>(struct zskiplistLevel));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置属性</span></span><br><span class="line">    zn-&gt;score = score;</span><br><span class="line">    zn-&gt;obj = obj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> zn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各种初始化，把 header 结点创建出来填充好</p><h2 id="zskiplistNode-zslInsert-zskiplist-zsl-double-score-robj-obj"><a href="#zskiplistNode-zslInsert-zskiplist-zsl-double-score-robj-obj" class="headerlink" title="zskiplistNode *zslInsert(zskiplist *zsl, double score, robj *obj);"></a>zskiplistNode *zslInsert(zskiplist *zsl, double score, robj *obj);</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建一个成员为 obj ，分值为 score 的新节点，</span></span><br><span class="line"><span class="comment"> * 并将这个新节点插入到跳跃表 zsl 中。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 函数的返回值为新节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T_wrost = O(N^2), T_avg = O(N log N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslInsert</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, robj *obj)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rank[ZSKIPLIST_MAXLEVEL];</span><br><span class="line">    <span class="keyword">int</span> i, level;</span><br><span class="line"></span><br><span class="line">    redisAssert(!isnan(score));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在各个层查找节点的插入位置</span></span><br><span class="line">    <span class="comment">// T_wrost = O(N^2), T_avg = O(N log N)</span></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* store rank that is crossed to reach the insert position */</span></span><br><span class="line">        <span class="comment">// 如果 i 不是 zsl-&gt;level-1 层</span></span><br><span class="line">        <span class="comment">// 那么 i 层的起始 rank 值为 i+1 层的 rank 值</span></span><br><span class="line">        <span class="comment">// 各个层的 rank 值一层层累积</span></span><br><span class="line">        <span class="comment">// 最终 rank[0] 的值加一就是新节点的前置节点的排位</span></span><br><span class="line">        <span class="comment">// rank[0] 会在后面成为计算 span 值和 rank 值的基础</span></span><br><span class="line">        rank[i] = i == (zsl-&gt;level - <span class="number">1</span>) ? <span class="number">0</span> : rank[i + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 沿着前进指针遍历跳跃表</span></span><br><span class="line">        <span class="comment">// T_wrost = O(N^2), T_avg = O(N log N)</span></span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">               (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                <span class="comment">// 比对分值</span></span><br><span class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                 <span class="comment">// 比对成员， T = O(N)</span></span><br><span class="line">                 compareStringObjects(x-&gt;level[i].forward-&gt;obj, obj) &lt; <span class="number">0</span>))) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录沿途跨越了多少个节点</span></span><br><span class="line">            rank[i] += x-&gt;level[i].span;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 移动至下一指针</span></span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录将要和新节点相连接的节点</span></span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* we assume the key is not already inside, since we allow duplicated</span></span><br><span class="line"><span class="comment">     * scores, and the re-insertion of score and redis object should never</span></span><br><span class="line"><span class="comment">     * happen since the caller of zslInsert() should test in the hash table</span></span><br><span class="line"><span class="comment">     * if the element is already inside or not. </span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * zslInsert() 的调用者会确保同分值且同成员的元素不会出现，</span></span><br><span class="line"><span class="comment">     * 所以这里不需要进一步进行检查，可以直接创建新元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取一个随机值作为新节点的层数</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    level = zslRandomLevel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新节点的层数比表中其他节点的层数都要大</span></span><br><span class="line">    <span class="comment">// 那么初始化表头节点中未使用的层，并将它们记录到 update 数组中</span></span><br><span class="line">    <span class="comment">// 将来也指向新节点</span></span><br><span class="line">    <span class="keyword">if</span> (level &gt; zsl-&gt;level) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化未使用层</span></span><br><span class="line">        <span class="comment">// T = O(1)</span></span><br><span class="line">        <span class="keyword">for</span> (i = zsl-&gt;level; i &lt; level; i++) &#123;</span><br><span class="line">            rank[i] = <span class="number">0</span>;</span><br><span class="line">            update[i] = zsl-&gt;header;</span><br><span class="line">            update[i]-&gt;level[i].span = zsl-&gt;length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新表中节点最大层数</span></span><br><span class="line">        zsl-&gt;level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新节点</span></span><br><span class="line">    x = zslCreateNode(level, score, obj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将前面记录的指针指向新节点，并做相应的设置</span></span><br><span class="line">    <span class="comment">// T = O(1)</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置新节点的 forward 指针</span></span><br><span class="line">        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将沿途记录的各个节点的 forward 指针指向新节点</span></span><br><span class="line">        update[i]-&gt;level[i].forward = x;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* update span covered by update[i] as x is inserted here */</span></span><br><span class="line">        <span class="comment">// 计算新节点跨越的节点数量</span></span><br><span class="line">        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="number">0</span>] - rank[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新新节点插入之后，沿途节点的 span 值</span></span><br><span class="line">        <span class="comment">// 其中的 +1 计算的是新节点</span></span><br><span class="line">        update[i]-&gt;level[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* increment span for untouched levels */</span></span><br><span class="line">    <span class="comment">// 未接触的节点的 span 值也需要增一，这些节点直接从表头指向新节点</span></span><br><span class="line">    <span class="comment">// T = O(1)</span></span><br><span class="line">    <span class="keyword">for</span> (i = level; i &lt; zsl-&gt;level; i++) &#123;</span><br><span class="line">        update[i]-&gt;level[i].span++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置新节点的后退指针</span></span><br><span class="line">    x-&gt;backward = (update[<span class="number">0</span>] == zsl-&gt;header) ? <span class="literal">NULL</span> : update[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward)</span><br><span class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        zsl-&gt;tail = x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳跃表的节点计数增一</span></span><br><span class="line">    zsl-&gt;length++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>首先是找对于每一个 level，新插入的结点应该放在哪：具体做法是从最高层(跨度最大)，向下出溜，每一层的位置记录在 update 数组中，这个位置是恰好比要插入结点要一点点的位置</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在各个层查找节点的插入位置</span></span><br><span class="line"><span class="comment">// T_wrost = O(N^2), T_avg = O(N log N)</span></span><br><span class="line">x = zsl-&gt;header;</span><br><span class="line"><span class="keyword">for</span> (i = zsl-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* store rank that is crossed to reach the insert position */</span></span><br><span class="line">    <span class="comment">// 如果 i 不是 zsl-&gt;level-1 层</span></span><br><span class="line">    <span class="comment">// 那么 i 层的起始 rank 值为 i+1 层的 rank 值</span></span><br><span class="line">    <span class="comment">// 各个层的 rank 值一层层累积</span></span><br><span class="line">    <span class="comment">// 最终 rank[0] 的值加一就是新节点的前置节点的排位</span></span><br><span class="line">    <span class="comment">// rank[0] 会在后面成为计算 span 值和 rank 值的基础</span></span><br><span class="line">    rank[i] = i == (zsl-&gt;level - <span class="number">1</span>) ? <span class="number">0</span> : rank[i + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 沿着前进指针遍历跳跃表</span></span><br><span class="line">    <span class="comment">// T_wrost = O(N^2), T_avg = O(N log N)</span></span><br><span class="line">    <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">           (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">            <span class="comment">// 比对分值</span></span><br><span class="line">            (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">             <span class="comment">// 比对成员， T = O(N)</span></span><br><span class="line">             compareStringObjects(x-&gt;level[i].forward-&gt;obj, obj) &lt; <span class="number">0</span>))) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录沿途跨越了多少个节点</span></span><br><span class="line">        rank[i] += x-&gt;level[i].span;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动至下一指针</span></span><br><span class="line">        x = x-&gt;level[i].forward;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录将要和新节点相连接的节点</span></span><br><span class="line">    update[i] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后创建新结点，随机一个 level 值，把链重新穿好</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">level = zslRandomLevel();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果新节点的层数比表中其他节点的层数都要大</span></span><br><span class="line"><span class="comment">// 那么初始化表头节点中未使用的层，并将它们记录到 update 数组中</span></span><br><span class="line"><span class="comment">// 将来也指向新节点</span></span><br><span class="line"><span class="keyword">if</span> (level &gt; zsl-&gt;level) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化未使用层</span></span><br><span class="line">    <span class="comment">// T = O(1)</span></span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level; i &lt; level; i++) &#123;</span><br><span class="line">        rank[i] = <span class="number">0</span>;</span><br><span class="line">        update[i] = zsl-&gt;header;</span><br><span class="line">        update[i]-&gt;level[i].span = zsl-&gt;length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新表中节点最大层数</span></span><br><span class="line">    zsl-&gt;level = level;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新节点</span></span><br><span class="line">x = zslCreateNode(level, score, obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将前面记录的指针指向新节点，并做相应的设置</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置新节点的 forward 指针</span></span><br><span class="line">    x-&gt;level[i].forward = update[i]-&gt;level[i].forward;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将沿途记录的各个节点的 forward 指针指向新节点</span></span><br><span class="line">    update[i]-&gt;level[i].forward = x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* update span covered by update[i] as x is inserted here */</span></span><br><span class="line">    <span class="comment">// 计算新节点跨越的节点数量</span></span><br><span class="line">    x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="number">0</span>] - rank[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新新节点插入之后，沿途节点的 span 值</span></span><br><span class="line">    <span class="comment">// 其中的 +1 计算的是新节点</span></span><br><span class="line">    update[i]-&gt;level[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后做点收尾工作，设置一下各种东西</p></li></ul><h2 id="int-zslDelete-zskiplist-zsl-double-score-robj-obj"><a href="#int-zslDelete-zskiplist-zsl-double-score-robj-obj" class="headerlink" title="int zslDelete(zskiplist *zsl, double score, robj *obj);"></a>int zslDelete(zskiplist *zsl, double score, robj *obj);</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 从跳跃表 zsl 中删除包含给定节点 score 并且带有指定对象 obj 的节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T_wrost = O(N^2), T_avg = O(N log N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslDelete</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, robj *obj)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历跳跃表，查找目标节点，并记录所有沿途节点</span></span><br><span class="line">    <span class="comment">// T_wrost = O(N^2), T_avg = O(N log N)</span></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历跳跃表的复杂度为 T_wrost = O(N), T_avg = O(log N)</span></span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">               (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                <span class="comment">// 比对分值</span></span><br><span class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                 <span class="comment">// 比对对象，T = O(N)</span></span><br><span class="line">                 compareStringObjects(x-&gt;level[i].forward-&gt;obj, obj) &lt; <span class="number">0</span>)))</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 沿着前进指针移动</span></span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录沿途节点</span></span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We may have multiple elements with the same score, what we need</span></span><br><span class="line"><span class="comment">     * is to find the element with both the right score and object. </span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 检查找到的元素 x ，只有在它的分值和对象都相同时，才将它删除。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    x = x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">    <span class="keyword">if</span> (x &amp;&amp; score == x-&gt;score &amp;&amp; equalStringObjects(x-&gt;obj, obj)) &#123;</span><br><span class="line">        <span class="comment">// T = O(1)</span></span><br><span class="line">        zslDeleteNode(zsl, x, update);</span><br><span class="line">        <span class="comment">// T = O(1)</span></span><br><span class="line">        zslFreeNode(x);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* not found */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* not found */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>首先和 insert 差不多，也是先找到各层的待删除位置</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">x = zsl-&gt;header;</span><br><span class="line"><span class="keyword">for</span> (i = zsl-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历跳跃表的复杂度为 T_wrost = O(N), T_avg = O(log N)</span></span><br><span class="line">    <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">           (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">            <span class="comment">// 比对分值</span></span><br><span class="line">            (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">             <span class="comment">// 比对对象，T = O(N)</span></span><br><span class="line">             compareStringObjects(x-&gt;level[i].forward-&gt;obj, obj) &lt; <span class="number">0</span>)))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 沿着前进指针移动</span></span><br><span class="line">        x = x-&gt;level[i].forward;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录沿途节点</span></span><br><span class="line">    update[i] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>由于最底层的间隔是 1，所以被删除的结点如果存在的话，只能是 <code>x = x-&gt;level[0].forward;</code></p></li><li><p>如果是它的话，就拆链 zslDeleteNode</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zslDeleteNode</span><span class="params">(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新所有和被删除节点 x 有关的节点的指针，解除它们之间的关系</span></span><br><span class="line">    <span class="comment">// T = O(1)</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; zsl-&gt;level; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (update[i]-&gt;level[i].forward == x) &#123;</span><br><span class="line">            update[i]-&gt;level[i].span += x-&gt;level[i].span - <span class="number">1</span>;</span><br><span class="line">            update[i]-&gt;level[i].forward = x-&gt;level[i].forward;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            update[i]-&gt;level[i].span -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新被删除节点 x 的前进和后退指针</span></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward) &#123;</span><br><span class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x-&gt;backward;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        zsl-&gt;tail = x-&gt;backward;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新跳跃表最大层数（只在被删除节点是跳跃表中最高的节点时才执行）</span></span><br><span class="line">    <span class="comment">// T = O(1)</span></span><br><span class="line">    <span class="keyword">while</span> (zsl-&gt;level &gt; <span class="number">1</span> &amp;&amp; zsl-&gt;header-&gt;level[zsl-&gt;level - <span class="number">1</span>].forward == <span class="literal">NULL</span>)</span><br><span class="line">    zsl-&gt;level--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳跃表节点计数器减一</span></span><br><span class="line">    zsl-&gt;length--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后把 结点本身 free 掉</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 释放给定的跳跃表节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zslFreeNode</span><span class="params">(zskiplistNode *node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    decrRefCount(node-&gt;obj);</span><br><span class="line">    zfree(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  由于 redis 用了 引用计数，所以 free之前还要看看持有的 robj 是否需要回收</p></li></ul><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;跳跃表&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%e6%b6%89%e5%8f%8a%e6%96%87%e4%bb%b6&quot;&gt;涉及文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%e7%bb%93%e6%9e%84%e4%bd%93&quot;&gt;结构体&lt;/a&gt;&lt;ul&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="开源组件" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/"/>
    
      <category term="Redis" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/"/>
    
      <category term="源码阅读" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
      <category term="C" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Redis 源码阅读3_数据结构_dict</title>
    <link href="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB3_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_dict/"/>
    <id>http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB3_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_dict/</id>
    <published>2020-03-11T12:14:52.388Z</published>
    <updated>2020-03-11T12:16:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>字典，实现了一个内存哈希表，它支持插入、删除、替换、查找和获取随机元素等操作。哈希表会自动在表的大小的二次方之间进行调整。键的冲突通过链表来解决。</p><ul><li><a href="#%e6%b6%89%e5%8f%8a%e6%96%87%e4%bb%b6">涉及文件</a></li><li><a href="#%e7%bb%93%e6%9e%84%e4%bd%93">结构体</a><ul><li><a href="#dictentry">dictEntry</a></li><li><a href="#dicttype">dictType</a></li><li><a href="#dictht">dictht</a></li><li><a href="#dict">dict</a></li></ul></li><li><a href="#api">API</a><ul><li><a href="#%e5%ae%8f%e5%ae%9a%e4%b9%89">宏定义</a></li><li><a href="#prototypes">Prototypes</a></li></ul></li><li><a href="#dict-dictcreatedicttype-type-void-privdataptr">dict *dictCreate(dictType *type, void *privDataPtr);</a></li><li><a href="#int-dictreplacedict-d-void-key-void-val">int dictReplace(dict *d, void *key, void *val);</a></li></ul><h2 id="涉及文件"><a href="#涉及文件" class="headerlink" title="涉及文件"></a>涉及文件</h2><p><code>dict.h</code> 和 <code>dict.c</code></p><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="dictEntry"><a href="#dictEntry" class="headerlink" title="dictEntry"></a>dictEntry</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 哈希表节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><h3 id="dictType"><a href="#dictType" class="headerlink" title="dictType"></a>dictType</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 字典类型特定函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算哈希值的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制键的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制值的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对比键的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁键的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁值的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line"></span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure><h3 id="dictht"><a href="#dictht" class="headerlink" title="dictht"></a>dictht</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 哈希表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 每个字典都使用两个哈希表，从而实现渐进式 rehash 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">// 总是等于 size - 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line"></span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><h3 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 字典</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rehash 索引</span></span><br><span class="line">    <span class="comment">// 当 rehash 不在进行时，值为 -1</span></span><br><span class="line">    <span class="keyword">int</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目前正在运行的安全迭代器的数量</span></span><br><span class="line">    <span class="keyword">int</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line"></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放给定字典节点的值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictFreeVal(d, entry) \</span></span><br><span class="line">    <span class="keyword">if</span> ((d)-&gt;type-&gt;valDestructor) \</span><br><span class="line">        (d)-&gt;type-&gt;valDestructor((d)-&gt;privdata, (entry)-&gt;v.val)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置给定字典节点的值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictSetVal(d, entry, _val_) do &#123; \</span></span><br><span class="line">    <span class="keyword">if</span> ((d)-&gt;type-&gt;valDup) \</span><br><span class="line">        entry-&gt;v.val = (d)-&gt;type-&gt;valDup((d)-&gt;privdata, _val_); \</span><br><span class="line">    <span class="keyword">else</span> \</span><br><span class="line">        entry-&gt;v.val = (_val_); \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个有符号整数设为节点的值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictSetSignedIntegerVal(entry, _val_) \</span></span><br><span class="line">    <span class="keyword">do</span> &#123; entry-&gt;v.s64 = _val_; &#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个无符号整数设为节点的值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictSetUnsignedIntegerVal(entry, _val_) \</span></span><br><span class="line">    <span class="keyword">do</span> &#123; entry-&gt;v.u64 = _val_; &#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放给定字典节点的键</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictFreeKey(d, entry) \</span></span><br><span class="line">    <span class="keyword">if</span> ((d)-&gt;type-&gt;keyDestructor) \</span><br><span class="line">        (d)-&gt;type-&gt;keyDestructor((d)-&gt;privdata, (entry)-&gt;key)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置给定字典节点的键</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictSetKey(d, entry, _key_) do &#123; \</span></span><br><span class="line">    <span class="keyword">if</span> ((d)-&gt;type-&gt;keyDup) \</span><br><span class="line">        entry-&gt;key = (d)-&gt;type-&gt;keyDup((d)-&gt;privdata, _key_); \</span><br><span class="line">    <span class="keyword">else</span> \</span><br><span class="line">        entry-&gt;key = (_key_); \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比对两个键</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictCompareKeys(d, key1, key2) \</span></span><br><span class="line">    (((d)-&gt;type-&gt;keyCompare) ? \</span><br><span class="line">        (d)-&gt;type-&gt;keyCompare((d)-&gt;privdata, key1, key2) : \</span><br><span class="line">        (key1) == (key2))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算给定键的哈希值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictHashKey(d, key) (d)-&gt;type-&gt;hashFunction(key)</span></span><br><span class="line"><span class="comment">// 返回获取给定节点的键</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictGetKey(he) ((he)-&gt;key)</span></span><br><span class="line"><span class="comment">// 返回获取给定节点的值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictGetVal(he) ((he)-&gt;v.val)</span></span><br><span class="line"><span class="comment">// 返回获取给定节点的有符号整数值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictGetSignedIntegerVal(he) ((he)-&gt;v.s64)</span></span><br><span class="line"><span class="comment">// 返回给定节点的无符号整数值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictGetUnsignedIntegerVal(he) ((he)-&gt;v.u64)</span></span><br><span class="line"><span class="comment">// 返回给定字典的大小</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictSlots(d) ((d)-&gt;ht[0].size+(d)-&gt;ht[1].size)</span></span><br><span class="line"><span class="comment">// 返回字典的已有节点数量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictSize(d) ((d)-&gt;ht[0].used+(d)-&gt;ht[1].used)</span></span><br><span class="line"><span class="comment">// 查看字典是否正在 rehash</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictIsRehashing(ht) ((ht)-&gt;rehashidx != -1)</span></span><br></pre></td></tr></table></figure><h3 id="Prototypes"><a href="#Prototypes" class="headerlink" title="Prototypes"></a>Prototypes</h3><p>dict *dictCreate(dictType *type, void *privDataPtr);</p><p>int dictExpand(dict *d, unsigned long size);</p><p>int dictAdd(dict *d, void *key, void *val);</p><p>dictEntry *dictAddRaw(dict *d, void *key);</p><p>int dictReplace(dict *d, void *key, void *val);</p><p>dictEntry *dictReplaceRaw(dict *d, void *key);</p><p>int dictDelete(dict *d, const void *key);</p><p>int dictDeleteNoFree(dict *d, const void *key);</p><p>void dictRelease(dict *d);</p><p>dictEntry *dictFind(dict *d, const void *key);</p><p>void *dictFetchValue(dict *d, const void *key);</p><p>int dictResize(dict *d);</p><p>dictIterator *dictGetIterator(dict *d);</p><p>dictIterator *dictGetSafeIterator(dict *d);</p><p>dictEntry *dictNext(dictIterator *iter);</p><p>void dictReleaseIterator(dictIterator *iter);</p><p>dictEntry *dictGetRandomKey(dict *d);</p><p>int dictGetRandomKeys(dict <em>d, dictEntry *</em>des, int count);</p><p>void dictPrintStats(dict *d);</p><p>unsigned int dictGenHashFunction(const void *key, int len);</p><p>unsigned int dictGenCaseHashFunction(const unsigned char *buf, int len);</p><p>void dictEmpty(dict *d, void(callback)(void *));</p><p>void dictEnableResize(void);</p><p>void dictDisableResize(void);</p><p>int dictRehash(dict *d, int n);</p><p>int dictRehashMilliseconds(dict *d, int ms);</p><p>void dictSetHashFunctionSeed(unsigned int initval);</p><p>unsigned int dictGetHashFunctionSeed(void);</p><p>unsigned long dictScan(dict *d, unsigned long v, dictScanFunction *fn, void *privdata);</p><h2 id="dict-dictCreate-dictType-type-void-privDataPtr"><a href="#dict-dictCreate-dictType-type-void-privDataPtr" class="headerlink" title="dict *dictCreate(dictType *type, void *privDataPtr);"></a>dict *dictCreate(dictType *type, void *privDataPtr);</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建一个新的字典</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">dict *<span class="title">dictCreate</span><span class="params">(dictType *type, <span class="keyword">void</span> *privDataPtr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    dict *d = zmalloc(<span class="keyword">sizeof</span>(*d));</span><br><span class="line"></span><br><span class="line">    _dictInit(d, type, privDataPtr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 初始化哈希表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> _dictInit(dict *d, dictType *type,</span><br><span class="line">              <span class="keyword">void</span> *privDataPtr) &#123;</span><br><span class="line">    <span class="comment">// 初始化两个哈希表的各项属性值</span></span><br><span class="line">    <span class="comment">// 但暂时还不分配内存给哈希表数组</span></span><br><span class="line">    _dictReset(&amp;d-&gt;ht[<span class="number">0</span>]);</span><br><span class="line">    _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置类型特定函数</span></span><br><span class="line">    d-&gt;type = type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置私有数据</span></span><br><span class="line">    d-&gt;privdata = privDataPtr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置哈希表 rehash 状态</span></span><br><span class="line">    d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置字典的安全迭代器数量</span></span><br><span class="line">    d-&gt;iterators = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 重置（或初始化）给定哈希表的各项属性值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dictReset(dictht *ht) &#123;</span><br><span class="line">    ht-&gt;table = <span class="literal">NULL</span>;</span><br><span class="line">    ht-&gt;<span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">    ht-&gt;sizemask = <span class="number">0</span>;</span><br><span class="line">    ht-&gt;used = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字典的构造函数，需要依赖 dictType *type 和 void *privDataPtr：一个是 字典类型特定函数 ，另一个是私有数据指针。</p><p>设置各种属性，但是哈希表数组的内存不分配。</p><h2 id="int-dictReplace-dict-d-void-key-void-val"><a href="#int-dictReplace-dict-d-void-key-void-val" class="headerlink" title="int dictReplace(dict *d, void *key, void *val);"></a>int dictReplace(dict *d, void *key, void *val);</h2><p>/*</p><ul><li><p>将给定的键值对添加到字典中，如果键已经存在，那么删除旧有的键值对。</p></li><li></li><li><p>如果键值对为全新添加，那么返回 1 。</p></li><li><p>如果键值对是通过对原有的键值对更新得来的，那么返回 0 。</p></li><li></li><li><p>T = O(N)</p></li><li><p>/<br>int dictReplace(dict *d, void *key, void *val) {<br>  dictEntry *entry, auxentry;</p><p>  /* Try to add the element. If the key</p><ul><li><p>does not exists dictAdd will suceed. */<br>// 尝试直接将键值对添加到字典<br>// 如果键 key 不存在的话，添加会成功<br>// T = O(N)<br>if (dictAdd(d, key, val) == DICT_OK)<br> return 1;</p><p>/* It already exists, get the entry <em>/<br>// 运行到这里，说明键 key 已经存在，那么找出包含这个 key 的节点<br>// T = O(1)<br>entry = dictFind(d, key);<br>/</em> Set the new value and free the old one. Note that it is important</p></li><li><p>to do that in this order, as the value may just be exactly the same</p></li><li><p>as the previous one. In this context, think to reference counting,</p></li><li><p>you want to increment (set), and then decrement (free), and not the</p></li><li><p>reverse. */<br>// 先保存原有的值的指针<br>auxentry = *entry;<br>// 然后设置新的值<br>// T = O(1)<br>dictSetVal(d, entry, val);<br>// 然后释放旧值<br>// T = O(1)<br>dictFreeVal(d, &amp;auxentry);</p><p>return 0;<br>}</p></li></ul></li></ul><ul><li><p>首先，尝试直接将键值对添加到字典：如果键 key 不存在的话，添加会成功</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 尝试将给定键值对添加到字典中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 只有给定键 key 不存在于字典时，添加操作才会成功</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 添加成功返回 DICT_OK ，失败返回 DICT_ERR</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 最坏 T = O(N) ，平滩 O(1) </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictAdd</span><span class="params">(dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试添加键到字典，并返回包含了这个键的新哈希节点</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    dictEntry *entry = dictAddRaw(d, key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键已存在，添加失败</span></span><br><span class="line">    <span class="keyword">if</span> (!entry) &#123;</span><br><span class="line">        <span class="keyword">return</span> DICT_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键不存在，设置节点的值</span></span><br><span class="line">    <span class="comment">// T = O(1)</span></span><br><span class="line">    dictSetVal(d, entry, val);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加成功</span></span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 尝试将键插入到字典中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果键已经在字典存在，那么返回 NULL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果键不存在，那么程序创建新的哈希节点，</span></span><br><span class="line"><span class="comment"> * 将节点和键关联，并插入到字典，然后返回节点本身。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">dictEntry *<span class="title">dictAddRaw</span><span class="params">(dict *d, <span class="keyword">void</span> *key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    dictEntry *entry;</span><br><span class="line">    dictht *ht;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果条件允许的话，进行单步 rehash</span></span><br><span class="line">    <span class="comment">// T = O(1)</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) &#123;</span><br><span class="line">        _dictRehashStep(d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算键在哈希表中的索引值</span></span><br><span class="line">    <span class="comment">// 如果值为 -1 ，那么表示键已经存在</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    <span class="keyword">if</span> ((index = _dictKeyIndex(d, key)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// T = O(1)</span></span><br><span class="line">    <span class="comment">// 如果字典正在 rehash ，那么将新键添加到 1 号哈希表</span></span><br><span class="line">    <span class="comment">// 否则，将新键添加到 0 号哈希表</span></span><br><span class="line">    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class="number">1</span>] : &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 为新节点分配空间</span></span><br><span class="line">    entry = zmalloc(<span class="keyword">sizeof</span>(*entry));</span><br><span class="line">    <span class="comment">// 将新节点插入到链表表头</span></span><br><span class="line">    entry-&gt;next = ht-&gt;table[index];</span><br><span class="line">    ht-&gt;table[index] = entry;</span><br><span class="line">    <span class="comment">// 更新哈希表已使用节点数量</span></span><br><span class="line">    ht-&gt;used++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the hash entry fields. */</span></span><br><span class="line">    <span class="comment">// 设置新节点的键</span></span><br><span class="line">    <span class="comment">// T = O(1)</span></span><br><span class="line">    dictSetKey(d, entry, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  首先找找 key 是否已存在</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 返回可以将 key 插入到哈希表的索引位置</span></span><br><span class="line"><span class="comment"> * 如果 key 已经存在于哈希表，那么返回 -1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意，如果字典正在进行 rehash ，那么总是返回 1 号哈希表的索引。</span></span><br><span class="line"><span class="comment"> * 因为在字典进行 rehash 时，新节点总是插入到 1 号哈希表。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _dictKeyIndex(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> h, idx, table;</span><br><span class="line">    dictEntry *he;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Expand the hash table if needed */</span></span><br><span class="line">    <span class="comment">// 单步 rehash</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    <span class="keyword">if</span> (_dictExpandIfNeeded(d) == DICT_ERR)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Compute the key hash value */</span></span><br><span class="line">    <span class="comment">// 计算 key 的哈希值</span></span><br><span class="line">    h = dictHashKey(d, key);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// T = O(1)</span></span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算索引值</span></span><br><span class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找 key 是否存在</span></span><br><span class="line">        <span class="comment">// T = O(1)</span></span><br><span class="line">        he = d-&gt;ht[table].table[idx];</span><br><span class="line">        <span class="keyword">while</span> (he) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dictCompareKeys(d, key, he-&gt;key))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果运行到这里时，说明 0 号哈希表中所有节点都不包含 key</span></span><br><span class="line">        <span class="comment">// 如果这时 rehahs 正在进行，那么继续对 1 号哈希表进行 rehash</span></span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回索引值</span></span><br><span class="line">    <span class="keyword">return</span> idx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  基本思路是先 hash，然后从 ht[0] 和 ht[1] 里面顺着链找</p><p>  如果 key 没找到的话，那就创建一个新的结点，并且把新结点作为链表的头</p><blockquote><p><strong>头插法</strong></p></blockquote>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为新节点分配空间</span></span><br><span class="line">entry = zmalloc(<span class="keyword">sizeof</span>(*entry));</span><br><span class="line"><span class="comment">// 将新节点插入到链表表头</span></span><br><span class="line">entry-&gt;next = ht-&gt;table[index];</span><br><span class="line">ht-&gt;table[index] = entry;</span><br></pre></td></tr></table></figure><p>  然后把 key 设置好就行了</p></li><li><p>如果键不存在，那么创建了一个新的 entry 以后，再把 val 设置好就行了</p></li><li><p>如果键存在，那就找一找包含这个 key 的结点在哪</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 返回字典中包含键 key 的节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 找到返回节点，找不到返回 NULL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">dictEntry *<span class="title">dictFind</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    dictEntry *he;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> h, idx, table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字典（的哈希表）为空</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].<span class="built_in">size</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/* We don't have a table at all */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果条件允许的话，进行单步 rehash</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算键的哈希值</span></span><br><span class="line">    h = dictHashKey(d, key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在字典的哈希表中查找这个键</span></span><br><span class="line">    <span class="comment">// T = O(1)</span></span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算索引值</span></span><br><span class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历给定索引上的链表的所有节点，查找 key</span></span><br><span class="line">        he = d-&gt;ht[table].table[idx];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// T = O(1)</span></span><br><span class="line">        <span class="keyword">while</span> (he) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dictCompareKeys(d, key, he-&gt;key))</span><br><span class="line">                <span class="keyword">return</span> he;</span><br><span class="line"></span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果程序遍历完 0 号哈希表，仍然没找到指定的键的节点</span></span><br><span class="line">        <span class="comment">// 那么程序会检查字典是否在进行 rehash ，</span></span><br><span class="line">        <span class="comment">// 然后才决定是直接返回 NULL ，还是继续查找 1 号哈希表</span></span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行到这里时，说明两个哈希表都没找到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后替换一下</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先保存原有的值的指针</span></span><br><span class="line">auxentry = *entry;</span><br><span class="line"><span class="comment">// 然后设置新的值</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line">dictSetVal(d, entry, val);</span><br><span class="line"><span class="comment">// 然后释放旧值</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line">dictFreeVal(d, &amp;auxentry);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置给定字典节点的值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictSetVal(d, entry, _val_) do &#123; \</span></span><br><span class="line">    <span class="keyword">if</span> ((d)-&gt;type-&gt;valDup) \</span><br><span class="line">        entry-&gt;v.val = (d)-&gt;type-&gt;valDup((d) -&gt;privdata, _val_); \</span><br><span class="line">    <span class="keyword">else</span> \</span><br><span class="line">        entry-&gt;v.val = (_val_); \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放给定字典节点的值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictFreeVal(d, entry) \</span></span><br><span class="line">    <span class="keyword">if</span> ((d)-&gt;type-&gt;valDestructor) \</span><br><span class="line">        (d)-&gt;type-&gt;valDestructor((d)-&gt;privdata, (entry)-&gt;v.val)</span><br></pre></td></tr></table></figure><p>  这里面也是有操作的，要先 SetVal 再 FreeVal，因为新值和旧值有可能是一个，所以要先保存一份，dup，然后再 free</p></li></ul><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;字典，实现了一个内存哈希表，它支持插入、删除、替换、查找和获取随机元素等操作。哈希表会自动在表的大小的二次方之间进行调整。键的冲突通过链表来解决。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%e6%b6%89%e5%8f%8a%e6%96%87%e4%bb%b6&quot;&gt;涉及
      
    
    </summary>
    
    
      <category term="开源组件" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/"/>
    
      <category term="Redis" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/"/>
    
      <category term="源码阅读" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
      <category term="C" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Redis 源码阅读2_数据结构_adlist</title>
    <link href="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB2_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_adlist/"/>
    <id>http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB2_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_adlist/</id>
    <published>2020-03-11T12:13:18.328Z</published>
    <updated>2020-03-11T12:14:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>双端链表</p><ul><li><a href="#%e6%b6%89%e5%8f%8a%e6%96%87%e4%bb%b6">涉及文件</a></li><li><a href="#%e7%bb%93%e6%9e%84%e4%bd%93">结构体</a></li><li><a href="#api">API</a></li><li><a href="#list-listcreatevoid">list *listCreate(void);</a></li><li><a href="#void-listreleaselist-list">void listRelease(list *list);</a></li><li><a href="#list-listinsertnodelist-list-listnode-oldnode-void-value-int-after">list *listInsertNode(list *list, listNode *old_node, void *value, int after);</a></li></ul><h2 id="涉及文件"><a href="#涉及文件" class="headerlink" title="涉及文件"></a>涉及文件</h2><p><code>adlist.h</code> 和 <code>adlist.c</code></p><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 双端链表节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的值</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line"></span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure><p>双链表结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 双端链表结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line"></span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><p>list 中包含三个函数指针 dup、free 和 match ，用于多态实现功能。</p><blockquote><p>注：</p><p>函数指针的声明方法为：<br>返回值类型 ( * 指针变量名) ([形参列表]);</p><p>int func(int x); /* 声明一个函数 */</p><p>int (<em>f) (int x); /</em> 声明一个函数指针 */</p><p>f=func; /* 将func函数的首地址赋给指针f */</p><p>或者使用下面的方法将函数地址赋给函数指针：</p><p>f = &func;</p></blockquote><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>首先是一大堆简单的宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Functions implemented as macros */</span></span><br><span class="line"><span class="comment">// 返回给定链表所包含的节点数量</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listLength(l) ((l)-&gt;len)</span></span><br><span class="line"><span class="comment">// 返回给定链表的表头节点</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listFirst(l) ((l)-&gt;head)</span></span><br><span class="line"><span class="comment">// 返回给定链表的表尾节点</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listLast(l) ((l)-&gt;tail)</span></span><br><span class="line"><span class="comment">// 返回给定节点的前置节点</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listPrevNode(n) ((n)-&gt;prev)</span></span><br><span class="line"><span class="comment">// 返回给定节点的后置节点</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listNextNode(n) ((n)-&gt;next)</span></span><br><span class="line"><span class="comment">// 返回给定节点的值</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listNodeValue(n) ((n)-&gt;value)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将链表 l 的值复制函数设置为 m</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetDupMethod(l, m) ((l)-&gt;dup = (m))</span></span><br><span class="line"><span class="comment">// 将链表 l 的值释放函数设置为 m</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetFreeMethod(l, m) ((l)-&gt;free = (m))</span></span><br><span class="line"><span class="comment">// 将链表的对比函数设置为 m</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetMatchMethod(l, m) ((l)-&gt;match = (m))</span></span><br></pre></td></tr></table></figure><p>然后是真正的部分：</p><p>list *listCreate(void);</p><p>void listRelease(list *list);</p><p>list *listAddNodeHead(list *list, void *value);</p><p>list *listAddNodeTail(list *list, void *value);</p><p>list *listInsertNode(list *list, listNode *old_node, void *value, int after);</p><p>void listDelNode(list *list, listNode *node);</p><p>listIter *listGetIterator(list *list, int direction);</p><p>listNode *listNext(listIter *iter);</p><p>void listReleaseIterator(listIter *iter);</p><p>list *listDup(list *orig);</p><p>listNode *listSearchKey(list *list, void *key);</p><p>listNode *listIndex(list *list, long index);</p><p>void listRewind(list *list, listIter *li);</p><p>void listRewindTail(list *list, listIter *li);</p><p>void listRotate(list *list);</p><h2 id="list-listCreate-void"><a href="#list-listCreate-void" class="headerlink" title="list *listCreate(void);"></a>list *listCreate(void);</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建一个新的链表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 创建成功返回链表，失败返回 NULL 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listCreate</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配内存</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">list</span> = zmalloc(<span class="keyword">sizeof</span>(*<span class="built_in">list</span>))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化属性</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;dup = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">free</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;match = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分配内存和各种初始化，不要被 <code>zmalloc(sizeof(*list)))</code> 骗了， list 是一个指针， <em>list 又变成了 list 本身，所以 `sizeof(</em>list)<code>和</code>sizeof(struct list)` 是一样的。</p><h2 id="void-listRelease-list-list"><a href="#void-listRelease-list-list" class="headerlink" title="void listRelease(list *list);"></a>void listRelease(list *list);</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 释放整个链表，以及链表中所有节点</span><br><span class="line"> *</span><br><span class="line"> * T &#x3D; O(N)</span><br><span class="line"> *&#x2F;</span><br><span class="line">void listRelease(list *list) &#123;</span><br><span class="line">    unsigned long len;</span><br><span class="line">    listNode *current, *next;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 指向头指针</span><br><span class="line">    current &#x3D; list-&gt;head;</span><br><span class="line">    &#x2F;&#x2F; 遍历整个链表</span><br><span class="line">    len &#x3D; list-&gt;len;</span><br><span class="line">    while (len--) &#123;</span><br><span class="line">        next &#x3D; current-&gt;next;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果有设置值释放函数，那么调用它</span><br><span class="line">        if (list-&gt;free) &#123;</span><br><span class="line">            list-&gt;free(current-&gt;value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 释放节点结构</span><br><span class="line">        zfree(current);</span><br><span class="line"></span><br><span class="line">        current &#x3D; next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 释放链表结构</span><br><span class="line">    zfree(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先通过调用多态的 free 函数，释放链表中的结点；然后释放链表结构 <code>zfree(list)</code></p><h2 id="list-listInsertNode-list-list-listNode-old-node-void-value-int-after"><a href="#list-listInsertNode-list-list-listNode-old-node-void-value-int-after" class="headerlink" title="list *listInsertNode(list *list, listNode *old_node, void *value, int after);"></a>list *listInsertNode(list *list, listNode *old_node, void *value, int after);</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建一个包含值 value 的新节点，并将它插入到 old_node 的之前或之后</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果 after 为 0 ，将新节点插入到 old_node 之前。</span></span><br><span class="line"><span class="comment"> * 如果 after 为 1 ，将新节点插入到 old_node 之后。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listInsertNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *old_node, <span class="keyword">void</span> *value, <span class="keyword">int</span> after)</span> </span>&#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新节点</span></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存值</span></span><br><span class="line">    node-&gt;value = value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将新节点添加到给定节点之后</span></span><br><span class="line">    <span class="keyword">if</span> (after) &#123;</span><br><span class="line">        node-&gt;prev = old_node;</span><br><span class="line">        node-&gt;next = old_node-&gt;next;</span><br><span class="line">        <span class="comment">// 给定节点是原表尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;tail == old_node) &#123;</span><br><span class="line">            <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将新节点添加到给定节点之前</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;next = old_node;</span><br><span class="line">        node-&gt;prev = old_node-&gt;prev;</span><br><span class="line">        <span class="comment">// 给定节点是原表头节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;head == old_node) &#123;</span><br><span class="line">            <span class="built_in">list</span>-&gt;head = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新新节点的前置指针</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新新节点的后置指针</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        node-&gt;next-&gt;prev = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新链表节点数</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>挺简单的，就是拆链，插入，重组链</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;双端链表&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%e6%b6%89%e5%8f%8a%e6%96%87%e4%bb%b6&quot;&gt;涉及文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%e7%bb%93%e6%9e%84%e4%bd%93&quot;&gt;结构体&lt;/a&gt;&lt;/li&gt;
&lt;
      
    
    </summary>
    
    
      <category term="开源组件" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/"/>
    
      <category term="Redis" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/"/>
    
      <category term="源码阅读" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
      <category term="C" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Redis 源码阅读1_数据结构_sds</title>
    <link href="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB1_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_sds/"/>
    <id>http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB1_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_sds/</id>
    <published>2020-03-11T12:10:26.585Z</published>
    <updated>2020-03-11T12:11:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>简单动态字符串 sds</p><ul><li><a href="#%e6%b6%89%e5%8f%8a%e6%96%87%e4%bb%b6">涉及文件</a></li><li><a href="#%e7%bb%93%e6%9e%84%e4%bd%93">结构体</a></li><li><a href="#api">API</a></li><li><a href="#sds-sdsnewconst-char-init">sds sdsnew(const char *init);</a></li><li><a href="#sds-sdscatsds-s-const-char-t">sds sdscat(sds s, const char *t);</a></li><li><a href="#void-sdsclearsds-s">void sdsclear(sds s);</a></li></ul><h2 id="涉及文件"><a href="#涉及文件" class="headerlink" title="涉及文件"></a>涉及文件</h2><p><code>sds.h</code> 和 <code>sds.c</code></p><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 保存字符串对象的结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf 中已占用空间的长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf 中剩余可用空间的长度</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据空间</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>char buf[] 是一个柔性数组结构，统计 sizeof(struct sdshdr) 时不包含 buf（因为也确实不知道）</p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>sds sdsnewlen(const void *init, size_t initlen);</p><p>sds sdsnew(const char *init);</p><p>sds sdsempty(void);</p><p>size_t sdslen(const sds s);</p><p>sds sdsdup(const sds s);</p><p>void sdsfree(sds s);</p><p>size_t sdsavail(const sds s);</p><p>sds sdsgrowzero(sds s, size_t len);</p><p>sds sdscatlen(sds s, const void *t, size_t len);</p><p>sds sdscat(sds s, const char *t);</p><p>sds sdscatsds(sds s, const sds t);</p><p>sds sdscpylen(sds s, const char *t, size_t len);</p><p>sds sdscpy(sds s, const char *t);</p><p>sds sdscatvprintf(sds s, const char *fmt, va_list ap);</p><p>sds sdscatfmt(sds s, char const *fmt, …);</p><p>sds sdstrim(sds s, const char *cset);</p><p>void sdsrange(sds s, int start, int end);</p><p>void sdsupdatelen(sds s);</p><p>void sdsclear(sds s);</p><p>int sdscmp(const sds s1, const sds s2);</p><p>sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count);</p><p>void sdsfreesplitres(sds *tokens, int count);</p><p>void sdstolower(sds s);</p><p>void sdstoupper(sds s);</p><p>sds sdsfromlonglong(long long value);</p><p>sds sdscatrepr(sds s, const char *p, size_t len);</p><p>sds *sdssplitargs(const char *line, int *argc);</p><p>sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen);</p><p>sds sdsjoin(char **argv, int argc, char *sep);</p><p>/* Low level functions exposed to the user API */<br>sds sdsMakeRoomFor(sds s, size_t addlen);</p><p>void sdsIncrLen(sds s, int incr);</p><p>sds sdsRemoveFreeSpace(sds s);</p><p>size_t sdsAllocSize(sds s);</p><h2 id="sds-sdsnew-const-char-init"><a href="#sds-sdsnew-const-char-init" class="headerlink" title="sds sdsnew(const char *init);"></a>sds sdsnew(const char *init);</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 类型别名，用于指向 sdshdr 的 buf 属性</span><br><span class="line"> *&#x2F;</span><br><span class="line">typedef char *sds;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * 根据给定字符串 init ，创建一个包含同样字符串的 sds</span><br><span class="line"> *</span><br><span class="line"> * 参数</span><br><span class="line"> *  init ：如果输入为 NULL ，那么创建一个空白 sds</span><br><span class="line"> *         否则，新创建的 sds 中包含和 init 内容相同字符串</span><br><span class="line"> *</span><br><span class="line"> * 返回值</span><br><span class="line"> *  sds ：创建成功返回 sdshdr 相对应的 sds</span><br><span class="line"> *        创建失败返回 NULL</span><br><span class="line"> *</span><br><span class="line"> * 复杂度</span><br><span class="line"> *  T &#x3D; O(N)</span><br><span class="line"> *&#x2F;</span><br><span class="line">sds sdsnew(const char *init) &#123;</span><br><span class="line">    size_t initlen &#x3D; (init &#x3D;&#x3D; NULL) ? 0 : strlen(init);</span><br><span class="line">    return sdsnewlen(init, initlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先用 string.h 获取字符串长度，然后看 sdsnewlen 方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 根据给定的初始化字符串 init 和字符串长度 initlen</span></span><br><span class="line"><span class="comment"> * 创建一个新的 sds</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数</span></span><br><span class="line"><span class="comment"> *  init ：初始化字符串指针</span></span><br><span class="line"><span class="comment"> *  initlen ：初始化字符串的长度</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值</span></span><br><span class="line"><span class="comment"> *  sds ：创建成功返回 sdshdr 相对应的 sds</span></span><br><span class="line"><span class="comment"> *        创建失败返回 NULL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 复杂度</span></span><br><span class="line"><span class="comment"> *  T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据是否有初始化内容，选择适当的内存分配方式</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    <span class="keyword">if</span> (init) &#123;</span><br><span class="line">        <span class="comment">// zmalloc 不初始化所分配的内存</span></span><br><span class="line">        sh = zmalloc(<span class="keyword">sizeof</span>(struct sdshdr) + initlen + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// zcalloc 将分配的内存全部初始化为 0</span></span><br><span class="line">        sh = zcalloc(<span class="keyword">sizeof</span>(struct sdshdr) + initlen + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存分配失败，返回</span></span><br><span class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置初始化长度</span></span><br><span class="line">    sh-&gt;len = initlen;</span><br><span class="line">    <span class="comment">// 新 sds 不预留任何空间</span></span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果有指定初始化内容，将它们复制到 sdshdr 的 buf 中</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</span><br><span class="line">        <span class="built_in">memcpy</span>(sh-&gt;buf, init, initlen);</span><br><span class="line">    <span class="comment">// 以 \0 结尾</span></span><br><span class="line">    sh-&gt;buf[initlen] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 buf 部分，而不是整个 sdshdr</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span> *) sh-&gt;buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>首先进行内存的分配/初始化，zmalloc 和 zcalloc 方法在 zmalloc.h / zmalloc.c 中定义和实现，具体细节未看；</p></li><li><p>然后把 sdshdr 的 len 和 free 属性设置好，用 string.h 中的 memcpy 把原始字符串的内容拷贝一份到 buf 中，然后给末尾添加上 ‘\0’；</p></li><li><p>最后返回的是 sds 的 buf 部分</p></li></ul><h2 id="sds-sdscat-sds-s-const-char-t"><a href="#sds-sdscat-sds-s-const-char-t" class="headerlink" title="sds sdscat(sds s, const char *t);"></a>sds sdscat(sds s, const char *t);</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将给定字符串 t 追加到 sds 的末尾</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 返回值</span></span><br><span class="line"><span class="comment"> *  sds ：追加成功返回新 sds ，失败返回 NULL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 复杂度</span></span><br><span class="line"><span class="comment"> *  T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdscat</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdscatlen(s, t, <span class="built_in">strlen</span>(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将长度为 len 的字符串 t 追加到 sds 的字符串末尾</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值</span></span><br><span class="line"><span class="comment"> *  sds ：追加成功返回新 sds ，失败返回 NULL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 复杂度</span></span><br><span class="line"><span class="comment"> *  T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原有字符串长度</span></span><br><span class="line">    <span class="keyword">size_t</span> curlen = sdslen(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩展 sds 空间</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    s = sdsMakeRoomFor(s, len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存不足？直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制 t 中的内容到字符串后部</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    sh = (<span class="keyword">void</span> *) (s - (<span class="keyword">sizeof</span>(struct sdshdr)));</span><br><span class="line">    <span class="built_in">memcpy</span>(s + curlen, t, len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新属性</span></span><br><span class="line">    sh-&gt;len = curlen + len;</span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = sh-&gt;<span class="built_in">free</span> - len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加新结尾符号</span></span><br><span class="line">    s[curlen + len] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回新 sds</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>首先获取 sds 当前的长度，但是这个也是有点操作的：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">size_t</span> <span class="title">sdslen</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span> *) (<span class="title">s</span> - (<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span><br><span class="line">    <span class="keyword">return</span> sh-&gt;len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  sdshdr 中的 len 属性记录了长度，但是 s 指向的是 buf 部分的首地址，而 sizeof 不包含 buf 部分，所以 <code>struct sdshdr *sh = (void *) (s - (sizeof(struct sdshdr)));</code> 这个操作可以让指针恰好指向 sdshdr 的开头</p></li><li><p>扩展 sds 的空间，这个也是有点操作的</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 对 sds 中 buf 的长度进行扩展，确保在函数执行之后，</span></span><br><span class="line"><span class="comment"> * buf 至少会有 addlen + 1 长度的空余空间</span></span><br><span class="line"><span class="comment"> * （额外的 1 字节是为 \0 准备的）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值</span></span><br><span class="line"><span class="comment"> *  sds ：扩展成功返回扩展后的 sds</span></span><br><span class="line"><span class="comment"> *        扩展失败返回 NULL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 复杂度</span></span><br><span class="line"><span class="comment"> *  T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>, *<span class="title">newsh</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 s 目前的空余空间长度</span></span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">free</span> = sdsavail(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> len, newlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s 目前的空余空间已经足够，无须再进行扩展，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">free</span> &gt;= addlen) &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 s 目前已占用空间的长度</span></span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    sh = (<span class="keyword">void</span> *) (s - (<span class="keyword">sizeof</span>(struct sdshdr)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s 最少需要的长度</span></span><br><span class="line">    newlen = (len + addlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据新长度，为 s 分配新空间所需的大小</span></span><br><span class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class="line">        <span class="comment">// 如果新长度小于 SDS_MAX_PREALLOC </span></span><br><span class="line">        <span class="comment">// 那么为它分配两倍于所需长度的空间</span></span><br><span class="line">        newlen *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则，分配长度为目前长度加上 SDS_MAX_PREALLOC</span></span><br><span class="line">        newlen += SDS_MAX_PREALLOC;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    newsh = zrealloc(sh, <span class="keyword">sizeof</span>(struct sdshdr) + newlen + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存不足，分配失败，返回</span></span><br><span class="line">    <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新 sds 的空余长度</span></span><br><span class="line">    newsh-&gt;<span class="built_in">free</span> = newlen - len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 sds</span></span><br><span class="line">    <span class="keyword">return</span> newsh-&gt;buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  sdshdr 的 free 属性记录了 剩余空间大小，如果空间足够就啥也不干；</p><p>  如果空间不够，要做的事情是 zrealloc，这个方法目标是新分配内存+把原来的 sdshdr 整体拷贝过去 + 释放原有空间</p></li><li><p>现在空间肯定是够了，把字符串放在原来的空间后面，加个 ‘\0’，然后更新 len 和 free 属性</p></li></ul><h2 id="void-sdsclear-sds-s"><a href="#void-sdsclear-sds-s" class="headerlink" title="void sdsclear(sds s);"></a>void sdsclear(sds s);</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在不释放 SDS 的字符串空间的情况下，</span></span><br><span class="line"><span class="comment"> * 重置 SDS 所保存的字符串为空字符串。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 复杂度</span></span><br><span class="line"><span class="comment"> *  T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsclear</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出 sdshdr</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span> *) (<span class="title">s</span> - (<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新计算属性</span></span><br><span class="line">    sh-&gt;<span class="built_in">free</span> += sh-&gt;len;</span><br><span class="line">    sh-&gt;len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将结束符放到最前面（相当于惰性地删除 buf 中的内容）</span></span><br><span class="line">    sh-&gt;buf[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>惰性</strong>空间释放，把属性更新一下，结束符放在 buf 最前面</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;简单动态字符串 sds&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%e6%b6%89%e5%8f%8a%e6%96%87%e4%bb%b6&quot;&gt;涉及文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%e7%bb%93%e6%9e%84%e4%bd%93&quot;&gt;结构体&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="开源组件" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/"/>
    
      <category term="Redis" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/"/>
    
      <category term="源码阅读" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/Redis/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
      <category term="C" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>muduo 多线程模型：一个 Sudoku 服务器演变</title>
    <link href="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%EF%BC%9A%E4%B8%80%E4%B8%AASudoku%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%BC%94%E5%8F%98/"/>
    <id>http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%EF%BC%9A%E4%B8%80%E4%B8%AASudoku%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%BC%94%E5%8F%98/</id>
    <published>2020-03-09T03:01:57.280Z</published>
    <updated>2020-03-09T03:02:43.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接 <a href="https://blog.csdn.net/solstice/article/details/6548228" target="_blank" rel="noopener">https://blog.csdn.net/solstice/article/details/6548228</a></p></blockquote><p>本文以一个 Sudoku Solver 为例，回顾了并发网络服务程序的多种设计方案，并介绍了使用 muduo 网络库编写<strong>多线程服务器</strong>的两种最常用手法。以往的例子展现了 Muduo 在编写单线程并发网络服务程序方面的能力与便捷性，今天我们看一看它在多线程方面的表现。</p><p>本文代码见：<a href="http://code.google.com/p/muduo/source/browse/trunk/examples/sudoku/" target="_blank" rel="noopener">http://code.google.com/p/muduo/source/browse/trunk/examples/sudoku/</a></p><p>下载：<a href="http://muduo.googlecode.com/files/muduo-0.2.5-alpha.tar.gz" target="_blank" rel="noopener">http://muduo.googlecode.com/files/muduo-0.2.5-alpha.tar.gz</a></p><p>关于数独的求解算法见 <a href="https://blog.csdn.net/Solstice/article/details/2096209" target="_blank" rel="noopener">https://blog.csdn.net/Solstice/article/details/2096209</a></p><ul><li><a href="#%e4%b8%80sudoku-solver">一、Sudoku Solver</a><ul><li><a href="#%e5%8d%8f%e8%ae%ae">协议</a></li><li><a href="#%e5%9f%ba%e6%9c%ac%e5%ae%9e%e7%8e%b0">基本实现</a></li></ul></li><li><a href="#%e4%ba%8c%e5%b8%b8%e8%a7%81%e7%9a%84%e5%b9%b6%e5%8f%91%e7%bd%91%e7%bb%9c%e6%9c%8d%e5%8a%a1%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%e6%96%b9%e6%a1%88">二、常见的并发网络服务程序设计方案</a></li><li><a href="#%e4%b8%89%e7%bb%93%e8%af%ad">三、结语</a></li><li><a href="#%e5%9b%9b%e4%bb%a3%e7%a0%81">四、代码</a><ul><li><a href="#%e6%96%b9%e6%a1%88-5%e5%8d%95%e7%ba%bf%e7%a8%8b-reactor">方案 5：单线程 Reactor</a></li><li><a href="#%e6%96%b9%e6%a1%88-8reactor--thread-pool">方案 8：Reactor + Thread Pool</a></li><li><a href="#%e6%96%b9%e6%a1%88-9multiple-reactors">方案 9：Multiple Reactors</a></li></ul></li></ul><h2 id="一、Sudoku-Solver"><a href="#一、Sudoku-Solver" class="headerlink" title="一、Sudoku Solver"></a>一、Sudoku Solver</h2><p>假设有这么一个网络编程任务：写一个求解数独的程序 (Sudoku Solver)，并把它做成一个网络服务。</p><p>Sudoku Solver 是我喜爱的网络编程例子，它曾经出现在《分布式系统部署、监控与进程管理的几重境界》、《Muduo 设计与实现之一：Buffer 类的设计》、《〈多线程服务器的适用场合〉例释与答疑》等文中，它也可以看成是 echo 服务的一个变种（《谈一谈网络编程学习经验》把 echo 列为三大 TCP 网络编程案例之一）。</p><p>写这么一个程序在网络编程方面的难度不高，跟写 echo 服务差不多（从网络连接读入一个 Sudoku 题目，算出答案，再发回给客户），挑战在于怎样做才能发挥现在多核硬件的能力？在谈这个问题之前，让我们先写一个基本的单线程版。</p><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>一个简单的以 /r/n 分隔的文本行协议，<strong>使用 TCP 长连接</strong>，<strong>客户端在不需要服务时主动断开连接</strong>。</p><p>请求：<code>[id:]〈81digits〉/r/n</code></p><p>响应：<code>[id:]〈81digits〉/r/n</code> 或者 <code>[id:]NoSolution/r/n</code></p><p>其中 <code>[id:]</code> 表示可选的 id，<strong>用于区分先后的请求</strong>，以支持 Parallel Pipelining，响应中会回显请求中的 id。Parallel Pipelining 的意义见赖勇浩的《以小见大——那些基于 protobuf 的五花八门的 RPC（2） 》，或者见我写的《分布式系统的工程化开发方法》第 54 页关于 out-of-order RPC 的介绍。</p><p>〈81digits〉是 Sudoku 的棋盘，9x9 个数字，未知数字以 0 表示。</p><p>如果 Sudoku 有解，那么响应是填满数字的棋盘；如果无解，则返回 NoSolution。</p><p><strong>例子1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">请求：000000010400000000020000000000050407008000300001090000300400200050100000000806000&#x2F;r&#x2F;n</span><br><span class="line"></span><br><span class="line">响应：693784512487512936125963874932651487568247391741398625319475268856129743274836159&#x2F;r&#x2F;n</span><br></pre></td></tr></table></figure><p><strong>例子2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">请求：a:000000010400000000020000000000050407008000300001090000300400200050100000000806000&#x2F;r&#x2F;n</span><br><span class="line"></span><br><span class="line">响应：a:693784512487512936125963874932651487568247391741398625319475268856129743274836159&#x2F;r&#x2F;n</span><br></pre></td></tr></table></figure><p><strong>例子3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">请求：b:000000010400000000020000000000050407008000300001090000300400200050100000000806005&#x2F;r&#x2F;n</span><br><span class="line"></span><br><span class="line">响应：b:NoSolution&#x2F;r&#x2F;n</span><br></pre></td></tr></table></figure><p>基于这个文本协议，我们可以用 <code>telnet</code> <strong>模拟客户端来测试</strong> sudoku solver，不需要单独编写 sudoku client。SudokuSolver 的默认端口号是 9981，因为它有 9x9=81 个格子。</p><h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><p>Sudoku 的求解算法见《谈谈数独(Sudoku)》一文，这不是本文的重点。假设我们已经有一个函数能求解 Sudoku，它的原型如下</p><p><code>string solveSudoku(const string&amp; puzzle);</code></p><p>函数的输入是上文的”〈81digits〉”，输出是”〈81digits〉”或”NoSolution”。这个函数是个 pure function，同时也是线程安全的。</p><p>有了这个函数，我们以《Muduo 网络编程示例之零：前言》中的 EchoServer 为蓝本，稍作修改就能得到 SudokuServer。这里只列出最关键的 onMessage() 函数，完整的代码见 <a href="http://code.google.com/p/muduo/source/browse/trunk/examples/sudoku/server_basic.cc" target="_blank" rel="noopener">http://code.google.com/p/muduo/source/browse/trunk/examples/sudoku/server_basic.cc</a> 。onMessage() 的主要功能是<strong>处理协议格式，并调用 solveSudoku() 求解问题</strong>。</p><p><code>server_basic.cc</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn, Buffer *buf, Timestamp)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    LOG_DEBUG &lt;&lt; conn-&gt;name();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">size_t</span> len = buf-&gt;readableBytes();</span><br><span class="line">    <span class="keyword">while</span> (len &gt;= kCells + <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *crlf = buf-&gt;findCRLF();</span><br><span class="line">        <span class="keyword">if</span> (crlf) &#123;</span><br><span class="line">            <span class="function"><span class="built_in">string</span> <span class="title">request</span><span class="params">(buf-&gt;peek(), crlf)</span></span>;</span><br><span class="line">            buf-&gt;retrieveUntil(crlf + <span class="number">2</span>);</span><br><span class="line">            len = buf-&gt;readableBytes();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!processRequest(conn, request)) &#123;</span><br><span class="line">                conn-&gt;send(<span class="string">"Bad Request!\r\n"</span>);</span><br><span class="line">                conn-&gt;shutdown();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; <span class="number">100</span>) &#123;</span><br><span class="line">            conn-&gt;send(<span class="string">"Id too long!\r\n"</span>);</span><br><span class="line">            conn-&gt;shutdown();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>server_basic.cc 是一个<strong>并发服务器</strong>，可以同时服务多个客户连接。<strong>但是它是单线程的</strong>，无法发挥多核硬件的能力。</p><p>Sudoku 是一个<strong>计算密集型</strong>的任务（见《Muduo 设计与实现之一：Buffer 类的设计》中关于其性能的分析），其瓶颈在 CPU。为了让这个单线程 server_basic 程序充分利用 CPU 资源，一个简单的办法是在同一台机器上部署多个 server_basic 进程，让每个进程占用不同的端口，比如在一台 8 核机器上部署 8 个 server_basic 进程，分别占用 9981、9982、……、9988 端口。这样做其实是把难题推给了客户端，因为客户端(s)要自己做负载均衡。再想得远一点，在 8 个 server_basic 前面部署一个 load balancer？似乎小题大做了。</p><p>能不能在一个端口上提供服务，并且又能发挥多核处理器的计算能力呢？当然可以，办法不止一种。</p><h2 id="二、常见的并发网络服务程序设计方案"><a href="#二、常见的并发网络服务程序设计方案" class="headerlink" title="二、常见的并发网络服务程序设计方案"></a>二、常见的并发网络服务程序设计方案</h2><p>W. Richard Stevens 的 UNP2e 第 27 章 Client-Server Design Alternatives 介绍了十来种当时（90 年代末）流行的编写并发网络程序的方案。UNP3e 第 30 章，内容未变，还是这几种。以下简称 UNP CSDA 方案。UNP 这本书主要讲解阻塞式网络编程，在非阻塞方面着墨不多，仅有一章。正确使用 non-blocking IO 需要考虑的问题很多，不适宜直接调用 Sockets API，而需要一个功能完善的网络库支撑。</p><p>随着 2000 年前后第一次互联网浪潮的兴起，业界对高并发 http 服务器的强烈需求大大推动了这一领域的研究，<strong>目前高性能 httpd 普遍采用的是单线程 reactor 方式</strong>。另外一个说法是 IBM Lotus 使用 TCP 长连接协议，而把 Lotus 服务端移植到 Linux 的过程中 IBM 的工程师们大大提高了 Linux 内核在处理并发连接方面的可伸缩性，因为一个公司可能有上万人同时上线，连接到同一台跑着 Lotus server 的 Linux 服务器。</p><p>可伸缩网络编程这个领域其实近十年来没什么新东西，POSA2 已经作了相当全面的总结，另外以下几篇文章也值得参考。</p><p><a href="http://bulk.fefe.de/scalable-networking.pdf" target="_blank" rel="noopener">http://bulk.fefe.de/scalable-networking.pdf</a></p><p><a href="http://www.kegel.com/c10k.html" target="_blank" rel="noopener">http://www.kegel.com/c10k.html</a></p><p><a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf" target="_blank" rel="noopener">http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf</a></p><p>下表是陈硕总结的 10 种常见方案。其中“<strong>多连接互通</strong>”指的是如果开发 chat 服务，多个客户连接之间是否能方便地交换数据（chat 也是《谈一谈网络编程学习经验》中举的三大 TCP 网络编程案例之一）。对于 echo/http/sudoku 这类“连接相互独立”的服务程序，这个功能无足轻重，但是对于 chat 类服务至关重要。“<strong>顺序性</strong>”指的是在 http/sudoku 这类请求-响应服务中，如果客户连接顺序发送多个请求，那么计算得到的多个响应是否按相同的顺序发还给客户（这里指的是在自然条件下，不含刻意同步）。</p><table><thead><tr><th align="center">方案</th><th align="center">model</th><th align="center">UNP 对应</th><th align="center">阻塞/非阻塞</th><th align="center">多进程？</th><th align="center">多线程？</th><th align="center">IO 复用？</th><th align="center">长连接？</th><th align="center">并发性</th><th align="center">多核？</th><th align="center">开销</th><th align="center">多连接互通？</th><th align="center">顺序性</th><th align="center">线程数确定？</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">accept + read/write</td><td align="center">0</td><td align="center">阻塞</td><td align="center">no</td><td align="center">no</td><td align="center">no</td><td align="center">no</td><td align="center">无</td><td align="center">no</td><td align="center">低</td><td align="center">no</td><td align="center">yes</td><td align="center">yes</td><td align="center">一次服务一个客户</td></tr><tr><td align="center">1</td><td align="center">accept + fork</td><td align="center">1</td><td align="center">阻塞</td><td align="center">yes</td><td align="center">no</td><td align="center">no</td><td align="center">yes</td><td align="center">低</td><td align="center">yes</td><td align="center">高</td><td align="center">no</td><td align="center">yes</td><td align="center">no</td><td align="center">process-per-connection</td></tr><tr><td align="center">2</td><td align="center">accept + thread</td><td align="center">6</td><td align="center">阻塞</td><td align="center">no</td><td align="center">yes</td><td align="center">no</td><td align="center">yes</td><td align="center">中</td><td align="center">yes</td><td align="center">中</td><td align="center">yes</td><td align="center">yes</td><td align="center">no</td><td align="center">thread-per-connection</td></tr><tr><td align="center">3</td><td align="center">prefork</td><td align="center">2/3/4/5</td><td align="center">阻塞</td><td align="center">yes</td><td align="center">no</td><td align="center">no</td><td align="center">yes</td><td align="center">低</td><td align="center">yes</td><td align="center">高</td><td align="center">no</td><td align="center">yes</td><td align="center">no</td><td align="center">见 UNP</td></tr><tr><td align="center">4</td><td align="center">pre threaded</td><td align="center">7/8</td><td align="center">阻塞</td><td align="center">no</td><td align="center">yes</td><td align="center">no</td><td align="center">yes</td><td align="center">中</td><td align="center">yes</td><td align="center">中</td><td align="center">yes</td><td align="center">yes</td><td align="center">no</td><td align="center">见 UNP</td></tr><tr><td align="center">5</td><td align="center">poll(reactor)</td><td align="center">sec 6.8</td><td align="center">非阻塞</td><td align="center">no</td><td align="center">no</td><td align="center">yes</td><td align="center">yes</td><td align="center">高</td><td align="center">no</td><td align="center">低</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td><td align="center">单线程 reactor</td></tr><tr><td align="center">6</td><td align="center">reactor + thread-per-task</td><td align="center">无</td><td align="center">非阻塞</td><td align="center">no</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td><td align="center">中</td><td align="center">yes</td><td align="center">中</td><td align="center">yes</td><td align="center">no</td><td align="center">no</td><td align="center">thread-per-request</td></tr><tr><td align="center">7</td><td align="center">reactor + worker thread</td><td align="center">无</td><td align="center">非阻塞</td><td align="center">no</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td><td align="center">中</td><td align="center">yes</td><td align="center">中</td><td align="center">yes</td><td align="center">yes</td><td align="center">no</td><td align="center">worker-thread-per-connection</td></tr><tr><td align="center">8</td><td align="center">reactor + thread pool</td><td align="center">无</td><td align="center">非阻塞</td><td align="center">no</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td><td align="center">高</td><td align="center">yes</td><td align="center">低</td><td align="center">yes</td><td align="center">no</td><td align="center">yes</td><td align="center">主线程 io + 工作线程计算</td></tr><tr><td align="center">9</td><td align="center">multiple reactors</td><td align="center">无</td><td align="center">非阻塞</td><td align="center">no</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td><td align="center">高</td><td align="center">yes</td><td align="center">低</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td><td align="center">one-loop-per-thread</td></tr></tbody></table><p>UNP CSDA 方案归入 0~5。5 也是目前用得很多的单线程 reactor 方案，muduo 对此提供了很好的支持。6 和 7 其实不是实用的方案，只是作为过渡品。8 和 9 是本文重点介绍的方案，其实这两个方案已经在《多线程服务器的常用编程模型》一文中提到过，只不过当时我还没有写 muduo，无法用具体的代码示例来说明。</p><p>在对比各方案之前，我们先看看基本的 micro benchmark 数据（前三项由 lmbench 测得）：</p><ul><li>fork()+exit(): 160us</li><li>pthread_create()+pthread_join(): 12us</li><li>context switch : 1.5us</li><li>sudoku resolve: 100us (根据题目难度不同，浮动范围 20~200us)</li></ul><p>接下来看一下几种方案：</p><ul><li><p><strong>方案 0</strong>：这其实不是并发服务器，而是 iterative 服务器，因为它一次只能服务一个客户。代码见 UNP figure 1.9，UNP 以此为对比其他方案的基准点。这个方案不适合长连接，到是很适合 daytime 这种 write-only 服务。</p></li><li><p><strong>方案 1</strong>：这是传统的 Unix 并发网络编程方案，UNP 称之为 child-per-client 或 fork()-per-client，另外也俗称 process-per-connection。这种方案适合并发连接数不大的情况。至今仍有一些网络服务程序用这种方式实现，比如 PostgreSQL 和 Perforce 的服务端。<strong>这种方案适合“计算响应的工作量远大于 fork() 的开销”这种情况</strong>，比如数据库服务器。这种方案适合长连接，但不太适合短连接，因为 fork() 开销大于求解 sudoku 的用时。</p></li><li><p><strong>方案 2</strong>：<strong>这是传统的 Java 网络编程方案</strong> thread-per-connection，在 Java 1.4 引入 NIO 之前，Java 网络服务程序多采用这种方案。它的初始化开销比方案 1 要小很多。这种方案的伸缩性受到线程数的限制，一两百个还行，几千个的话对操作系统的 scheduler 恐怕是个不小的负担。</p></li><li><p><strong>方案 3</strong>：这是针对方案 1 的优化，UNP 详细分析了几种变化，包括对 accept 惊群问题的考虑。</p></li><li><p><strong>方案 4</strong>：这是对方案 2 的优化，UNP 详细分析了它的几种变化。</p></li></ul><p>以上几种方案都是<strong>阻塞式网络编程</strong>，程序（thread-of-control）通常<strong>阻塞在 read() 上</strong>，等待数据到达。但是 TCP 是个全双工协议，同时支持 read() 和 write() 操作，当一个线程/进程阻塞在 read() 上，但程序又想给这个 TCP 连接发数据，那该怎么办？比如说 echo client，既要从 stdin 读，又要从网络读，当程序正在阻塞地读网络的时候，如何处理键盘输入？又比如 proxy，既要把连接 a 收到的数据发给连接 b，又要把从连接 b 收到的数据发给连接 a，那么到底读哪个？（proxy 是《谈一谈网络编程学习经验》中举的三大 TCP 网络编程案例之一。）</p><p><strong>一种方法</strong>是用两个线程/进程，一个负责读，一个负责写。UNP 也在实现 echo client 时介绍了这种方案。另外见 Python Pinhole 的代码：<a href="http://code.activestate.com/recipes/114642/" target="_blank" rel="noopener">http://code.activestate.com/recipes/114642/</a></p><p>((另一种方法))是使用 <code>IO multiplexing</code>，也就是 select/poll/epoll/kqueue 这一系列的“多路选择器”，让一个 thread-of-control 能处理多个连接。“IO 复用”其实复用的不是 IO 连接，而是复用线程。<strong>使用 select/poll 几乎肯定要配合 non-blocking IO，而使用 non-blocking IO 肯定要使用应用层 buffer</strong>，原因见《Muduo 设计与实现之一：Buffer 类的设计》。这就不是一件轻松的事儿了，如果每个程序都去搞一套自己的 IO multiplexing 机制（本质是 event-driven 事件驱动），这是一种很大的浪费。感谢 Doug Schmidt 为我们总结出了 <code>Reactor</code> 模式，让 event-driven 网络编程有章可循。继而出现了一些通用的 reactor 框架/库，比如 libevent、muduo、Netty、twisted、POE 等等，有了这些库，我想基本不用去编写阻塞式的网络程序了（特殊情况除外，比如 proxy 流量限制）。</p><p>单线程 reactor 的程序结构是（图片取自 Doug Lea 的演讲）：</p><p><img src="/resources/%E5%8D%95%E7%BA%BF%E7%A8%8Breactor%E7%9A%84%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84.gif" alt="单线程 reactor 的程序结构"></p><ul><li><p><strong>方案 5</strong>：基本的单线程 reactor 方案，即前面的 server_basic.cc 程序。本文以它作为对比其他方案的基准点。这种方案的优点是由网络库搞定数据收发，程序只关心业务逻辑；缺点在前面已经谈了：适合 IO 密集的应用，不太适合 CPU 密集的应用，因为较难发挥多核的威力。</p></li><li><p><strong>方案 6</strong>：这是一个过渡方案，收到 Sudoku 请求之后，不在 reactor 线程计算，而是创建一个新线程去计算，以充分利用多核 CPU。这是非常初级的多线程应用，<strong>因为它为每个请求（而不是每个连接）创建了一个新线程</strong>。这个开销可以用线程池来避免，即方案 8。这个方案还有一个特点是 out-of-order，即同时创建多个线程去计算同一个连接上收到的多个请求，那么算出结果的次序是不确定的，可能第 2 个 Sudoku 比较简单，比第 1 个先算出结果。这也是为什么我们在一开始设计协议的时候使用了 id，以便客户端区分 response 对应的是哪个 request。</p></li><li><p><strong>方案 7</strong>：为了让返回结果的顺序确定，我们可以<strong>为每个连接创建一个计算线程，每个连接上的请求固定发给同一个线程去算，先到先得</strong>。这也是一个过渡方案，因为并发连接数受限于线程数目，这个方案或许还不如直接使用阻塞 IO 的 thread-per-connection 方案2。方案 7 与方案 6 的另外一个区别是一个 client 的最大 CPU 占用率，在方案 6 中，一个 connection 上发来的一长串突发请求(burst requests) 可以占满全部 8 个 core；而在方案 7 中，由于每个连接上的请求固定由同一个线程处理，那么它最多占用 12.5% 的 CPU 资源。这两种方案各有优劣，取决于应用场景的需要，到底是<strong>公平性</strong>重要还是<strong>突发性能</strong>重要。这个区别在方案 8 和方案 9 中同样存在，需要根据应用来取舍。</p></li><li><p><strong>方案 8</strong>：为了弥补方案 6 中为每个请求创建线程的缺陷，我们使用固定大小线程池，程序结构如下图。全部的 IO 工作都在一个 reactor 线程完成，而计算任务交给 thread pool。如果计算任务彼此独立，而且 IO 的压力不大，那么这种方案是非常适用的。Sudoku Solver 正好符合。代码见：<a href="http://code.google.com/p/muduo/source/browse/trunk/examples/sudoku/server_threadpool.cc" target="_blank" rel="noopener">http://code.google.com/p/muduo/source/browse/trunk/examples/sudoku/server_threadpool.cc</a> 后文给出了它与方案 9 的区别。</p></li></ul><p><img src="/resources/%E4%B8%BB%E7%BA%BF%E7%A8%8Bio+%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E8%AE%A1%E7%AE%97gif.gif" alt="主线程 io + 工作线程计算"></p><p>如果 IO 的压力比较大，一个 reactor 忙不过来，可以试试 multiple reactors 的方案 9。</p><ul><li><strong>方案 9</strong>：<strong>这是 muduo 内置的多线程方案</strong>，也是 Netty 内置的多线程方案。这种方案的特点是 one loop per thread，<strong>有一个 main reactor 负责 accept 连接，然后把连接挂在某个 sub reactor 中</strong>（muduo 采用 round-robin 的方式来选择 sub reactor），这样该连接的所有操作都在那个 sub reactor 所处的线程中完成。多个连接可能被分派到多个线程中，以充分利用 CPU。Muduo 采用的是固定大小的 reactor pool，池子的大小通常根据 CPU 核数确定，也就是说线程数是固定的，这样程序的总体处理能力不会随连接数增加而下降。另外，由于一个连接完全由一个线程管理，那么请求的顺序性有保证，突发请求也不会占满全部 8 个核（如果需要优化突发请求，可以考虑方案 10）。这种方案把 IO 分派给多个线程，防止出现一个 reactor 的处理能力饱和。与方案 8 的线程池相比，方案 9 减少了进出 thread pool 的两次上下文切换。我认为这是一个适应性很强的多线程 IO 模型，因此把它作为 muduo 的默认线程模型。</li></ul><p><img src="/resources/mutiple_reactors.gif" alt="Multiple Reactors"></p><ul><li><strong>方案 10</strong>：把方案 8 和方案 90 混合，既使用多个 reactors 来处理 IO，又使用线程池来处理计算。这种方案适合既有突发 IO （利用多线程处理多个连接上的 IO），又有突发计算的应用（利用线程池把一个连接上的计算任务分配给多个线程去做）。</li></ul><p><img src="/resources/multiple_reactors_with_thread_pool.gif" alt="Multiple Reactors With Thread Pool"></p><p>这种其实方案看起来复杂，<strong>其实写起来很简单，只要把方案 8 的代码加一行 server_.setThreadNum(numThreads); 就行</strong>，这里就不举例了。</p><h2 id="三、结语"><a href="#三、结语" class="headerlink" title="三、结语"></a>三、结语</h2><p>我在《多线程服务器的常用编程模型》一文中说</p><p>总结起来，我推荐的多线程服务端编程模式为：event loop per thread + thread pool。</p><p>event loop 用作 non-blocking IO 和定时器。<br>thread pool 用来做计算，具体可以是任务队列或消费者-生产者队列。</p><p>当时（2010年2月）我还说“以这种方式写服务器程序，需要一个优质的基于 Reactor 模式的网络库来支撑，我只用过in-house的产品，无从比较并推荐市面上常见的 C++ 网络库，抱歉。”</p><p>现在有了 muduo 网络库，我终于能够用具体的代码示例把思想完整地表达出来。</p><h2 id="四、代码"><a href="#四、代码" class="headerlink" title="四、代码"></a>四、代码</h2><h3 id="方案-5：单线程-Reactor"><a href="#方案-5：单线程-Reactor" class="headerlink" title="方案 5：单线程 Reactor"></a>方案 5：单线程 Reactor</h3><p><code>server_basic.cc</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SudokuServer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SudokuServer(EventLoop *loop, <span class="keyword">const</span> InetAddress &amp;listenAddr)</span><br><span class="line">            : server_(loop, listenAddr, <span class="string">"SudokuServer"</span>),</span><br><span class="line">              startTime_(Timestamp::now()) &#123;</span><br><span class="line">        server_.setConnectionCallback(</span><br><span class="line">                <span class="built_in">std</span>::bind(&amp;SudokuServer::onConnection, <span class="keyword">this</span>, _1));</span><br><span class="line">        server_.setMessageCallback(</span><br><span class="line">                <span class="built_in">std</span>::bind(&amp;SudokuServer::onMessage, <span class="keyword">this</span>, _1, _2, _3));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        server_.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn, Buffer *buf, Timestamp)</span> </span>&#123;</span><br><span class="line">        LOG_DEBUG &lt;&lt; conn-&gt;name();</span><br><span class="line">        <span class="keyword">size_t</span> len = buf-&gt;readableBytes();</span><br><span class="line">        <span class="keyword">while</span> (len &gt;= kCells + <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *crlf = buf-&gt;findCRLF();</span><br><span class="line">            <span class="keyword">if</span> (crlf) &#123;</span><br><span class="line">                <span class="function"><span class="built_in">string</span> <span class="title">request</span><span class="params">(buf-&gt;peek(), crlf)</span></span>;</span><br><span class="line">                buf-&gt;retrieveUntil(crlf + <span class="number">2</span>);</span><br><span class="line">                len = buf-&gt;readableBytes();</span><br><span class="line">                <span class="keyword">if</span> (!processRequest(conn, request)) &#123;</span><br><span class="line">                    conn-&gt;send(<span class="string">"Bad Request!\r\n"</span>);</span><br><span class="line">                    conn-&gt;shutdown();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; <span class="number">100</span>) <span class="comment">// id + ":" + kCells + "\r\n"</span></span><br><span class="line">            &#123;</span><br><span class="line">                conn-&gt;send(<span class="string">"Id too long!\r\n"</span>);</span><br><span class="line">                conn-&gt;shutdown();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">processRequest</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn, <span class="keyword">const</span> <span class="built_in">string</span> &amp;request)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> id;</span><br><span class="line">        <span class="built_in">string</span> puzzle;</span><br><span class="line">        <span class="keyword">bool</span> goodRequest = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span>::const_iterator colon = find(request.begin(), request.end(), <span class="string">':'</span>);</span><br><span class="line">        <span class="keyword">if</span> (colon != request.end()) &#123;</span><br><span class="line">            id.assign(request.begin(), colon);</span><br><span class="line">            puzzle.assign(colon + <span class="number">1</span>, request.end());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            puzzle = request;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (puzzle.size() == implicit_cast&lt;<span class="keyword">size_t</span>&gt;(kCells)) &#123;</span><br><span class="line">            LOG_DEBUG &lt;&lt; conn-&gt;name();</span><br><span class="line">            <span class="built_in">string</span> result = solveSudoku(puzzle);</span><br><span class="line">            <span class="keyword">if</span> (id.empty()) &#123;</span><br><span class="line">                conn-&gt;send(result + <span class="string">"\r\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                conn-&gt;send(id + <span class="string">":"</span> + result + <span class="string">"\r\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            goodRequest = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> goodRequest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TcpServer server_;</span><br><span class="line">    Timestamp startTime_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方案-8：Reactor-Thread-Pool"><a href="#方案-8：Reactor-Thread-Pool" class="headerlink" title="方案 8：Reactor + Thread Pool"></a>方案 8：Reactor + Thread Pool</h3><p><code>server_threadpool.cc</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SudokuServer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SudokuServer(EventLoop *loop, <span class="keyword">const</span> InetAddress &amp;listenAddr, <span class="keyword">int</span> numThreads)</span><br><span class="line">            : server_(loop, listenAddr, <span class="string">"SudokuServer"</span>),</span><br><span class="line">              numThreads_(numThreads),</span><br><span class="line">              startTime_(Timestamp::now()) &#123;</span><br><span class="line"></span><br><span class="line">        server_.setConnectionCallback(</span><br><span class="line">                <span class="built_in">std</span>::bind(&amp;SudokuServer::onConnection, <span class="keyword">this</span>, _1));</span><br><span class="line">        server_.setMessageCallback(</span><br><span class="line">                <span class="built_in">std</span>::bind(&amp;SudokuServer::onMessage, <span class="keyword">this</span>, _1, _2, _3));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LOG_INFO &lt;&lt; <span class="string">"starting "</span> &lt;&lt; numThreads_ &lt;&lt; <span class="string">" threads."</span>;</span><br><span class="line">        threadPool_.start(numThreads_);</span><br><span class="line">        server_.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn, Buffer *buf, Timestamp)</span> </span>&#123;</span><br><span class="line">        LOG_DEBUG &lt;&lt; conn-&gt;name();</span><br><span class="line">        <span class="keyword">size_t</span> len = buf-&gt;readableBytes();</span><br><span class="line">        <span class="keyword">while</span> (len &gt;= kCells + <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *crlf = buf-&gt;findCRLF();</span><br><span class="line">            <span class="keyword">if</span> (crlf) &#123;</span><br><span class="line">                <span class="function"><span class="built_in">string</span> <span class="title">request</span><span class="params">(buf-&gt;peek(), crlf)</span></span>;</span><br><span class="line">                buf-&gt;retrieveUntil(crlf + <span class="number">2</span>);</span><br><span class="line">                len = buf-&gt;readableBytes();</span><br><span class="line">                <span class="keyword">if</span> (!processRequest(conn, request)) &#123;</span><br><span class="line">                    conn-&gt;send(<span class="string">"Bad Request!\r\n"</span>);</span><br><span class="line">                    conn-&gt;shutdown();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; <span class="number">100</span>) &#123;</span><br><span class="line">                conn-&gt;send(<span class="string">"Id too long!\r\n"</span>);</span><br><span class="line">                conn-&gt;shutdown();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">processRequest</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn, <span class="keyword">const</span> <span class="built_in">string</span> &amp;request)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> id;</span><br><span class="line">        <span class="built_in">string</span> puzzle;</span><br><span class="line">        <span class="keyword">bool</span> goodRequest = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span>::const_iterator colon = find(request.begin(), request.end(), <span class="string">':'</span>);</span><br><span class="line">        <span class="keyword">if</span> (colon != request.end()) &#123;</span><br><span class="line">            id.assign(request.begin(), colon);</span><br><span class="line">            puzzle.assign(colon + <span class="number">1</span>, request.end());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            puzzle = request;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (puzzle.size() == implicit_cast&lt;<span class="keyword">size_t</span>&gt;(kCells)) &#123;</span><br><span class="line">            threadPool_.run(<span class="built_in">std</span>::bind(&amp;solve, conn, puzzle, id));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            goodRequest = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> goodRequest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> <span class="built_in">string</span> &amp;puzzle,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> <span class="built_in">string</span> &amp;id)</span> </span>&#123;</span><br><span class="line">        LOG_DEBUG &lt;&lt; conn-&gt;name();</span><br><span class="line">        <span class="built_in">string</span> result = solveSudoku(puzzle);</span><br><span class="line">        <span class="keyword">if</span> (id.empty()) &#123;</span><br><span class="line">            conn-&gt;send(result + <span class="string">"\r\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            conn-&gt;send(id + <span class="string">":"</span> + result + <span class="string">"\r\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TcpServer server_;</span><br><span class="line">    ThreadPool threadPool_;</span><br><span class="line">    <span class="keyword">int</span> numThreads_;</span><br><span class="line">    Timestamp startTime_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方案-9：Multiple-Reactors"><a href="#方案-9：Multiple-Reactors" class="headerlink" title="方案 9：Multiple Reactors"></a>方案 9：Multiple Reactors</h3><p><code>server_multiloop.cc</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SudokuServer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SudokuServer(EventLoop *loop, <span class="keyword">const</span> InetAddress &amp;listenAddr, <span class="keyword">int</span> numThreads)</span><br><span class="line">            : server_(loop, listenAddr, <span class="string">"SudokuServer"</span>),</span><br><span class="line">              numThreads_(numThreads),</span><br><span class="line">              startTime_(Timestamp::now()) &#123;</span><br><span class="line"></span><br><span class="line">        server_.setConnectionCallback(</span><br><span class="line">                <span class="built_in">std</span>::bind(&amp;SudokuServer::onConnection, <span class="keyword">this</span>, _1));</span><br><span class="line">        server_.setMessageCallback(</span><br><span class="line">                <span class="built_in">std</span>::bind(&amp;SudokuServer::onMessage, <span class="keyword">this</span>, _1, _2, _3));</span><br><span class="line">        server_.setThreadNum(numThreads);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LOG_INFO &lt;&lt; <span class="string">"starting "</span> &lt;&lt; numThreads_ &lt;&lt; <span class="string">" threads."</span>;</span><br><span class="line">        server_.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn, Buffer *buf, Timestamp)</span> </span>&#123;</span><br><span class="line">        LOG_DEBUG &lt;&lt; conn-&gt;name();</span><br><span class="line">        <span class="keyword">size_t</span> len = buf-&gt;readableBytes();</span><br><span class="line">        <span class="keyword">while</span> (len &gt;= kCells + <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *crlf = buf-&gt;findCRLF();</span><br><span class="line">            <span class="keyword">if</span> (crlf) &#123;</span><br><span class="line">                <span class="function"><span class="built_in">string</span> <span class="title">request</span><span class="params">(buf-&gt;peek(), crlf)</span></span>;</span><br><span class="line">                buf-&gt;retrieveUntil(crlf + <span class="number">2</span>);</span><br><span class="line">                len = buf-&gt;readableBytes();</span><br><span class="line">                <span class="keyword">if</span> (!processRequest(conn, request)) &#123;</span><br><span class="line">                    conn-&gt;send(<span class="string">"Bad Request!\r\n"</span>);</span><br><span class="line">                    conn-&gt;shutdown();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; <span class="number">100</span>) &#123;</span><br><span class="line">                conn-&gt;send(<span class="string">"Id too long!\r\n"</span>);</span><br><span class="line">                conn-&gt;shutdown();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">processRequest</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn, <span class="keyword">const</span> <span class="built_in">string</span> &amp;request)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> id;</span><br><span class="line">        <span class="built_in">string</span> puzzle;</span><br><span class="line">        <span class="keyword">bool</span> goodRequest = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span>::const_iterator colon = find(request.begin(), request.end(), <span class="string">':'</span>);</span><br><span class="line">        <span class="keyword">if</span> (colon != request.end()) &#123;</span><br><span class="line">            id.assign(request.begin(), colon);</span><br><span class="line">            puzzle.assign(colon + <span class="number">1</span>, request.end());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            puzzle = request;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (puzzle.size() == implicit_cast&lt;<span class="keyword">size_t</span>&gt;(kCells)) &#123;</span><br><span class="line">            LOG_DEBUG &lt;&lt; conn-&gt;name();</span><br><span class="line">            <span class="built_in">string</span> result = solveSudoku(puzzle);</span><br><span class="line">            <span class="keyword">if</span> (id.empty()) &#123;</span><br><span class="line">                conn-&gt;send(result + <span class="string">"\r\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                conn-&gt;send(id + <span class="string">":"</span> + result + <span class="string">"\r\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            goodRequest = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> goodRequest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TcpServer server_;</span><br><span class="line">    <span class="keyword">int</span> numThreads_;</span><br><span class="line">    Timestamp startTime_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文链接 &lt;a href=&quot;https://blog.csdn.net/solstice/article/details/6548228&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/s
      
    
    </summary>
    
    
      <category term="开源组件" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/"/>
    
      <category term="muduo" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/"/>
    
    
      <category term="Cpp" scheme="http://yoursite.com/tags/Cpp/"/>
    
      <category term="Net" scheme="http://yoursite.com/tags/Net/"/>
    
  </entry>
  
  <entry>
    <title>muduo 网络编程示例之二： Boost.Asio 的聊天服务器</title>
    <link href="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B%E4%B9%8B%E4%BA%8C%EF%BC%9ABoost.Asio%E7%9A%84%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B%E4%B9%8B%E4%BA%8C%EF%BC%9ABoost.Asio%E7%9A%84%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2020-03-09T03:00:45.855Z</published>
    <updated>2020-03-09T03:01:30.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接 <a href="https://blog.csdn.net/Solstice/article/details/6172391" target="_blank" rel="noopener">https://blog.csdn.net/Solstice/article/details/6172391</a></p></blockquote><p>本文将介绍一个与 Boost.Asio 的示例代码中的聊天服务器功能类似的网络服务程序，包括客户端与服务端的 muduo 实现。这个例子的<strong>主要目的是介绍如何处理分包</strong>，并初步涉及 Muduo 的<strong>多线程功能</strong>。Muduo 的下载地址： <a href="http://muduo.googlecode.com/files/muduo-0.1.7-alpha.tar.gz" target="_blank" rel="noopener">http://muduo.googlecode.com/files/muduo-0.1.7-alpha.tar.gz</a> ，SHA1 873567e43b3c2cae592101ea809b30ba730f2ee6，本文的完整代码可在线阅读<br><a href="http://code.google.com/p/muduo/source/browse/trunk/examples/asio/chat/" target="_blank" rel="noopener">http://code.google.com/p/muduo/source/browse/trunk/examples/asio/chat/</a> 。</p><ul><li><a href="#%e4%b8%80tcp-%e5%88%86%e5%8c%85">一、TCP 分包</a></li><li><a href="#%e4%ba%8c%e8%81%8a%e5%a4%a9%e6%9c%8d%e5%8a%a1">二、聊天服务</a></li><li><a href="#%e4%b8%89%e6%b6%88%e6%81%af%e6%a0%bc%e5%bc%8f">三、消息格式</a></li><li><a href="#%e5%9b%9b%e6%89%93%e5%8c%85%e7%9a%84%e4%bb%a3%e7%a0%81">四、打包的代码</a></li><li><a href="#%e4%ba%94%e5%88%86%e5%8c%85%e7%9a%84%e4%bb%a3%e7%a0%81">五、分包的代码</a></li><li><a href="#%e5%85%ad%e7%bc%96%e8%a7%a3%e7%a0%81%e5%99%a8-lengthheadercodec">六、编解码器 LengthHeaderCodec</a></li><li><a href="#%e4%b8%83%e6%9c%8d%e5%8a%a1%e7%ab%af%e7%9a%84%e5%ae%9e%e7%8e%b0">七、服务端的实现</a></li><li><a href="#%e5%85%ab%e5%ae%a2%e6%88%b7%e7%ab%af%e7%9a%84%e5%ae%9e%e7%8e%b0">八、客户端的实现</a></li><li><a href="#%e4%b9%9d%e7%ae%80%e5%8d%95%e6%b5%8b%e8%af%95">九、简单测试</a></li></ul><h2 id="一、TCP-分包"><a href="#一、TCP-分包" class="headerlink" title="一、TCP 分包"></a>一、TCP 分包</h2><p>前面一篇《五个简单 TCP 协议》中处理的协议没有涉及分包，在 TCP 这种字节流协议上做<strong>应用层分包</strong>是网络编程的基本需求。<strong>分包</strong>指的是在发送一个消息(message)或一帧(frame)数据时，通过一定的处理，让接收方能从字节流中识别并截取（还原）出一个个消息。“粘包问题”是个伪问题。</p><p><strong>对于短连接的 TCP 服务，分包不是一个问题</strong>，只要发送方主动关闭连接，就表示一条消息发送完毕，<strong>接收方 read() 返回 0，从而知道消息的结尾</strong>。例如前一篇文章里的 daytime 和 time 协议。</p><p><strong>注：一方主动关闭 TCP 连接时，另一方 read() 返回 0 ，则代表对方已经关闭连接。</strong></p><p>对于长连接的 TCP 服务，分包有四种方法：</p><ul><li><strong>消息长度固定</strong>，比如 muduo 的 roundtrip 示例就采用了固定的 16 字节消息；</li><li><strong>使用特殊的字符或字符串作为消息的边界</strong>，例如 HTTP 协议的 headers 以 “/r/n” 为字段的分隔符；</li><li><strong>在每条消息的头部加一个长度字段</strong>，这恐怕是<strong>最常见的做法</strong>，本文的聊天协议也采用这一办法；</li><li>利用消息本身的格式来分包，例如 XML 格式的消息中 <code>...</code> 的配对，或者 JSON 格式中的 <code>{ ... }</code> 的配对。解析这种消息格式通常会用到状态机。</li></ul><p>在后文的代码讲解中还会仔细讨论用长度字段分包的常见陷阱。</p><h2 id="二、聊天服务"><a href="#二、聊天服务" class="headerlink" title="二、聊天服务"></a>二、聊天服务</h2><p>本文实现的聊天服务非常简单，由服务端程序和客户端程序组成，<strong>协议如下</strong>：</p><ul><li>服务端程序中某个端口侦听 (listen) 新的连接；</li><li>客户端向服务端发起连接；</li><li>连接建立之后，客户端随时准备接收服务端的消息并在屏幕上显示出来；</li><li>客户端接受键盘输入，以回车为界，把消息发送给服务端；</li><li>服务端接收到消息之后，依次发送给每个连接到它的客户端；原来发送消息的客户端进程也会收到这条消息；</li><li>一个服务端进程可以同时服务多个客户端进程，当有消息到达服务端后，每个客户端进程都会收到同一条消息，服务端广播发送消息的顺序是任意的，不一定哪个客户端会先收到这条消息。</li><li>（可选）如果消息 A 先于消息 B 到达服务端，那么每个客户端都会先收到 A 再收到 B。</li></ul><p>这实际上是一个简单的基于 TCP 的应用层广播协议，<strong>由服务端负责把消息发送给每个连接到它的客户端</strong>。参与“聊天”的既可以是人，也可以是程序。在以后的文章中，我将介绍一个稍微复杂的一点的例子 hub，它有“聊天室”的功能，客户端可以注册特定的 topic(s)，并往某个 topic 发送消息，这样代码更有意思。</p><h2 id="三、消息格式"><a href="#三、消息格式" class="headerlink" title="三、消息格式"></a>三、消息格式</h2><p>本聊天服务的消息格式非常简单，“消息”本身是一个字符串，<strong>每条消息的有一个 4 字节的头部，以网络序存放字符串的长度</strong>。消息之间没有间隙，字符串也不一定以 ‘/0’ 结尾。比方说有两条消息 “hello” 和 “chenshuo”，那么打包后的字节流是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00, 0x00, 0x00, 0x05, &#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, 0x00, 0x00, 0x00, 0x08, &#39;c&#39;, &#39;h&#39;, &#39;e&#39;, &#39;n&#39;, &#39;s&#39;, &#39;h&#39;, &#39;u&#39;, &#39;o&#39;</span><br></pre></td></tr></table></figure><p>共 21 字节。</p><h2 id="四、打包的代码"><a href="#四、打包的代码" class="headerlink" title="四、打包的代码"></a>四、打包的代码</h2><p>这段代码把 const string&amp; message 打包为 muduo::net::Buffer，并通过 conn 发送。</p><p><code>muduo/examples/asio/chat/codec.h</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(muduo::net::TcpConnection* conn, <span class="keyword">const</span> <span class="built_in">string</span>&amp; message)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    muduo::net::Buffer buf;</span><br><span class="line">    buf.append(message.data(), message.size());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> len = muduo::net::sockets::hostToNetwork32(<span class="keyword">static_cast</span>(message.size()));</span><br><span class="line">    buf.prepend(&amp;len, <span class="keyword">sizeof</span> len);</span><br><span class="line"></span><br><span class="line">    conn-&gt;send(&amp;buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>muduo::Buffer 有一个很好的功能，它在头部预留了 8 个字节的空间，这样第 6 行的 prepend() 操作就不需要移动已有的数据，效率较高。</p><h2 id="五、分包的代码"><a href="#五、分包的代码" class="headerlink" title="五、分包的代码"></a>五、分包的代码</h2><p>解析数据往往比生成数据复杂，分包打包也不例外。</p><p><code>muduo/examples/asio/chat/codec.h</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr&amp; conn, muduo::net::Buffer* buf, muduo::Timestamp receiveTime)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (buf-&gt;readableBytes() &gt;= kHeaderLen) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">void</span>* data = buf-&gt;peek();</span><br><span class="line">        <span class="keyword">int32_t</span> tmp = *<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">int32_t</span>*&gt;(data);</span><br><span class="line">        <span class="keyword">int32_t</span> len = muduo::net::sockets::networkToHost32(tmp);</span><br><span class="line">        <span class="keyword">if</span> (len &gt; <span class="number">65536</span> || len &lt; <span class="number">0</span>) &#123; </span><br><span class="line">            LOG_ERROR &lt;&lt; <span class="string">"Invalid length "</span> &lt;&lt; len;</span><br><span class="line">            conn-&gt;shutdown();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (buf-&gt;readableBytes() &gt;= len + kHeaderLen) &#123;</span><br><span class="line">            buf-&gt;retrieve(kHeaderLen);</span><br><span class="line">            <span class="function">muduo::<span class="built_in">string</span> <span class="title">message</span><span class="params">(buf-&gt;peek(), len)</span></span>;</span><br><span class="line">            buf-&gt;retrieve(len);</span><br><span class="line">            messageCallback_(conn, message, receiveTime);  <span class="comment">// 收到完整的消息，通知用户</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码第 7 行用了 while 循环来反复读取数据，直到 Buffer 中的数据不够一条完整的消息。请读者思考，如果换成 if (buf-&gt;readableBytes() &gt;= kHeaderLen) 会有什么后果。</p><p>以前面提到的两条消息的字节流为例：</p><p>0x00, 0x00, 0x00, 0x05, ‘h’, ‘e’, ‘l’, ‘l’, ‘o’, 0x00, 0x00, 0x00, 0x08, ‘c’, ‘h’, ‘e’, ‘n’, ‘s’, ‘h’, ‘u’, ‘o’</p><p>假设数据最终都全部到达，onMessage() 至少要能正确处理以下各种数据到达的次序，每种情况下 messageCallback_ 都应该被调用两次：</p><ol><li>每次收到一个字节的数据，onMessage() 被调用 21 次；</li><li>数据分两次到达，第一次收到 2 个字节，不足消息的长度字段；</li><li>数据分两次到达，第一次收到 4 个字节，刚好够长度字段，但是没有 body；</li><li>数据分两次到达，第一次收到 8 个字节，长度完整，但 body 不完整；</li><li>数据分两次到达，第一次收到 9 个字节，长度完整，body 也完整；</li><li>数据分两次到达，第一次收到 10 个字节，第一条消息的长度完整、body 也完整，第二条消息长度不完整；</li><li>请自行移动分割点，验证各种情况；</li><li>数据一次就全部到达，这时必须用 while 循环来读出两条消息，否则消息会堆积。</li></ol><p>请读者验证 onMessage() 是否做到了以上几点。这个例子充分说明了 non-blocking read 必须和 input buffer 一起使用。这也解释了为什么该用 while 而不是 if 。</p><h2 id="六、编解码器-LengthHeaderCodec"><a href="#六、编解码器-LengthHeaderCodec" class="headerlink" title="六、编解码器 LengthHeaderCodec"></a>六、编解码器 LengthHeaderCodec</h2><p>有人评论 Muduo 的接收缓冲区不能设置回调函数的触发条件，确实如此。每当 socket 可读，Muduo 的 TcpConnection 会读取数据并存入 Input Buffer，然后回调用户的函数。不过，<strong>一个简单的间接层就能解决问题</strong>，让用户代码只关心“消息到达”而不是“数据到达”，如本例中的 LengthHeaderCodec 所展示的那一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MUDUO_EXAMPLES_ASIO_CHAT_CODEC_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MUDUO_EXAMPLES_ASIO_CHAT_CODEC_H</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">using</span> muduo::Logger;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LengthHeaderCodec</span> :</span> boost::noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> boost::function&lt;<span class="keyword">void</span> (<span class="keyword">const</span> muduo::net::TcpConnectionPtr&amp;, <span class="keyword">const</span> muduo::<span class="built_in">string</span>&amp; message, muduo::Timestamp)&gt; StringMessageCallback;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">LengthHeaderCodec</span><span class="params">(<span class="keyword">const</span> StringMessageCallback&amp; cb)</span> : <span class="title">messageCallback_</span><span class="params">(cb)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr&amp; conn, muduo::net::Buffer* buf, muduo::Timestamp receiveTime)</span> </span>&#123; 同上 &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(muduo::net::TcpConnection* conn, <span class="keyword">const</span> muduo::<span class="built_in">string</span>&amp; message)</span> </span>&#123; 同上 &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    StringMessageCallback messageCallback_;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">size_t</span> kHeaderLen = <span class="keyword">sizeof</span>(<span class="keyword">int32_t</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// MUDUO_EXAMPLES_ASIO_CHAT_CODEC_H</span></span></span><br></pre></td></tr></table></figure><p>这段代码把以 Buffer* 为参数的 MessageCallback 转换成了以 const string&amp; 为参数的 StringMessageCallback，<strong>让用户代码不必关心分包操作。客户端和服务端都能从中受益</strong>。</p><h2 id="七、服务端的实现"><a href="#七、服务端的实现" class="headerlink" title="七、服务端的实现"></a>七、服务端的实现</h2><p>聊天服务器的服务端代码小于 100 行，不到 asio 的一半。</p><p>请先阅读第 68 行起的数据成员的定义。除了经常见到的 EventLoop 和 TcpServer，ChatServer 还定义了 codec_ 和 std::set connections_ 作为成员，connections_ 是目前已建立的客户连接，<strong>在收到消息之后，服务器会遍历整个容器，把消息广播给其中每一个 TCP 连接</strong>。</p><p>首先，在构造函数里注册回调：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"codec.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo::net;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChatServer</span> :</span> boost::noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ChatServer(EventLoop* loop, <span class="keyword">const</span> InetAddress&amp; listenAddr): </span><br><span class="line">            loop_(loop),</span><br><span class="line">            server_(loop, listenAddr, <span class="string">"ChatServer"</span>),</span><br><span class="line">            codec_(boost::bind(&amp;ChatServer::onStringMessage, <span class="keyword">this</span>, _1, _2, _3)) &#123;</span><br><span class="line">  </span><br><span class="line">        server_.setConnectionCallback(boost::bind(&amp;ChatServer::onConnection, <span class="keyword">this</span>, _1));</span><br><span class="line">        server_.setMessageCallback(boost::bind(&amp;LengthHeaderCodec::onMessage, &amp;codec_, _1, _2, _3));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        server_.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里有几点值得注意，<strong>在以往的代码里是直接把本 class 的 onMessage() 注册给 server_；这里我们把 LengthHeaderCodec::onMessage() 注册给 server_，然后向 codec_ 注册了 ChatServer::onStringMessage()，等于说让 codec_ 负责解析消息，然后把完整的消息回调给 ChatServer</strong>。这正是我前面提到的“一个简单的间接层”，在不增加 Muduo 库的复杂度的前提下，提供了足够的灵活性让我们在用户代码里完成需要的工作。</p><p>另外，<strong>server_.start() 绝对不能在构造函数里调用，这么做将来会有线程安全的问题</strong>，见我在《当析构函数遇到多线程 ── C++ 中线程安全的对象回调》一文中的论述。</p><p>以下是处理连接的建立和断开的代码，注意它把新建的连接加入到 connections_ 容器中，把已断开的连接从容器中删除。这么做是为了避免内存和资源泄漏，<strong>TcpConnectionPtr 是 boost::shared_ptr，是 muduo 里唯一一个默认采用 shared_ptr 来管理生命期的对象</strong>。以后我们会谈到这么做的原因。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn)</span> </span>&#123;</span><br><span class="line">        LOG_INFO &lt;&lt; conn-&gt;localAddress().toHostPort() &lt;&lt; <span class="string">" -&gt; "</span> &lt;&lt; conn-&gt;peerAddress().toHostPort() &lt;&lt; <span class="string">" is "</span> &lt;&lt; (conn-&gt;connected() ? <span class="string">"UP"</span> : <span class="string">"DOWN"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (conn-&gt;connected()) &#123;</span><br><span class="line">            connections_.insert(conn);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            connections_.erase(conn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以下是服务端处理消息的代码，它遍历整个 connections_ 容器，把消息打包发送给各个客户连接。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onStringMessage</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp; message, Timestamp)</span> </span>&#123;</span><br><span class="line">    <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (ConnectionList::iterator it = connections_.begin(); it != connections_.end(); ++it) &#123; </span><br><span class="line">        codec_.send(get_pointer(*it), message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据成员：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">set</span> ConnectionList;</span><br><span class="line">EventLoop* loop_;</span><br><span class="line">TcpServer server_;</span><br><span class="line">LengthHeaderCodec codec_;</span><br><span class="line">MutexLock mutex_;</span><br><span class="line">ConnectionList connections_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>main() 函数里边是例行公事的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">"pid = "</span> &lt;&lt; getpid();</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        EventLoop loop;</span><br><span class="line">        <span class="keyword">uint16_t</span> port = <span class="keyword">static_cast</span>(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">        <span class="function">InetAddress <span class="title">serverAddr</span><span class="params">(port)</span></span>;</span><br><span class="line">        <span class="function">ChatServer <span class="title">server</span><span class="params">(&amp;loop, serverAddr)</span></span>;</span><br><span class="line">        server.start();</span><br><span class="line">        loop.loop();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage: %s port/n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你读过 asio 的对应代码，会不会觉得 Reactor 往往比 Proactor 容易使用？</p><h2 id="八、客户端的实现"><a href="#八、客户端的实现" class="headerlink" title="八、客户端的实现"></a>八、客户端的实现</h2><p>我有时觉得服务端的程序常常比客户端的更容易写，聊天服务器再次验证了我的看法。客户端的复杂性来自于它要读取键盘输入，而 EventLoop 是独占线程的，<strong>所以我用了两个线程，main() 函数所在的线程负责读键盘，另外用一个 EventLoopThread 来处理网络 IO</strong>。我暂时没有把标准输入输出融入 Reactor 的想法，因为服务器程序的 stdin 和 stdout 往往是重定向了的。</p><p>来看代码，首先，在构造函数里注册回调，并使用了跟前面一样的 LengthHeaderCodec <strong>作为中间层</strong>，负责打包分包。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"codec.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo::net;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChatClient</span> :</span> boost::noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ChatClient(EventLoop* loop, <span class="keyword">const</span> InetAddress&amp; listenAddr)</span><br><span class="line">            : loop_(loop),</span><br><span class="line">              client_(loop, listenAddr, <span class="string">"ChatClient"</span>),</span><br><span class="line">              codec_(boost::bind(&amp;ChatClient::onStringMessage, <span class="keyword">this</span>, _1, _2, _3)) &#123;</span><br><span class="line">        client_.setConnectionCallback(boost::bind(&amp;ChatClient::onConnection, <span class="keyword">this</span>, _1));</span><br><span class="line">        client_.setMessageCallback(boost::bind(&amp;LengthHeaderCodec::onMessage, &amp;codec_, _1, _2, _3));</span><br><span class="line">        client_.enableRetry();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        client_.connect();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>disconnect() 目前为空，客户端的连接由操作系统在进程终止时关闭。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disconnect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// client_.disconnect();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>write() 会由 main 线程调用，所以要加锁，这个锁不是为了保护 TcpConnection，而是保护 shared_ptr。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; message)</span> </span>&#123;</span><br><span class="line">    <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (connection_) &#123;</span><br><span class="line">        codec_.send(get_pointer(connection_), message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>onConnection() 会由 EventLoop 线程调用，所以要加锁以保护 shared_ptr。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn)</span> </span>&#123;</span><br><span class="line">        LOG_INFO &lt;&lt; conn-&gt;localAddress().toHostPort() &lt;&lt; <span class="string">" -&gt; "</span> &lt;&lt; conn-&gt;peerAddress().toHostPort() &lt;&lt; <span class="string">" is "</span> &lt;&lt; (conn-&gt;connected() ? <span class="string">"UP"</span> : <span class="string">"DOWN"</span>);</span><br><span class="line">  </span><br><span class="line">        <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (conn-&gt;connected()) &#123;</span><br><span class="line">            connection_ = conn;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            connection_.reset();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>把收到的消息打印到屏幕，这个函数由 EventLoop 线程调用，但是不用加锁，因为 printf() 是线程安全的。<br><strong>注意这里不能用 cout，它不是线程安全的</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onStringMessage</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp; message, Timestamp)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&lt;&lt;&lt; %s/n"</span>, message.c_str());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据成员：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EventLoop* loop_;</span><br><span class="line">TcpClient client_;</span><br><span class="line">LengthHeaderCodec codec_;</span><br><span class="line">MutexLock mutex_;</span><br><span class="line">TcpConnectionPtr connection_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>main() 函数里除了例行公事，还要启动 EventLoop 线程和读取键盘输入。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">"pid = "</span> &lt;&lt; getpid();</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        EventLoopThread loopThread;</span><br><span class="line">        <span class="keyword">uint16_t</span> port = <span class="keyword">static_cast</span>(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">        <span class="function">InetAddress <span class="title">serverAddr</span><span class="params">(argv[<span class="number">1</span>], port)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function">ChatClient <span class="title">client</span><span class="params">(loopThread.startLoop(), serverAddr)</span></span>; <span class="comment">// 注册到 EventLoopThread 的 EventLoop 上。</span></span><br><span class="line">        client.connect();</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> line;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">std</span>::getline(<span class="built_in">std</span>::<span class="built_in">cin</span>, line)) &#123;</span><br><span class="line">            <span class="function"><span class="built_in">string</span> <span class="title">message</span><span class="params">(line.c_str())</span></span>; <span class="comment">// 这里似乎多此一举，可直接发送 line。这里是</span></span><br><span class="line">            client.write(message);</span><br><span class="line">        &#125;</span><br><span class="line">        client.disconnect();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage: %s host_ip port/n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="九、简单测试"><a href="#九、简单测试" class="headerlink" title="九、简单测试"></a>九、简单测试</h2><p>开三个命令行窗口，在第一个运行</p><p><code>$ ./asio_chat_server 3000</code></p><p>第二个运行</p><p><code>$ ./asio_chat_client 127.0.0.1 3000</code></p><p>第三个运行同样的命令</p><p><code>$ ./asio_chat_client 127.0.0.1 3000</code></p><p>这样就有两个客户端进程参与聊天。在第二个窗口里输入一些字符并回车，字符会出现在本窗口和第三个窗口中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文链接 &lt;a href=&quot;https://blog.csdn.net/Solstice/article/details/6172391&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/S
      
    
    </summary>
    
    
      <category term="开源组件" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/"/>
    
      <category term="muduo" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/"/>
    
    
      <category term="Cpp" scheme="http://yoursite.com/tags/Cpp/"/>
    
      <category term="Net" scheme="http://yoursite.com/tags/Net/"/>
    
      <category term="Boost" scheme="http://yoursite.com/tags/Boost/"/>
    
  </entry>
  
  <entry>
    <title>为什么 muduo 的 shutdown() 没有直接关闭 TCP 连接？</title>
    <link href="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/%E4%B8%BA%E4%BB%80%E4%B9%88muduo%E7%9A%84shutdown()%E6%B2%A1%E6%9C%89%E7%9B%B4%E6%8E%A5%E5%85%B3%E9%97%ADTCP%E8%BF%9E%E6%8E%A5%EF%BC%9F/"/>
    <id>http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/%E4%B8%BA%E4%BB%80%E4%B9%88muduo%E7%9A%84shutdown()%E6%B2%A1%E6%9C%89%E7%9B%B4%E6%8E%A5%E5%85%B3%E9%97%ADTCP%E8%BF%9E%E6%8E%A5%EF%BC%9F/</id>
    <published>2020-03-09T02:59:18.134Z</published>
    <updated>2020-03-09T03:00:08.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接 <a href="https://blog.csdn.net/Solstice/article/details/6208634" target="_blank" rel="noopener">https://blog.csdn.net/Solstice/article/details/6208634</a></p></blockquote><ul><li><a href="#%e9%97%ae%e9%a2%98">问题：</a></li><li><a href="#%e7%9b%b8%e5%85%b3%e4%bb%a3%e7%a0%81">相关代码</a></li><li><a href="#%e5%9b%9e%e7%ad%94">回答</a></li></ul><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在 simple 中的 daytime 示例中，服务端主动关闭时调用的是如下函数序列，这不是只是关闭了连接上的写操作吗，怎么是关闭了整个连接？</span><br></pre></td></tr></table></figure><h3 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h3><p><code>daytime.cc</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DaytimeServer::onConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn)</span> </span>&#123;</span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">"DaytimeServer - "</span> &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; <span class="string">" -&gt; "</span></span><br><span class="line">             &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; <span class="string">" is "</span></span><br><span class="line">             &lt;&lt; (conn-&gt;connected() ? <span class="string">"UP"</span> : <span class="string">"DOWN"</span>);</span><br><span class="line">    <span class="keyword">if</span> (conn-&gt;connected()) &#123;</span><br><span class="line">        conn-&gt;send(Timestamp::now().toFormattedString() + <span class="string">"\n"</span>);</span><br><span class="line">        conn-&gt;shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TcpConnection.cc</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> use compare and swap</span></span><br><span class="line">    <span class="keyword">if</span> (state_ == kConnected) &#123;</span><br><span class="line">        setState(kDisconnecting);</span><br><span class="line">        <span class="comment">// <span class="doctag">FIXME:</span> shared_from_this()?</span></span><br><span class="line">        loop_-&gt;runInLoop(<span class="built_in">std</span>::bind(&amp;TcpConnection::shutdownInLoop, <span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::shutdownInLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    <span class="keyword">if</span> (!channel_-&gt;isWriting()) &#123;</span><br><span class="line">        <span class="comment">// we are not writing</span></span><br><span class="line">        socket_-&gt;shutdownWrite();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Socket.cc</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Socket::shutdownWrite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sockets::shutdownWrite(sockfd_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sockets::shutdownWrite</span><span class="params">(<span class="keyword">int</span> sockfd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (::shutdown(sockfd, SHUT_WR) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOG_SYSERR &lt;&lt; <span class="string">"sockets::shutdownWrite"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="回答"><a href="#回答" class="headerlink" title="回答"></a>回答</h3><p>Muduo TcpConnection <strong>没有提供 close，而只提供 shutdown</strong> ，这么做是为了<strong>收发数据的完整性</strong>。</p><p><strong>TCP 是一个全双工协议，同一个文件描述符既可读又可写，</strong> shutdownWrite() 关闭了“写”方向的连接，保留了“读”方向，这称为 TCP half-close。如果直接 close(socket_fd)，那么 socket_fd 就不能读或写了。</p><p>用 shutdown 而不用 close 的效果是，如果对方已经发送了数据，这些数据还“在路上”，那么 muduo 不会漏收这些数据。换句话说，muduo 在 TCP 这一层面解决了“当你打算关闭网络连接的时候，如何得知对方有没有发了一些数据而你还没有收到？”这一问题。当然，这个问题也可以在上面的协议层解决，双方商量好不再互发数据，就可以直接断开连接。</p><p><strong>等于说 muduo 把“主动关闭连接”这件事情分成两步来做</strong>，如果要主动关闭连接，它<strong>会先关本地“写”端</strong>，等对方关闭之后，<strong>再关本地“读”端</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">练习：阅读代码，回答“如果被动关闭连接，muduo 的行为如何？</span><br></pre></td></tr></table></figure><p>提示：<strong>muduo 在 read() 返回 0 的时候会回调 connection callback</strong>，这样客户代码就知道对方断开连接了。</p><p><strong>Muduo 这种关闭连接的方式对对方也有要求，那就是对方 read() 到 0 字节之后会主动关闭连接</strong>（无论 shutdownWrite() 还是 close()），一般的网络程序都会这样，不是什么问题。当然，这么做有一个潜在的安全漏洞，万一对方故意不不关，那么 muduo 的连接就一直半开着，消耗系统资源。</p><p><strong>完整的流程</strong>是：我们发完了数据，于是 shutdownWrite，发送 TCP FIN 分节，<strong>对方会读到 0 字节</strong>，然后对方通常会关闭连接，这样 muduo 会读到 0 字节，然后 muduo 关闭连接。（思考题，在 shutdown() 之后，muduo 回调 connection callback 的时间间隔大约是一个 round-trip time，为什么？）</p><p>另外，如果有必要，对方可以在 read() 返回 0 之后继续发送数据，这是直接利用了 half-close TCP 连接。muduo 会收到这些数据，通过 message callback 通知客户代码。</p><p><strong>那么 muduo 什么时候真正 close socket 呢？在 TcpConnection 对象析构的时候</strong>。TcpConnection 持有一个 Socket 对象，<strong>Socket 是一个 RAII handler，它的析构函数会 close(sockfd_)</strong>。这样，如果发生 TcpConnection 对象泄漏，那么我们从 /proc/pid/fd/ 就能找到没有关闭的文件描述符，便于查错。</p><p><strong>muduo 在 read() 返回 0 的时候会回调 connection callback，然后把 TcpConnection 的引用计数减一，如果 TcpConnection 的引用计数降到零，它就会析构了。</strong></p><p>参考：</p><p>《TCP/IP 详解》第一卷第 18.5 节，TCP Half-Close。</p><p>《UNIX 网络编程》第一卷第三版第 6.6 节， shutdown() 函数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文链接 &lt;a href=&quot;https://blog.csdn.net/Solstice/article/details/6208634&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/S
      
    
    </summary>
    
    
      <category term="开源组件" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/"/>
    
      <category term="muduo" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/"/>
    
    
      <category term="Cpp" scheme="http://yoursite.com/tags/Cpp/"/>
    
      <category term="TCP" scheme="http://yoursite.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>muduo 网络编程示例之一：五个简单 TCP 协议</title>
    <link href="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B%E4%B9%8B%E4%B8%80%EF%BC%9A%E4%BA%94%E4%B8%AA%E7%AE%80%E5%8D%95TCP%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B%E4%B9%8B%E4%B8%80%EF%BC%9A%E4%BA%94%E4%B8%AA%E7%AE%80%E5%8D%95TCP%E5%8D%8F%E8%AE%AE/</id>
    <published>2020-03-09T02:58:09.704Z</published>
    <updated>2020-03-09T02:58:54.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接 <a href="https://blog.csdn.net/Solstice/article/details/6171905" target="_blank" rel="noopener">https://blog.csdn.net/Solstice/article/details/6171905</a></p></blockquote><p>本文将介绍第一个示例：五个简单 TCP 网络服务协议，包括 echo (RFC 862)、discard (RFC 863)、chargen (RFC 864)、daytime (RFC 867)、time (RFC 868)，以及 time 协议的客户端。各协议的功能简介如下：</p><ul><li>discard - 丢弃所有收到的数据；</li><li>daytime - 服务端 accept 连接之后，以字符串形式发送当前时间，然后主动断开连接；</li><li>time - 服务端 accept 连接之后，以二进制形式发送当前时间（从 Epoch 到现在的秒数），然后主动断开连接；我们需要一个客户程序来把收到的时间转换为字符串。</li><li>echo - 回显服务，把收到的数据发回客户端；</li><li>chargen - 服务端 accept 连接之后，不停地发送测试数据。</li></ul><p><strong>以上五个协议使用不同的端口，可以放到同一个进程中实现，且不必使用多线程</strong>。完整的代码见 muduo/examples/simple，下载地址 <a href="http://muduo.googlecode.com/files/muduo-0.1.6-alpha.tar.gz" target="_blank" rel="noopener">http://muduo.googlecode.com/files/muduo-0.1.6-alpha.tar.gz</a> 。</p><ul><li><a href="#%e4%b8%80discard">一、discard</a></li><li><a href="#%e4%ba%8cdaytime">二、daytime</a></li><li><a href="#%e4%b8%89time">三、time</a><ul><li><a href="#server">server</a></li><li><a href="#client">client</a></li></ul></li><li><a href="#%e5%9b%9becho">四、echo</a></li><li><a href="#%e4%ba%94chargen">五、chargen</a><ul><li><a href="#server-1">server</a></li><li><a href="#client-1">client</a></li></ul></li><li><a href="#%e5%85%adfive-in-one">六、Five in one</a></li></ul><h2 id="一、discard"><a href="#一、discard" class="headerlink" title="一、discard"></a>一、discard</h2><p>Discard 恐怕算是最简单的长连接 TCP 应用层协议，它只需要关注“三个半事件”中的“消息/数据到达”事件</p><p><code>main.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">"pid = "</span> &lt;&lt; getpid();</span><br><span class="line">    EventLoop loop;</span><br><span class="line">    <span class="function">InetAddress <span class="title">listenAddr</span><span class="params">(<span class="number">2009</span>)</span></span>;</span><br><span class="line">    <span class="function">DiscardServer <span class="title">server</span><span class="params">(&amp;loop, listenAddr)</span></span>;</span><br><span class="line">    server.start();</span><br><span class="line">    loop.loop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>discard.h</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiscardServer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DiscardServer(muduo::net::EventLoop *loop,</span><br><span class="line">                  <span class="keyword">const</span> muduo::net::InetAddress &amp;listenAddr);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onConnection</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr &amp;conn)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr &amp;conn,</span></span></span><br><span class="line"><span class="function"><span class="params">                   muduo::net::Buffer *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">                   muduo::Timestamp time)</span></span>;</span><br><span class="line"></span><br><span class="line">    muduo::net::TcpServer server_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>discard.cc</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">DiscardServer::DiscardServer(EventLoop *loop,</span><br><span class="line">                             <span class="keyword">const</span> InetAddress &amp;listenAddr)</span><br><span class="line">        : server_(loop, listenAddr, <span class="string">"DiscardServer"</span>) &#123;</span><br><span class="line">    server_.setConnectionCallback(</span><br><span class="line">            <span class="built_in">std</span>::bind(&amp;DiscardServer::onConnection, <span class="keyword">this</span>, _1));</span><br><span class="line">    server_.setMessageCallback(</span><br><span class="line">            <span class="built_in">std</span>::bind(&amp;DiscardServer::onMessage, <span class="keyword">this</span>, _1, _2, _3));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DiscardServer::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    server_.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DiscardServer::onConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn)</span> </span>&#123;</span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">"DiscardServer - "</span> &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; <span class="string">" -&gt; "</span></span><br><span class="line">             &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; <span class="string">" is "</span></span><br><span class="line">             &lt;&lt; (conn-&gt;connected() ? <span class="string">"UP"</span> : <span class="string">"DOWN"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DiscardServer::onMessage</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Buffer *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Timestamp time)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">msg</span><span class="params">(buf-&gt;retrieveAllAsString())</span></span>;</span><br><span class="line">    LOG_INFO &lt;&lt; conn-&gt;name() &lt;&lt; <span class="string">" discards "</span> &lt;&lt; msg.size()</span><br><span class="line">             &lt;&lt; <span class="string">" bytes received at "</span> &lt;&lt; time.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、daytime"><a href="#二、daytime" class="headerlink" title="二、daytime"></a>二、daytime</h2><p>Daytime 是<strong>短连接协议</strong>，<strong>在发送完当前时间后，由服务端主动断开连接</strong>。它只需要关注“三个半事件”中的“连接已建立”事件</p><p>仅关注两个回调函数，其他部分和 discard 大同小异</p><p><code>daytime.cc</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DaytimeServer::onConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn)</span> </span>&#123;</span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">"DaytimeServer - "</span> &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; <span class="string">" -&gt; "</span></span><br><span class="line">             &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; <span class="string">" is "</span></span><br><span class="line">             &lt;&lt; (conn-&gt;connected() ? <span class="string">"UP"</span> : <span class="string">"DOWN"</span>);</span><br><span class="line">    <span class="keyword">if</span> (conn-&gt;connected()) &#123;</span><br><span class="line">        conn-&gt;send(Timestamp::now().toFormattedString() + <span class="string">"\n"</span>);</span><br><span class="line">        conn-&gt;shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DaytimeServer::onMessage</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Buffer *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Timestamp time)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">msg</span><span class="params">(buf-&gt;retrieveAllAsString())</span></span>;</span><br><span class="line">    LOG_INFO &lt;&lt; conn-&gt;name() &lt;&lt; <span class="string">" discards "</span> &lt;&lt; msg.size()</span><br><span class="line">             &lt;&lt; <span class="string">" bytes received at "</span> &lt;&lt; time.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较值得注意的是 onConnection 方法，发送完数据以后，由 server 端 shutdown 这个 socket</p><h2 id="三、time"><a href="#三、time" class="headerlink" title="三、time"></a>三、time</h2><p>Time 协议与 daytime 极为类似，只不过它返回的不是日期时间字符串，而是一个 32-bit 整数，表示从 1970-01-01 00:00:00Z 到现在的秒数。当然，这个协议有“2038 年问题”。服务端只需要关注“三个半事件”中的“连接已建立”事件。</p><h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><p>server 端和 daytime 差不多，也是 send 以后主动 shutdown</p><p><code>time.cc</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TimeServer::onConnection</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr &amp;conn)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">"TimeServer - "</span> &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; <span class="string">" -&gt; "</span></span><br><span class="line">             &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; <span class="string">" is "</span></span><br><span class="line">             &lt;&lt; (conn-&gt;connected() ? <span class="string">"UP"</span> : <span class="string">"DOWN"</span>);</span><br><span class="line">    <span class="keyword">if</span> (conn-&gt;connected()) &#123;</span><br><span class="line">        <span class="keyword">time_t</span> now = ::time(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">int32_t</span> be32 = sockets::hostToNetwork32(<span class="keyword">static_cast</span>&lt;<span class="keyword">int32_t</span>&gt;(now));</span><br><span class="line">        conn-&gt;send(&amp;be32, <span class="keyword">sizeof</span> be32);</span><br><span class="line">        conn-&gt;shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TimeServer::onMessage</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr &amp;conn,</span></span></span><br><span class="line"><span class="function"><span class="params">                           muduo::net::Buffer *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">                           muduo::Timestamp time)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">msg</span><span class="params">(buf-&gt;retrieveAllAsString())</span></span>;</span><br><span class="line">    LOG_INFO &lt;&lt; conn-&gt;name() &lt;&lt; <span class="string">" discards "</span> &lt;&lt; msg.size()</span><br><span class="line">             &lt;&lt; <span class="string">" bytes received at "</span> &lt;&lt; time.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="client"><a href="#client" class="headerlink" title="client"></a>client</h3><p>因为 time 服务端发送的是二进制数据，不便直接阅读，<strong>我们编写一个客户端来解析并打印收到的 4 个字节数据</strong>。这个程序只需要关注“三个半事件”中的“消息/数据到达”事件。</p><p><code>main.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">"pid = "</span> &lt;&lt; getpid();</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        EventLoop loop;</span><br><span class="line">        <span class="function">InetAddress <span class="title">serverAddr</span><span class="params">(argv[<span class="number">1</span>], <span class="number">2037</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">TimeClient <span class="title">timeClient</span><span class="params">(&amp;loop, serverAddr)</span></span>;</span><br><span class="line">        timeClient.connect();</span><br><span class="line">        loop.loop();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage: %s host_ip\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>timeclient.h</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeClient</span> :</span> noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TimeClient(EventLoop *loop, <span class="keyword">const</span> InetAddress &amp;serverAddr)</span><br><span class="line">            : loop_(loop),</span><br><span class="line">              client_(loop, serverAddr, <span class="string">"TimeClient"</span>) &#123;</span><br><span class="line">        client_.setConnectionCallback(</span><br><span class="line">                <span class="built_in">std</span>::bind(&amp;TimeClient::onConnection, <span class="keyword">this</span>, _1));</span><br><span class="line">        client_.setMessageCallback(</span><br><span class="line">                <span class="built_in">std</span>::bind(&amp;TimeClient::onMessage, <span class="keyword">this</span>, _1, _2, _3));</span><br><span class="line">        <span class="comment">// client_.enableRetry();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        client_.connect();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    EventLoop *loop_;</span><br><span class="line">    TcpClient client_;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn)</span> </span>&#123;</span><br><span class="line">        LOG_INFO &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; <span class="string">" -&gt; "</span></span><br><span class="line">                 &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; <span class="string">" is "</span></span><br><span class="line">                 &lt;&lt; (conn-&gt;connected() ? <span class="string">"UP"</span> : <span class="string">"DOWN"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!conn-&gt;connected()) &#123;</span><br><span class="line">            loop_-&gt;quit();   <span class="comment">// // 如果连接断开，则终止主循环，退出程序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn, Buffer *buf, Timestamp receiveTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (buf-&gt;readableBytes() &gt;= <span class="keyword">sizeof</span>(<span class="keyword">int32_t</span>)) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">void</span> *data = buf-&gt;peek();</span><br><span class="line">            <span class="keyword">int32_t</span> be32 = *<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">int32_t</span> *&gt;(data);</span><br><span class="line">            buf-&gt;retrieve(<span class="keyword">sizeof</span>(<span class="keyword">int32_t</span>));</span><br><span class="line">            <span class="keyword">time_t</span> time = sockets::networkToHost32(be32);</span><br><span class="line">            <span class="function">Timestamp <span class="title">ts</span><span class="params">(implicit_cast&lt;<span class="keyword">uint64_t</span>&gt;(time) * Timestamp::kMicroSecondsPerSecond)</span></span>;</span><br><span class="line">            LOG_INFO &lt;&lt; <span class="string">"Server time = "</span> &lt;&lt; time &lt;&lt; <span class="string">", "</span> &lt;&lt; ts.toFormattedString();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LOG_INFO &lt;&lt; conn-&gt;name() &lt;&lt; <span class="string">" no enough data "</span> &lt;&lt; buf-&gt;readableBytes()</span><br><span class="line">                     &lt;&lt; <span class="string">" at "</span> &lt;&lt; receiveTime.toFormattedString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意其中考虑到了<strong>如果数据没有一次性收全，已经收到的数据会暂存在 Buffer 里，以等待下一次机会，程序也不会阻塞</strong>。这样即便服务器一个字节一个字节地发送数据，代码还是能正常工作，这也是非阻塞网络编程必须在用户态使用接受缓冲的主要原因。</p><h2 id="四、echo"><a href="#四、echo" class="headerlink" title="四、echo"></a>四、echo</h2><p>Echo 是我们遇到的第一个带交互的协议：服务端把客户端发过来的数据原封不动地传回去。它只需要关注“三个半事件”中的“消息/数据到达”事件。</p><p><code>echo.cc</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EchoServer::onConnection</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr &amp;conn)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">"EchoServer - "</span> &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; <span class="string">" -&gt; "</span></span><br><span class="line">             &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; <span class="string">" is "</span></span><br><span class="line">             &lt;&lt; (conn-&gt;connected() ? <span class="string">"UP"</span> : <span class="string">"DOWN"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EchoServer::onMessage</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr &amp;conn,</span></span></span><br><span class="line"><span class="function"><span class="params">                           muduo::net::Buffer *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">                           muduo::Timestamp time)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">muduo::<span class="built_in">string</span> <span class="title">msg</span><span class="params">(buf-&gt;retrieveAllAsString())</span></span>;</span><br><span class="line">    LOG_INFO &lt;&lt; conn-&gt;name() &lt;&lt; <span class="string">" echo "</span> &lt;&lt; msg.size() &lt;&lt; <span class="string">" bytes, "</span></span><br><span class="line">             &lt;&lt; <span class="string">"data received at "</span> &lt;&lt; time.toString();</span><br><span class="line">    conn-&gt;send(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码实现的不是行回显(line echo)服务，而是有一点数据就发送一点数据。这样可以避免客户端恶意地不发送换行字符，而服务端又必须缓存已经收到的数据，导致服务器内存暴涨。<strong>但这个程序还是有一个安全漏洞，即如果客户端故意不断发生数据，但从不接收，那么服务端的发送缓冲区会一直堆积，导致内存暴涨。</strong>解决办法可以参考下面的 chargen 协议。</p><h2 id="五、chargen"><a href="#五、chargen" class="headerlink" title="五、chargen"></a>五、chargen</h2><p>Chargen 协议很特殊，它<strong>只发送数据，不接收数据</strong>。<strong>而且，它发送数据的速度不能快过客户端接收的速度</strong>，因此需要关注“三个半事件”中的半个“消息/数据发送完毕”事件(onWriteComplete)。</p><h3 id="server-1"><a href="#server-1" class="headerlink" title="server"></a>server</h3><p><code>chargen.h</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChargenServer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ChargenServer(muduo::net::EventLoop *loop,</span><br><span class="line">                  <span class="keyword">const</span> muduo::net::InetAddress &amp;listenAddr,</span><br><span class="line">                  <span class="keyword">bool</span> print = <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onConnection</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr &amp;conn)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr &amp;conn,</span></span></span><br><span class="line"><span class="function"><span class="params">                   muduo::net::Buffer *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">                   muduo::Timestamp time)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onWriteComplete</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr &amp;conn)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printThroughput</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    muduo::net::TcpServer server_;</span><br><span class="line"></span><br><span class="line">    muduo::<span class="built_in">string</span> message_;</span><br><span class="line">    <span class="keyword">int64_t</span> transferred_;</span><br><span class="line">    muduo::Timestamp startTime_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>chargen.cc</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">ChargenServer::ChargenServer(EventLoop *loop,</span><br><span class="line">                             <span class="keyword">const</span> InetAddress &amp;listenAddr,</span><br><span class="line">                             <span class="keyword">bool</span> print)</span><br><span class="line">        : server_(loop, listenAddr, <span class="string">"ChargenServer"</span>),</span><br><span class="line">          transferred_(<span class="number">0</span>),</span><br><span class="line">          startTime_(Timestamp::now()) &#123;</span><br><span class="line"></span><br><span class="line">    server_.setConnectionCallback(</span><br><span class="line">            <span class="built_in">std</span>::bind(&amp;ChargenServer::onConnection, <span class="keyword">this</span>, _1));</span><br><span class="line">    server_.setMessageCallback(</span><br><span class="line">            <span class="built_in">std</span>::bind(&amp;ChargenServer::onMessage, <span class="keyword">this</span>, _1, _2, _3));</span><br><span class="line">    server_.setWriteCompleteCallback(</span><br><span class="line">            <span class="built_in">std</span>::bind(&amp;ChargenServer::onWriteComplete, <span class="keyword">this</span>, _1));</span><br><span class="line">    <span class="keyword">if</span> (print) &#123;</span><br><span class="line">        loop-&gt;runEvery(<span class="number">3.0</span>, <span class="built_in">std</span>::bind(&amp;ChargenServer::printThroughput, <span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> line;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">33</span>; i &lt; <span class="number">127</span>; ++i) &#123;</span><br><span class="line">        line.push_back(<span class="keyword">char</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">    line += line;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">127</span> - <span class="number">33</span>; ++i) &#123;</span><br><span class="line">        message_ += line.substr(i, <span class="number">72</span>) + <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChargenServer::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    server_.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChargenServer::onConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn)</span> </span>&#123;</span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">"ChargenServer - "</span> &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; <span class="string">" -&gt; "</span></span><br><span class="line">             &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; <span class="string">" is "</span></span><br><span class="line">             &lt;&lt; (conn-&gt;connected() ? <span class="string">"UP"</span> : <span class="string">"DOWN"</span>);</span><br><span class="line">    <span class="keyword">if</span> (conn-&gt;connected()) &#123;   <span class="comment">// 在连接建立时发生第一次数据</span></span><br><span class="line">        conn-&gt;setTcpNoDelay(<span class="literal">true</span>);</span><br><span class="line">        conn-&gt;send(message_);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChargenServer::onMessage</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Buffer *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Timestamp time)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">msg</span><span class="params">(buf-&gt;retrieveAllAsString())</span></span>;</span><br><span class="line">    LOG_INFO &lt;&lt; conn-&gt;name() &lt;&lt; <span class="string">" discards "</span> &lt;&lt; msg.size()</span><br><span class="line">             &lt;&lt; <span class="string">" bytes received at "</span> &lt;&lt; time.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChargenServer::onWriteComplete</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn)</span> </span>&#123;     <span class="comment">// 继续发送数据</span></span><br><span class="line">    transferred_ += message_.size();</span><br><span class="line">    conn-&gt;send(message_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChargenServer::printThroughput</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Timestamp endTime = Timestamp::now();</span><br><span class="line">    <span class="keyword">double</span> time = timeDifference(endTime, startTime_);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%4.3f MiB/s\n"</span>, <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(transferred_) / time / <span class="number">1024</span> / <span class="number">1024</span>);</span><br><span class="line">    transferred_ = <span class="number">0</span>;</span><br><span class="line">    startTime_ = endTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="client-1"><a href="#client-1" class="headerlink" title="client"></a>client</h3><p><code>chargenclient.cc</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChargenClient</span> :</span> noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ChargenClient(EventLoop *loop, <span class="keyword">const</span> InetAddress &amp;listenAddr)</span><br><span class="line">            : loop_(loop),</span><br><span class="line">              client_(loop, listenAddr, <span class="string">"ChargenClient"</span>) &#123;</span><br><span class="line">        client_.setConnectionCallback(</span><br><span class="line">                <span class="built_in">std</span>::bind(&amp;ChargenClient::onConnection, <span class="keyword">this</span>, _1));</span><br><span class="line">        client_.setMessageCallback(</span><br><span class="line">                <span class="built_in">std</span>::bind(&amp;ChargenClient::onMessage, <span class="keyword">this</span>, _1, _2, _3));</span><br><span class="line">        <span class="comment">// client_.enableRetry();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        client_.connect();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn)</span> </span>&#123;</span><br><span class="line">        LOG_INFO &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; <span class="string">" -&gt; "</span></span><br><span class="line">                 &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; <span class="string">" is "</span></span><br><span class="line">                 &lt;&lt; (conn-&gt;connected() ? <span class="string">"UP"</span> : <span class="string">"DOWN"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!conn-&gt;connected())</span><br><span class="line">            loop_-&gt;quit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn, Buffer *buf, Timestamp receiveTime)</span> </span>&#123;</span><br><span class="line">        buf-&gt;retrieveAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EventLoop *loop_;</span><br><span class="line">    TcpClient client_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="六、Five-in-one"><a href="#六、Five-in-one" class="headerlink" title="六、Five in one"></a>六、Five in one</h2><p>前面五个程序都用到了 EventLoop，这其实是个 Reactor，用于注册和分发 IO 事件。Muduo 遵循 one loop per thread 模型，<strong>多个服务端(TcpServer)和客户端(TcpClient)可以共享同一个 EventLoop，也可以分配到多个 EventLoop 上以发挥多核多线程的好处</strong>。<strong>这里我们把五个服务端用同一个 EventLoop 跑起来，程序还是单线程的，功能却强大了很多</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">"pid = "</span> &lt;&lt; getpid();</span><br><span class="line">    EventLoop loop;  <span class="comment">// one loop shared by multiple servers</span></span><br><span class="line"></span><br><span class="line">    <span class="function">ChargenServer <span class="title">chargenServer</span><span class="params">(&amp;loop, InetAddress(<span class="number">2019</span>))</span></span>;</span><br><span class="line">    chargenServer.start();</span><br><span class="line"></span><br><span class="line">    <span class="function">DaytimeServer <span class="title">daytimeServer</span><span class="params">(&amp;loop, InetAddress(<span class="number">2013</span>))</span></span>;</span><br><span class="line">    daytimeServer.start();</span><br><span class="line"></span><br><span class="line">    <span class="function">DiscardServer <span class="title">discardServer</span><span class="params">(&amp;loop, InetAddress(<span class="number">2009</span>))</span></span>;</span><br><span class="line">    discardServer.start();</span><br><span class="line"></span><br><span class="line">    <span class="function">EchoServer <span class="title">echoServer</span><span class="params">(&amp;loop, InetAddress(<span class="number">2007</span>))</span></span>;</span><br><span class="line">    echoServer.start();</span><br><span class="line"></span><br><span class="line">    <span class="function">TimeServer <span class="title">timeServer</span><span class="params">(&amp;loop, InetAddress(<span class="number">2037</span>))</span></span>;</span><br><span class="line">    timeServer.start();</span><br><span class="line"></span><br><span class="line">    loop.loop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上几个协议的消息格式都非常简单，<strong>没有涉及 TCP 网络编程中常见的分包处理</strong>，在下一篇文章讲 Boost.Asio 的聊天服务器时我们再来讨论这个问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文链接 &lt;a href=&quot;https://blog.csdn.net/Solstice/article/details/6171905&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/S
      
    
    </summary>
    
    
      <category term="开源组件" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/"/>
    
      <category term="muduo" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/"/>
    
    
      <category term="Cpp" scheme="http://yoursite.com/tags/Cpp/"/>
    
      <category term="TCP" scheme="http://yoursite.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>muduo 中的 net 组件</title>
    <link href="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E4%B8%AD%E7%9A%84net%E7%BB%84%E4%BB%B6/"/>
    <id>http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E4%B8%AD%E7%9A%84net%E7%BB%84%E4%BB%B6/</id>
    <published>2020-03-09T02:57:01.062Z</published>
    <updated>2020-03-09T02:57:36.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>类之间的耦合关系</p><ol><li><p>最底层</p><p> Buffer：√</p><p> Socket：√</p><p> Timer：√</p><p> Channel ：和 EventLoop 相互耦合 √</p></li><li><p>第二层</p><p> TimerId ：依赖 Timer √</p><p> Poller ：依赖 Channel，和 EventLoop 相互耦合 √</p><p> Connector ：依赖 Channel，和 EventLoop 相互耦合 √</p><p> Acceptor ：依赖 Channel 和 Socket，和 EventLoop 相互耦合 √</p><p> TimerQueue ：依赖 Timer 和 Channel，和 EventLoop 相互耦合 √</p></li><li><p>第三层</p><p> EventLoop ：和 Channel、Poller 和 TimerQueue 相互耦合 √</p></li><li><p>第四层</p><p> EventLoopThread ：依赖 EventLoop √</p><p> TcpConnection ：依赖 EventLoop、Socket、Channel 和 Buffer √</p></li><li><p>第五层</p><p> EventLoopThreadPool ：依赖 EventLoopThread √</p><p> TcpServer ：依赖 EventLoop、Acceptor、EventLoopThread 和 TcpConnection √</p><p> TcpClient ：依赖 EventLoop 、 Connector 和 TcpConnection √</p></li></ol></li></ol><ul><li><a href="#%e6%9c%80%e5%ba%95%e5%b1%82">最底层</a><ul><li><a href="#1-buffer">1. Buffer</a></li><li><a href="#2-socket">2. Socket</a></li><li><a href="#3-timer">3. Timer</a></li><li><a href="#4-channel">4. Channel</a></li></ul></li><li><a href="#%e7%ac%ac%e4%ba%8c%e5%b1%82">第二层</a><ul><li><a href="#1-timerid">1. TimerId</a></li><li><a href="#2-poller">2. Poller</a></li><li><a href="#3-acceptor">3. Acceptor</a></li><li><a href="#4-timerqueue">4. TimerQueue</a></li><li><a href="#5-connector">5. Connector</a></li></ul></li><li><a href="#%e7%ac%ac%e4%b8%89%e5%b1%82">第三层</a><ul><li><a href="#1-eventloop">1. EventLoop</a></li></ul></li><li><a href="#%e7%ac%ac%e5%9b%9b%e5%b1%82">第四层</a><ul><li><a href="#1-eventloopthread">1. EventLoopThread</a></li><li><a href="#2-tcpconnection">2. TcpConnection</a></li></ul></li><li><a href="#%e7%ac%ac%e4%ba%94%e5%b1%82">第五层</a><ul><li><a href="#1-eventloopthreadpool">1. EventLoopThreadPool</a></li><li><a href="#2-tcpserver">2. TcpServer</a></li><li><a href="#3-tcpclient">3. TcpClient</a></li></ul></li></ul><h2 id="最底层"><a href="#最底层" class="headerlink" title="最底层"></a>最底层</h2><h3 id="1-Buffer"><a href="#1-Buffer" class="headerlink" title="1. Buffer"></a>1. Buffer</h3><p>见 “./5_Buffer类的设计.md”</p><h3 id="2-Socket"><a href="#2-Socket" class="headerlink" title="2. Socket"></a>2. Socket</h3><p>socket_fd 的 wrapper，目标是提供了几种 Socket 的封装，例如 listen、bind 等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">InetAddress</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Socket</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="keyword">explicit</span> <span class="title">Socket</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span></span><br><span class="line"><span class="function">                    : <span class="title">sockfd_</span><span class="params">(sockfd)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">bindAddress</span><span class="params">(<span class="keyword">const</span> InetAddress &amp;localaddr)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(InetAddress *peeraddr)</span></span>;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> sockfd_;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure><h3 id="3-Timer"><a href="#3-Timer" class="headerlink" title="3. Timer"></a>3. Timer</h3><p>用于时间事件的内部类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Timer</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            Timer(TimerCallback cb, Timestamp when, <span class="keyword">double</span> interval)</span><br><span class="line">                    : callback_(<span class="built_in">std</span>::move(cb)),</span><br><span class="line">                      expiration_(when),</span><br><span class="line">                      interval_(interval),</span><br><span class="line">                      repeat_(interval &gt; <span class="number">0.0</span>),</span><br><span class="line">                      sequence_(s_numCreated_.incrementAndGet()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">                callback_();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">restart</span><span class="params">(Timestamp now)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (repeat_) &#123;</span><br><span class="line">                    expiration_ = addTime(now, interval_);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    expiration_ = Timestamp::invalid();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">Timestamp <span class="title">expiration</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">            <span class="function"><span class="keyword">bool</span> <span class="title">repeat</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">            <span class="function"><span class="keyword">int64_t</span> <span class="title">sequence</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">            <span class="function"><span class="keyword">static</span> <span class="keyword">int64_t</span> <span class="title">numCreated</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="keyword">const</span> TimerCallback callback_;</span><br><span class="line">            Timestamp expiration_;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">double</span> interval_;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">bool</span> repeat_;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int64_t</span> sequence_;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">static</span> AtomicInt64 s_numCreated_;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure><h3 id="4-Channel"><a href="#4-Channel" class="headerlink" title="4. Channel"></a>4. Channel</h3><p>用于注册与响应 IO 事件</p><ol><li>构造函数中和一个 EventLoop 绑定、和一个文件描述符 fd 绑定</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">EventLoop</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Channel</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            Channel(EventLoop *loop, <span class="keyword">int</span> fd);</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure><ol start="2"><li>IO 事件类型分为两种：ReadEventCallback 和 EventCallback；有四种回调函数类型：readCallback_、writeCallback_、closeCallback_ 和 errorCallback_，可以通过 setXXX 函数来注册（注意 std::move() 将左值转化为了右值引用以减少拷贝次数）</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Channel</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; EventCallback;</span><br><span class="line">            <span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(Timestamp)&gt; ReadEventCallback;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">setReadCallback</span><span class="params">(ReadEventCallback cb)</span> </span>&#123; readCallback_ = <span class="built_in">std</span>::move(cb); &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">setWriteCallback</span><span class="params">(EventCallback cb)</span> </span>&#123; writeCallback_ = <span class="built_in">std</span>::move(cb); &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">setCloseCallback</span><span class="params">(EventCallback cb)</span> </span>&#123; closeCallback_ = <span class="built_in">std</span>::move(cb); &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">setErrorCallback</span><span class="params">(EventCallback cb)</span> </span>&#123; errorCallback_ = <span class="built_in">std</span>::move(cb); &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            ReadEventCallback readCallback_;</span><br><span class="line">            EventCallback writeCallback_;</span><br><span class="line">            EventCallback closeCallback_;</span><br><span class="line">            EventCallback errorCallback_;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure><ol start="3"><li>设置事件读写能力，通过对 events_ 变量设置掩码完成，并且通知绑定的 EventLoop update</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Channel</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">enableReading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                events_ |= kReadEvent;</span><br><span class="line">                update();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">disableReading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                events_ &amp;= ~kReadEvent;</span><br><span class="line">                update();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">enableWriting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                events_ |= kWriteEvent;</span><br><span class="line">                update();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">disableWriting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                events_ &amp;= ~kWriteEvent;</span><br><span class="line">                update();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">disableAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                events_ = kNoneEvent;</span><br><span class="line">                update();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kNoneEvent = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kReadEvent = POLLIN | POLLPRI;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kWriteEvent = POLLOUT;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> events_;</span><br><span class="line"></span><br><span class="line">            update() &#123;</span><br><span class="line">                addedToLoop_ = <span class="literal">true</span>;</span><br><span class="line">                loop_-&gt;updateChannel(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure><ol start="4"><li><p>处理事件</p><p> revents_ 变量由 Poller 设置，表征事件的类型；处理事件时根据事件类型，调用注册好的几种回调函数</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Channel::handleEventWithGuard</span><span class="params">(Timestamp receiveTime)</span> </span>&#123;</span><br><span class="line">    eventHandling_ = <span class="literal">true</span>;</span><br><span class="line">    LOG_TRACE &lt;&lt; reventsToString();</span><br><span class="line">    <span class="keyword">if</span> ((revents_ &amp; POLLHUP) &amp;&amp; !(revents_ &amp; POLLIN)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logHup_) &#123;</span><br><span class="line">            LOG_WARN &lt;&lt; <span class="string">"fd = "</span> &lt;&lt; fd_ &lt;&lt; <span class="string">" Channel::handle_event() POLLHUP"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (closeCallback_) &#123;</span><br><span class="line">            closeCallback_();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (revents_ &amp; POLLNVAL) &#123;</span><br><span class="line">        LOG_WARN &lt;&lt; <span class="string">"fd = "</span> &lt;&lt; fd_ &lt;&lt; <span class="string">" Channel::handle_event() POLLNVAL"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (revents_ &amp; (POLLERR | POLLNVAL)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errorCallback_) &#123;</span><br><span class="line">            errorCallback_();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (revents_ &amp; (POLLIN | POLLPRI | POLLRDHUP)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (readCallback_) &#123;</span><br><span class="line">            readCallback_(receiveTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (revents_ &amp; POLLOUT) &#123;</span><br><span class="line">        <span class="keyword">if</span> (writeCallback_) &#123;</span><br><span class="line">            writeCallback_();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    eventHandling_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第二层"><a href="#第二层" class="headerlink" title="第二层"></a>第二层</h2><h3 id="1-TimerId"><a href="#1-TimerId" class="headerlink" title="1. TimerId"></a>1. TimerId</h3><p>用于取消 Timer</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Timer</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">TimerId</span> :</span> <span class="keyword">public</span> muduo::copyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            TimerId()</span><br><span class="line">                    : timer_(<span class="literal">NULL</span>),</span><br><span class="line">                      sequence_(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">            TimerId(Timer *timer, <span class="keyword">int64_t</span> seq)</span><br><span class="line">                    : timer_(timer),</span><br><span class="line">                      sequence_(seq) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// default copy-ctor, dtor and assignment are okay</span></span><br><span class="line">            <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerQueue</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            Timer *timer_;</span><br><span class="line">            <span class="keyword">int64_t</span> sequence_;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure><h3 id="2-Poller"><a href="#2-Poller" class="headerlink" title="2. Poller"></a>2. Poller</h3><ol><li><p>IO 多路复用的虚基类，和一个 EventLoop 对象绑定，poll 方法必须在 loop 线程中调用。</p></li><li><p>一个 Poller 对象中可以包含多个 Channel，代表多个 IO 事件</p></li><li><p>有两个实现类：PollPoller 底层使用 poll；EPollPoller 底层使用 epoll</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Channel</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Poller</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Channel *&gt; ChannelList;</span><br><span class="line"></span><br><span class="line">            Poller(EventLoop *loop);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">virtual</span> ~Poller();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// Polls the I/O events.</span></span><br><span class="line">            <span class="comment">/// Must be called in the loop thread.</span></span><br><span class="line">            <span class="function"><span class="keyword">virtual</span> Timestamp <span class="title">poll</span><span class="params">(<span class="keyword">int</span> timeoutMs, ChannelList *activeChannels)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// Changes the interested I/O events.</span></span><br><span class="line">            <span class="comment">/// Must be called in the loop thread.</span></span><br><span class="line">            <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">updateChannel</span><span class="params">(Channel *channel)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// Remove the channel, when it destructs.</span></span><br><span class="line">            <span class="comment">/// Must be called in the loop thread.</span></span><br><span class="line">            <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">removeChannel</span><span class="params">(Channel *channel)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hasChannel</span><span class="params">(Channel *channel)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">static</span> Poller *<span class="title">newDefaultPoller</span><span class="params">(EventLoop *loop)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">assertInLoopThread</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">                ownerLoop_-&gt;assertInLoopThread();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span>:</span><br><span class="line">            <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, Channel *&gt; ChannelMap;</span><br><span class="line">            ChannelMap channels_;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            EventLoop *ownerLoop_;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure><h3 id="3-Acceptor"><a href="#3-Acceptor" class="headerlink" title="3. Acceptor"></a>3. Acceptor</h3><p>用于接受 TCP 连接</p><ol><li>构造函数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Acceptor</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            Acceptor(EventLoop *loop, <span class="keyword">const</span> InetAddress &amp;listenAddr, <span class="keyword">bool</span> reuseport) : </span><br><span class="line">                loop_(loop), </span><br><span class="line">                acceptSocket_(sockets::createNonblockingOrDie(listenAddr.family())),</span><br><span class="line">                acceptChannel_(loop, acceptSocket_.fd()),</span><br><span class="line">                listenning_(<span class="literal">false</span>),</span><br><span class="line">                idleFd_(::open(<span class="string">"/dev/null"</span>, O_RDONLY | O_CLOEXEC)) &#123;</span><br><span class="line"></span><br><span class="line">                assert(idleFd_ &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                acceptSocket_.setReuseAddr(<span class="literal">true</span>);</span><br><span class="line">                acceptSocket_.setReusePort(reuseport);</span><br><span class="line">                acceptSocket_.bindAddress(listenAddr);</span><br><span class="line">                acceptChannel_.setReadCallback(</span><br><span class="line">                <span class="built_in">std</span>::bind(&amp;Acceptor::handleRead, <span class="keyword">this</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            EventLoop *loop_;</span><br><span class="line">            Socket acceptSocket_;</span><br><span class="line">            Channel acceptChannel_;</span><br><span class="line">            NewConnectionCallback newConnectionCallback_;</span><br><span class="line">            <span class="keyword">bool</span> listenning_;</span><br><span class="line">            <span class="keyword">int</span> idleFd_;    </span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure><p>每个 Acceptor 和一个 EventLoop 绑定，并且传入一个 InetAddress 对象用于构造 Socket 监听的端口。</p><p>在构造函数中，acceptSocket_ 对象初始化好，acceptChannel_ 也初始化好，并且注册 Read 事件的 CallBack 为 Acceptor::handleRead。</p><p>Acceptor::handleRead 的代码是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Acceptor::handleRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    InetAddress peerAddr;</span><br><span class="line">    <span class="comment">//FIXME loop until no more</span></span><br><span class="line">    <span class="keyword">int</span> connfd = acceptSocket_.accept(&amp;peerAddr);</span><br><span class="line">    <span class="keyword">if</span> (connfd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// string hostport = peerAddr.toIpPort();</span></span><br><span class="line">        <span class="comment">// LOG_TRACE &lt;&lt; "Accepts of " &lt;&lt; hostport;</span></span><br><span class="line">        <span class="keyword">if</span> (newConnectionCallback_) &#123;</span><br><span class="line">            newConnectionCallback_(connfd, peerAddr);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sockets::close(connfd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOG_SYSERR &lt;&lt; <span class="string">"in Acceptor::handleRead"</span>;</span><br><span class="line">        <span class="comment">// Read the section named "The special problem of</span></span><br><span class="line">        <span class="comment">// accept()ing when you can't" in libev's doc.</span></span><br><span class="line">        <span class="comment">// By Marc Lehmann, author of libev.</span></span><br><span class="line">        <span class="keyword">if</span> (errno == EMFILE) &#123;</span><br><span class="line">            ::close(idleFd_);</span><br><span class="line">            idleFd_ = ::accept(acceptSocket_.fd(), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">            ::close(idleFd_);</span><br><span class="line">            idleFd_ = ::open(<span class="string">"/dev/null"</span>, O_RDONLY | O_CLOEXEC);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，一旦 acceptChannel_ 产生了 read 事件，它就会调用 Acceptor 注册好的 newConnectionCallback_ 回调函数。</p><ol start="2"><li>listen</li></ol><p>让 acceptSocket_ 开始 listen 某个端口（这个不是阻塞的），然后打开 acceptChannel_ 的读事件能力。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Acceptor::listen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    listenning_ = <span class="literal">true</span>;</span><br><span class="line">    acceptSocket_.listen();</span><br><span class="line">    acceptChannel_.enableReading();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-TimerQueue"><a href="#4-TimerQueue" class="headerlink" title="4. TimerQueue"></a>4. TimerQueue</h3><p>一个 Timer 队列，用于管理定时事件</p><ol><li>构造函数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">TimerQueue</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="keyword">explicit</span> <span class="title">TimerQueue</span><span class="params">(EventLoop *loop)</span>: </span></span><br><span class="line">                loop_(loop),</span><br><span class="line">                timerfd_(createTimerfd()),</span><br><span class="line">                timerfdChannel_(loop, timerfd_),</span><br><span class="line">                timers_(),</span><br><span class="line">                callingExpiredTimers_(<span class="literal">false</span>) &#123;</span><br><span class="line"></span><br><span class="line">                timerfdChannel_.setReadCallback(<span class="built_in">std</span>::bind(&amp;TimerQueue::handleRead, <span class="keyword">this</span>));</span><br><span class="line">    </span><br><span class="line">                timerfdChannel_.enableReading();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">typedef</span> <span class="built_in">std</span>::pair&lt;Timestamp, Timer *&gt; Entry;</span><br><span class="line">            <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">set</span>&lt;Entry&gt; TimerList;</span><br><span class="line"></span><br><span class="line">            EventLoop *loop_;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> timerfd_;</span><br><span class="line">            Channel timerfdChannel_;</span><br><span class="line">            <span class="comment">// Timer list sorted by expiration</span></span><br><span class="line">            TimerList timers_;</span><br><span class="line">            <span class="keyword">bool</span> callingExpiredTimers_; <span class="comment">/* atomic */</span></span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure><p>在构造函数中，首先将一个 TimerQueue 和一个 EventLoop 绑定，然后创建一个 timer 的 fd，然后用这个 fd 构造一个 timerfdChannel_。这个 timerfdChannel_ 会设置一个 Read 事件的 CallBack 回调函数，看一下这个回调函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TimerQueue::handleRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    <span class="function">Timestamp <span class="title">now</span><span class="params">(Timestamp::now())</span></span>;</span><br><span class="line">    readTimerfd(timerfd_, now);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Entry&gt; expired = getExpired(now);</span><br><span class="line"></span><br><span class="line">    callingExpiredTimers_ = <span class="literal">true</span>;</span><br><span class="line">    cancelingTimers_.clear();</span><br><span class="line">    <span class="comment">// safe to callback outside critical section</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> Entry &amp;it : expired) &#123;</span><br><span class="line">        it.second-&gt;run();</span><br><span class="line">    &#125;</span><br><span class="line">    callingExpiredTimers_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    reset(expired, now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个回调函数的大致原理是：如果 timerfdChannel_ 变得可读，说明有时间事件到达了；此时找一下过期的 timer 们，执行一下 timer 的 callback 函数</p><ol start="2"><li>addTimer</li></ol><p>添加一个 Timer。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">TimerQueue</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function">TimerId <span class="title">addTimer</span><span class="params">(TimerCallback cb, Timestamp when, <span class="keyword">double</span> interval)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                Timer *timer = <span class="keyword">new</span> Timer(<span class="built_in">std</span>::move(cb), when, interval);</span><br><span class="line">    </span><br><span class="line">                loop_-&gt;runInLoop(<span class="built_in">std</span>::bind(&amp;TimerQueue::addTimerInLoop, <span class="keyword">this</span>, timer));</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> TimerId(timer, timer-&gt;sequence());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p>具体方式是先 new 一个 Timer 对象，然后向绑定的 EventLoop 对象添加。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::runInLoop</span><span class="params">(Functor cb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isInLoopThread()) &#123;</span><br><span class="line">        cb();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        queueInLoop(<span class="built_in">std</span>::move(cb));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EventLoop 要么直接执行，要么稍后执行（对于添加 Timer 这个行为，很可能发生在其他线程），但是无论如何最终都会执行 addTimerInLoop 方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TimerQueue::addTimerInLoop</span><span class="params">(Timer *timer)</span> </span>&#123;</span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    <span class="keyword">bool</span> earliestChanged = insert(timer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (earliestChanged) &#123;</span><br><span class="line">        resetTimerfd(timerfd_, timer-&gt;expiration());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>细节没有关注，整体思路就是更新 timer 列表</p><ol start="3"><li>cancel</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">TimerQueue</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">(TimerId timerId)</span> </span>&#123;</span><br><span class="line">                loop_-&gt;runInLoop(<span class="built_in">std</span>::bind(&amp;TimerQueue::cancelInLoop, <span class="keyword">this</span>, timerId));</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure><p>和 addTimer 一样，最终也是到 EventLoop 中执行，接下来看 cancelInLoop</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TimerQueue::cancelInLoop</span><span class="params">(TimerId timerId)</span> </span>&#123;</span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    assert(timers_.size() == activeTimers_.size());</span><br><span class="line">    <span class="function">ActiveTimer <span class="title">timer</span><span class="params">(timerId.timer_, timerId.sequence_)</span></span>;</span><br><span class="line">    ActiveTimerSet::iterator it = activeTimers_.find(timer);</span><br><span class="line">    <span class="keyword">if</span> (it != activeTimers_.end()) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> n = timers_.erase(Entry(it-&gt;first-&gt;expiration(), it-&gt;first));</span><br><span class="line">        assert(n == <span class="number">1</span>);</span><br><span class="line">        (<span class="keyword">void</span>) n;</span><br><span class="line">        <span class="keyword">delete</span> it-&gt;first; <span class="comment">// <span class="doctag">FIXME:</span> no delete please</span></span><br><span class="line">        activeTimers_.erase(it);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (callingExpiredTimers_) &#123;</span><br><span class="line">        cancelingTimers_.insert(timer);</span><br><span class="line">    &#125;</span><br><span class="line">    assert(timers_.size() == activeTimers_.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本思路也是更新 TimerQueue 中的 Timer 列表</p><h3 id="5-Connector"><a href="#5-Connector" class="headerlink" title="5. Connector"></a>5. Connector</h3><p>属于 TcpClient 的底层组件，用于发起 TCP 连接，它是 TcpClient 的成员，生命期由后者控制。</p><ol><li>构造函数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Connector</span> :</span> noncopyable,</span><br><span class="line">                          <span class="keyword">public</span> <span class="built_in">std</span>::enable_shared_from_this&lt;Connector&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            Connector(EventLoop *loop, <span class="keyword">const</span> InetAddress &amp;serverAddr) : </span><br><span class="line">                loop_(loop),</span><br><span class="line">                serverAddr_(serverAddr),</span><br><span class="line">                connect_(<span class="literal">false</span>),</span><br><span class="line">                state_(kDisconnected),</span><br><span class="line">                retryDelayMs_(kInitRetryDelayMs) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kInitRetryDelayMs = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">            EventLoop *loop_;</span><br><span class="line">            InetAddress serverAddr_;</span><br><span class="line">            <span class="keyword">bool</span> connect_; <span class="comment">// atomic</span></span><br><span class="line">            States state_;  <span class="comment">// <span class="doctag">FIXME:</span> use atomic variable</span></span><br><span class="line">            <span class="keyword">int</span> retryDelayMs_;</span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure><p>绑定一个 EventLoop，指定一下 server 的地址和端口</p><ol start="2"><li>start</li></ol><p>可以在任何线程中调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Connector::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    connect_ = <span class="literal">true</span>;</span><br><span class="line">    loop_-&gt;runInLoop(<span class="built_in">std</span>::bind(&amp;Connector::startInLoop, <span class="keyword">this</span>)); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Connector::startInLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    assert(state_ == kDisconnected);</span><br><span class="line">    <span class="keyword">if</span> (connect_) &#123;</span><br><span class="line">        connect();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOG_DEBUG &lt;&lt; <span class="string">"do not connect"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Connector::connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = sockets::createNonblockingOrDie(serverAddr_.family());</span><br><span class="line">    <span class="keyword">int</span> ret = sockets::connect(sockfd, serverAddr_.getSockAddr());</span><br><span class="line">    <span class="keyword">int</span> savedErrno = (ret == <span class="number">0</span>) ? <span class="number">0</span> : errno;</span><br><span class="line">    <span class="keyword">switch</span> (savedErrno) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">case</span> EINPROGRESS:</span><br><span class="line">        <span class="keyword">case</span> EINTR:</span><br><span class="line">        <span class="keyword">case</span> EISCONN:</span><br><span class="line">            connecting(sockfd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EAGAIN:</span><br><span class="line">        <span class="keyword">case</span> EADDRINUSE:</span><br><span class="line">        <span class="keyword">case</span> EADDRNOTAVAIL:</span><br><span class="line">        <span class="keyword">case</span> ECONNREFUSED:</span><br><span class="line">        <span class="keyword">case</span> ENETUNREACH:</span><br><span class="line">            retry(sockfd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EACCES:</span><br><span class="line">        <span class="keyword">case</span> EPERM:</span><br><span class="line">        <span class="keyword">case</span> EAFNOSUPPORT:</span><br><span class="line">        <span class="keyword">case</span> EALREADY:</span><br><span class="line">        <span class="keyword">case</span> EBADF:</span><br><span class="line">        <span class="keyword">case</span> EFAULT:</span><br><span class="line">        <span class="keyword">case</span> ENOTSOCK:</span><br><span class="line">            LOG_SYSERR &lt;&lt; <span class="string">"connect error in Connector::startInLoop "</span> &lt;&lt; savedErrno;</span><br><span class="line">            sockets::close(sockfd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            LOG_SYSERR &lt;&lt; <span class="string">"Unexpected error in Connector::startInLoop "</span> &lt;&lt; savedErrno;</span><br><span class="line">            sockets::close(sockfd);</span><br><span class="line">            <span class="comment">// connectErrorCallback_();</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>start 方法从客户端开启一个 TCP 连接。基本做法是把 connect 放在 EventLoop 中执行，最终会开启 socket::connect</p><p>在 connect 方法中有很多种情况，最终归结为 3 大类：connecting、retry 和 close，close 就是 socket::close 就行了，重点看一下前两个。</p><p>先看 retry，retry 的操作是先把原来的 sockfd close 掉，然后设一个定时任务 runAfter，而这个延时时延每次翻倍，直到到达最大阈值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Connector::retry</span><span class="params">(<span class="keyword">int</span> sockfd)</span> </span>&#123;</span><br><span class="line">    sockets::close(sockfd);</span><br><span class="line">    setState(kDisconnected);</span><br><span class="line">    <span class="keyword">if</span> (connect_) &#123;</span><br><span class="line">        LOG_INFO &lt;&lt; <span class="string">"Connector::retry - Retry connecting to "</span> &lt;&lt; serverAddr_.toIpPort()</span><br><span class="line">                 &lt;&lt; <span class="string">" in "</span> &lt;&lt; retryDelayMs_ &lt;&lt; <span class="string">" milliseconds. "</span>;</span><br><span class="line">        loop_-&gt;runAfter(retryDelayMs_ / <span class="number">1000.0</span>,</span><br><span class="line">                        <span class="built_in">std</span>::bind(&amp;Connector::startInLoop, shared_from_this()));</span><br><span class="line">        retryDelayMs_ = <span class="built_in">std</span>::min(retryDelayMs_ * <span class="number">2</span>, kMaxRetryDelayMs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOG_DEBUG &lt;&lt; <span class="string">"do not connect"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种是 connecting，能进入 connecting 说明 connect 阻塞过程已经结束，接下来正式进入通讯过程，因此设置 channel 的两个回调。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Connector::connecting</span><span class="params">(<span class="keyword">int</span> sockfd)</span> </span>&#123;</span><br><span class="line">    setState(kConnecting);</span><br><span class="line">    assert(!channel_);</span><br><span class="line"></span><br><span class="line">    channel_.reset(<span class="keyword">new</span> Channel(loop_, sockfd));</span><br><span class="line">    channel_-&gt;setWriteCallback(</span><br><span class="line">            <span class="built_in">std</span>::bind(&amp;Connector::handleWrite, <span class="keyword">this</span>)); </span><br><span class="line">    channel_-&gt;setErrorCallback(</span><br><span class="line">            <span class="built_in">std</span>::bind(&amp;Connector::handleError, <span class="keyword">this</span>)); </span><br><span class="line">    channel_-&gt;enableWriting();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看一下 WriteCallback，基本就是执行一下设置好的 newConnectionCallback_</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Connector::handleWrite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">"Connector::handleWrite "</span> &lt;&lt; state_;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (state_ == kConnecting) &#123;</span><br><span class="line">        <span class="keyword">int</span> sockfd = removeAndResetChannel();</span><br><span class="line">        <span class="keyword">int</span> err = sockets::getSocketError(sockfd);</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            LOG_WARN &lt;&lt; <span class="string">"Connector::handleWrite - SO_ERROR = "</span></span><br><span class="line">                     &lt;&lt; err &lt;&lt; <span class="string">" "</span> &lt;&lt; strerror_tl(err);</span><br><span class="line">            retry(sockfd);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sockets::isSelfConnect(sockfd)) &#123;</span><br><span class="line">            LOG_WARN &lt;&lt; <span class="string">"Connector::handleWrite - Self connect"</span>;</span><br><span class="line">            retry(sockfd);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            setState(kConnected);</span><br><span class="line">            <span class="keyword">if</span> (connect_) &#123;</span><br><span class="line">                newConnectionCallback_(sockfd);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sockets::close(sockfd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// what happened?</span></span><br><span class="line">        assert(state_ == kDisconnected);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看一下 ErrorCallback，基本操作就是 log 然后 retry。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Connector::handleError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOG_ERROR &lt;&lt; <span class="string">"Connector::handleError state="</span> &lt;&lt; state_;</span><br><span class="line">    <span class="keyword">if</span> (state_ == kConnecting) &#123;</span><br><span class="line">        <span class="keyword">int</span> sockfd = removeAndResetChannel();</span><br><span class="line">        <span class="keyword">int</span> err = sockets::getSocketError(sockfd);</span><br><span class="line">        LOG_TRACE &lt;&lt; <span class="string">"SO_ERROR = "</span> &lt;&lt; err &lt;&lt; <span class="string">" "</span> &lt;&lt; strerror_tl(err);</span><br><span class="line">        retry(sockfd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>restart</li></ol><p>restart 只能在 loop thread 中被调用，目标是重新设置各项 connector 参数，然后重启这个 connector</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Connector::restart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    setState(kDisconnected);</span><br><span class="line">    retryDelayMs_ = kInitRetryDelayMs;</span><br><span class="line">    connect_ = <span class="literal">true</span>;</span><br><span class="line">    startInLoop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第三层"><a href="#第三层" class="headerlink" title="第三层"></a>第三层</h2><h3 id="1-EventLoop"><a href="#1-EventLoop" class="headerlink" title="1. EventLoop"></a>1. EventLoop</h3><p>封装事件循环，也是事件分派的中心。它用 TimerQueue 作为计时器管理，用 Poller 作为 IO Multiplexing。</p><ol><li>构造函数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">EventLoop</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            EventLoop()</span><br><span class="line">                : </span><br><span class="line">                looping_(<span class="literal">false</span>),</span><br><span class="line">                quit_(<span class="literal">false</span>),</span><br><span class="line">                eventHandling_(<span class="literal">false</span>),</span><br><span class="line">                callingPendingFunctors_(<span class="literal">false</span>),</span><br><span class="line">                iteration_(<span class="number">0</span>),</span><br><span class="line">                threadId_(CurrentThread::tid()),</span><br><span class="line">                poller_(Poller::newDefaultPoller(<span class="keyword">this</span>)),</span><br><span class="line">                timerQueue_(<span class="keyword">new</span> TimerQueue(<span class="keyword">this</span>)),</span><br><span class="line">                wakeupFd_(createEventfd()),</span><br><span class="line">                wakeupChannel_(<span class="keyword">new</span> Channel(<span class="keyword">this</span>, wakeupFd_)),</span><br><span class="line">                currentActiveChannel_(<span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">                LOG_DEBUG &lt;&lt; <span class="string">"EventLoop created "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">" in thread "</span> &lt;&lt; threadId_;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (t_loopInThisThread) &#123;</span><br><span class="line">                    LOG_FATAL &lt;&lt; <span class="string">"Another EventLoop "</span> &lt;&lt; t_loopInThisThread &lt;&lt; <span class="string">" exists in this thread "</span> &lt;&lt; threadId_;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    t_loopInThisThread = <span class="keyword">this</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                wakeupChannel_-&gt;setReadCallback(<span class="built_in">std</span>::bind(&amp;EventLoop::handleRead, <span class="keyword">this</span>));</span><br><span class="line">    </span><br><span class="line">                wakeupChannel_-&gt;enableReading();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="keyword">bool</span> looping_; <span class="comment">/* atomic */</span></span><br><span class="line">            <span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; quit_;</span><br><span class="line">            <span class="keyword">bool</span> eventHandling_; <span class="comment">/* atomic */</span></span><br><span class="line">            <span class="keyword">bool</span> callingPendingFunctors_; <span class="comment">/* atomic */</span></span><br><span class="line">            <span class="keyword">int64_t</span> iteration_;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">pid_t</span> threadId_;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Poller&gt; poller_;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;TimerQueue&gt; timerQueue_;</span><br><span class="line">            <span class="keyword">int</span> wakeupFd_;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Channel&gt; wakeupChannel_;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure><p>在构造函数中，构造了 Poller 和 TimerQueue。</p><p>另外就是构造了 wakeupChannel_，这个 channel 的 fd 是 eventfd，注册的 read 回调函数是下面这样，目前不知道这个 channel 是干啥的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::handleRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> one = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> n = sockets::read(wakeupFd_, &amp;one, <span class="keyword">sizeof</span> one);</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="keyword">sizeof</span> one) &#123;</span><br><span class="line">        LOG_ERROR &lt;&lt; <span class="string">"EventLoop::handleRead() reads "</span> &lt;&lt; n &lt;&lt; <span class="string">" bytes instead of 8"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>Channel 相关</li></ol><p>一共有 3 个相关的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">EventLoop</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">updateChannel</span><span class="params">(Channel *channel)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">removeChannel</span><span class="params">(Channel *channel)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">bool</span> <span class="title">hasChannel</span><span class="params">(Channel *channel)</span></span>;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Poller&gt; poller_;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure><p>这几个函数的本质是向内部的 poller_ 对象注册或注销</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::updateChannel</span><span class="params">(Channel *channel)</span> </span>&#123;</span><br><span class="line">    assert(channel-&gt;ownerLoop() == <span class="keyword">this</span>);</span><br><span class="line">    assertInLoopThread();</span><br><span class="line">    poller_-&gt;updateChannel(channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::removeChannel</span><span class="params">(Channel *channel)</span> </span>&#123;</span><br><span class="line">    assert(channel-&gt;ownerLoop() == <span class="keyword">this</span>);</span><br><span class="line">    assertInLoopThread();</span><br><span class="line">    <span class="keyword">if</span> (eventHandling_) &#123;</span><br><span class="line">        assert(currentActiveChannel_ == channel ||</span><br><span class="line">               <span class="built_in">std</span>::find(activeChannels_.begin(), activeChannels_.end(), channel) == activeChannels_.end());</span><br><span class="line">    &#125;</span><br><span class="line">    poller_-&gt;removeChannel(channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EventLoop::hasChannel</span><span class="params">(Channel *channel)</span> </span>&#123;</span><br><span class="line">    assert(channel-&gt;ownerLoop() == <span class="keyword">this</span>);</span><br><span class="line">    assertInLoopThread();</span><br><span class="line">    <span class="keyword">return</span> poller_-&gt;hasChannel(channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>Timer 相关</li></ol><p>一共有 4 个相关方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">EventLoop</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function">TimerId <span class="title">runAt</span><span class="params">(Timestamp time, TimerCallback cb)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function">TimerId <span class="title">runAfter</span><span class="params">(<span class="keyword">double</span> delay, TimerCallback cb)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function">TimerId <span class="title">runEvery</span><span class="params">(<span class="keyword">double</span> interval, TimerCallback cb)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">(TimerId timerId)</span></span>;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;TimerQueue&gt; timerQueue_;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure><p>这几个方法的目标是注册定时回调函数或取消，实现靠的是内部的 TimerQueue 对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TimerId <span class="title">EventLoop::runAt</span><span class="params">(Timestamp time, TimerCallback cb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> timerQueue_-&gt;addTimer(<span class="built_in">std</span>::move(cb), time, <span class="number">0.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TimerId <span class="title">EventLoop::runAfter</span><span class="params">(<span class="keyword">double</span> delay, TimerCallback cb)</span> </span>&#123;</span><br><span class="line">    <span class="function">Timestamp <span class="title">time</span><span class="params">(addTime(Timestamp::now(), delay))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> runAt(time, <span class="built_in">std</span>::move(cb));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TimerId <span class="title">EventLoop::runEvery</span><span class="params">(<span class="keyword">double</span> interval, TimerCallback cb)</span> </span>&#123;</span><br><span class="line">    <span class="function">Timestamp <span class="title">time</span><span class="params">(addTime(Timestamp::now(), interval))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> timerQueue_-&gt;addTimer(<span class="built_in">std</span>::move(cb), time, interval);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::cancel</span><span class="params">(TimerId timerId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> timerQueue_-&gt;cancel(timerId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>loop </li></ol><p><code>EventLoop.h</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">EventLoop</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; Functor;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="keyword">bool</span> looping_; <span class="comment">/* atomic */</span></span><br><span class="line">            <span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; quit_;</span><br><span class="line">            <span class="keyword">int64_t</span> iteration_;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Poller&gt; poller_;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// scratch variables</span></span><br><span class="line">            ChannelList activeChannels_;</span><br><span class="line">            Channel *currentActiveChannel_;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure><p><code>EventLoop.cc</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kPollTimeMs = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    assert(!looping_);</span><br><span class="line">    assertInLoopThread();</span><br><span class="line"></span><br><span class="line">    looping_ = <span class="literal">true</span>;</span><br><span class="line">    quit_ = <span class="literal">false</span>;  </span><br><span class="line"></span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">"EventLoop "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">" start looping"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!quit_) &#123;</span><br><span class="line">        activeChannels_.clear();</span><br><span class="line">        pollReturnTime_ = poller_-&gt;poll(kPollTimeMs, &amp;activeChannels_);</span><br><span class="line">        ++iteration_;</span><br><span class="line">        <span class="keyword">if</span> (Logger::logLevel() &lt;= Logger::TRACE) &#123;</span><br><span class="line">            printActiveChannels();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// TODO sort channel by priority</span></span><br><span class="line">        eventHandling_ = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (Channel *channel : activeChannels_) &#123;</span><br><span class="line">            currentActiveChannel_ = channel;</span><br><span class="line">            currentActiveChannel_-&gt;handleEvent(pollReturnTime_);</span><br><span class="line">        &#125;</span><br><span class="line">        currentActiveChannel_ = <span class="literal">NULL</span>;</span><br><span class="line">        eventHandling_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        doPendingFunctors();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">"EventLoop "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">" stop looping"</span>;</span><br><span class="line">    looping_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loop 方法是一个死循环，它的主体是让 poller_ 监听一段时间的 IO 事件，然后调用已经注册好的这些 Channel 的各种 CallBack 函数进行处理；处理完这些事件以后，每一次循环会 doPendingFunctors 一次，看一下这个方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::doPendingFunctors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Functor&gt; functors;</span><br><span class="line">    callingPendingFunctors_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        functors.swap(pendingFunctors_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> Functor &amp;functor : functors) &#123;</span><br><span class="line">        functor();</span><br><span class="line">    &#125;</span><br><span class="line">    callingPendingFunctors_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的作用是有一些未执行的方法 pendingFunctors，在这个里面依次执行一下，pendingFunctors_ 是在以下的函数中被更新的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::runInLoop</span><span class="params">(Functor cb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isInLoopThread()) &#123;</span><br><span class="line">        cb();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        queueInLoop(<span class="built_in">std</span>::move(cb));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::queueInLoop</span><span class="params">(Functor cb)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        pendingFunctors_.push_back(<span class="built_in">std</span>::move(cb));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isInLoopThread() || callingPendingFunctors_) &#123;</span><br><span class="line">        wakeup();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>外部调用的接口是 runInLoop，如果 cb 没有被立刻执行，那么它就会加入到 pendingFunctors_ 中，等待在每次循环中执行掉。</p><p>事件包括了两部分：刚才说的是 IO 事件，还有一部分是 Timer 定时的事件，Timer 事件其实也跟 doPendingFunctors 有关：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TimerId <span class="title">EventLoop::runAt</span><span class="params">(Timestamp time, TimerCallback cb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> timerQueue_-&gt;addTimer(<span class="built_in">std</span>::move(cb), time, <span class="number">0.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TimerId <span class="title">TimerQueue::addTimer</span><span class="params">(TimerCallback cb,</span></span></span><br><span class="line"><span class="function"><span class="params">                             Timestamp when,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">double</span> interval)</span> </span>&#123;</span><br><span class="line">    Timer *timer = <span class="keyword">new</span> Timer(<span class="built_in">std</span>::move(cb), when, interval);</span><br><span class="line">    loop_-&gt;runInLoop(</span><br><span class="line">            <span class="built_in">std</span>::bind(&amp;TimerQueue::addTimerInLoop, <span class="keyword">this</span>, timer));</span><br><span class="line">    <span class="keyword">return</span> &#123;timer, timer-&gt;sequence()&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在 addTimer 时，本质上也把回调函数加到了 EventLoop 的 runInLoop 中，只不过回调函数是 TimerQueue::addTimerInLoop。</p><p>Timer 一旦注册好以后，跟 IO 事件一样，因为 timer 本身也有一个 timerfd，到时以后会唤醒，本质上还是一个 fd 的 IO。</p><p>TimerQueue 和 刚才的 wakeupChannel_ 的本质其实是一样的，TimerQueue 内部也有一个 Channel，对应一个 timerfd</p><p><code>TimerQueue.h</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">TimerQueue</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> timerfd_;</span><br><span class="line">            Channel timerfdChannel_;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="keyword">namespace</span> detail &#123;</span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">createTimerfd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> timerfd = ::timerfd_create(CLOCK_MONOTONIC, TFD_NONBLOCK | TFD_CLOEXEC);</span><br><span class="line">                <span class="keyword">if</span> (timerfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    LOG_SYSFATAL &lt;&lt; <span class="string">"Failed in timerfd_create"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> timerfd;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;  <span class="comment">// namespace detail</span></span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br><span class="line">```        </span><br><span class="line"></span><br><span class="line">`EventLoop.h`</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">EventLoop</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="keyword">int</span> wakeupFd_;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Channel&gt; wakeupChannel_;</span><br><span class="line">            </span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">createEventfd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> evtfd = ::eventfd(<span class="number">0</span>, EFD_NONBLOCK | EFD_CLOEXEC);</span><br><span class="line">        <span class="keyword">if</span> (evtfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            LOG_SYSERR &lt;&lt; <span class="string">"Failed in eventfd"</span>;</span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> evtfd;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>它们的底层都是一个系统调用，各产生一个 fd：timerfd 产生的是定时事件，eventfd 产生的事件，目标是让 poll 快速返回：向 eventfd 写入一个字节，就会产生一个可读事件，从而实现 poll 阻塞方法的快速返回。</p><p>无论是 TimerQueue 中的 timerfdChannel_，还是 EventLoop 中的 wakeupChannel_，都需要向 poller 中注册从而监听，这部分代码藏的比较深，在 Channel 的 enableReading 里面：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Channel::enableReading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    events_ |= kReadEvent;</span><br><span class="line">    update();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Channel::update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    addedToLoop_ = <span class="literal">true</span>;</span><br><span class="line">    loop_-&gt;updateChannel(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::updateChannel</span><span class="params">(Channel *channel)</span> </span>&#123;</span><br><span class="line">    assert(channel-&gt;ownerLoop() == <span class="keyword">this</span>);</span><br><span class="line">    assertInLoopThread();</span><br><span class="line">    poller_-&gt;updateChannel(channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>套了好几层，最终还是向 poller 注册上了。。。</p><p>总之，这个 loop 方法是 Reactor 模式的核心：一个 loop 一个 Thread，先向 poller 注册好要监听的 Channel，Channel 又包括了 3 种类型：要监听的 IO 端口、timerfd 抽象成的时间事件 Channel 和 为了快速推出阻塞而额外留好的 eventfd 抽象成的 Channel。产生事件以后，poller 退出阻塞，调用各个 channel 上注册好的处理回调函数。另外，在 loop 期间其他线程加入的方法，先 pending，然后一并处理一下。</p><ol start="5"><li>quit</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">EventLoop</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                quit_ = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">                <span class="keyword">if</span> (!isInLoopThread()) &#123;</span><br><span class="line">                    wakeup();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">wakeup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">uint64_t</span> one = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">ssize_t</span> n = sockets::write(wakeupFd_, &amp;one, <span class="keyword">sizeof</span> one);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (n != <span class="keyword">sizeof</span> one) &#123;</span><br><span class="line">                    LOG_ERROR &lt;&lt; <span class="string">"EventLoop::wakeup() writes "</span> &lt;&lt; n &lt;&lt; <span class="string">" bytes instead of 8"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure><p>quit 函数的目标是结束整个 loop：如果调用者就在当前线程，那么直接把 while 循环开始时的 quit 变量置为 true 即可；反之，为了快速退出 poller 的阻塞，向提前预留好的 wakeupfd 写一个字节，这样 poller 监听的 channel 就产生了可读事件，从而让阻塞退出。</p><h2 id="第四层"><a href="#第四层" class="headerlink" title="第四层"></a>第四层</h2><h3 id="1-EventLoopThread"><a href="#1-EventLoopThread" class="headerlink" title="1. EventLoopThread"></a>1. EventLoopThread</h3><p>启动一个线程，在其中运行 EventLoop::loop()</p><ol><li>构造函数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">EventLoopThread</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(EventLoop *)&gt; ThreadInitCallback;</span><br><span class="line"></span><br><span class="line">            explicit EventLoopThread(const ThreadInitCallback &amp;cb = ThreadInitCallback(), const string &amp;name = string()) : loop_(NULL),</span><br><span class="line">                        exiting_(<span class="literal">false</span>),</span><br><span class="line">                        thread_(<span class="built_in">std</span>::bind(&amp;EventLoopThread::threadFunc, <span class="keyword">this</span>), name),</span><br><span class="line">                        mutex_(),</span><br><span class="line">                        cond_(mutex_),</span><br><span class="line">                        callback_(cb) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="function">EventLoop *loop_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">            <span class="keyword">bool</span> exiting_;</span><br><span class="line">            Thread thread_;</span><br><span class="line">            MutexLock mutex_;</span><br><span class="line">            <span class="function">Condition cond_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">            ThreadInitCallback callback_;</span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure><p>其中，内部的 thread_ 对象注册的 func 是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoopThread::threadFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EventLoop loop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (callback_) &#123;</span><br><span class="line">        callback_(&amp;loop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        loop_ = &amp;loop;</span><br><span class="line">        cond_.notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    loop.loop();</span><br><span class="line">    <span class="comment">//assert(exiting_);</span></span><br><span class="line">    <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    loop_ = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，在新开的 Thread 中，会先跑 ThreadInitCallBack，然后运行 loop.loop()</p><ol start="2"><li>startLoop</li></ol><p>开始一个 loop，注意这里用 mutex 和 cond 保护 loop 的初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EventLoop *<span class="title">EventLoopThread::startLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assert(!thread_.started());</span><br><span class="line">    thread_.start();</span><br><span class="line"></span><br><span class="line">    EventLoop *loop = <span class="literal">NULL</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (loop_ == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            cond_.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        loop = loop_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-TcpConnection"><a href="#2-TcpConnection" class="headerlink" title="2. TcpConnection"></a>2. TcpConnection</h3><p>整个网络库的核心，封装一次 TCP 连接。每个 TcpConnection 必须归某个 EventLoop 管理，所有的 IO 会转移到这个线程。TcpConnection 既可以用于 Server，也可以用于 Client。</p><ol><li>构造函数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">TcpConnection</span> :</span> noncopyable,</span><br><span class="line">                              <span class="keyword">public</span> <span class="built_in">std</span>::enable_shared_from_this&lt;TcpConnection&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            TcpConnection(EventLoop *loop,</span><br><span class="line">                          <span class="keyword">const</span> <span class="built_in">string</span> &amp;name,</span><br><span class="line">                          <span class="keyword">int</span> sockfd,</span><br><span class="line">                          <span class="keyword">const</span> InetAddress &amp;localAddr,</span><br><span class="line">                          <span class="keyword">const</span> InetAddress &amp;peerAddr): </span><br><span class="line">                    loop_(CHECK_NOTNULL(loop)),</span><br><span class="line">                    name_(nameArg),</span><br><span class="line">                    state_(kConnecting),</span><br><span class="line">                    reading_(<span class="literal">true</span>),</span><br><span class="line">                    socket_(<span class="keyword">new</span> Socket(sockfd)),</span><br><span class="line">                    channel_(<span class="keyword">new</span> Channel(loop, sockfd)),</span><br><span class="line">                    localAddr_(localAddr),</span><br><span class="line">                    peerAddr_(peerAddr),</span><br><span class="line">                    highWaterMark_(<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>) &#123;</span><br><span class="line"></span><br><span class="line">                channel_-&gt;setReadCallback(<span class="built_in">std</span>::bind(&amp;TcpConnection::handleRead, <span class="keyword">this</span>, _1));</span><br><span class="line"></span><br><span class="line">                channel_-&gt;setWriteCallback(<span class="built_in">std</span>::bind(&amp;TcpConnection::handleWrite, <span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">                channel_-&gt;setCloseCallback(<span class="built_in">std</span>::bind(&amp;TcpConnection::handleClose, <span class="keyword">this</span>));</span><br><span class="line">    </span><br><span class="line">                channel_-&gt;setErrorCallback(<span class="built_in">std</span>::bind(&amp;TcpConnection::handleError, <span class="keyword">this</span>));</span><br><span class="line">    </span><br><span class="line">                LOG_DEBUG &lt;&lt; <span class="string">"TcpConnection::ctor["</span> &lt;&lt; name_ &lt;&lt; <span class="string">"] at "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">" fd="</span> &lt;&lt; sockfd;</span><br><span class="line">    </span><br><span class="line">                socket_-&gt;setKeepAlive(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="keyword">enum</span> StateE &#123;</span><br><span class="line">                kDisconnected, kConnecting, kConnected, kDisconnecting</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            EventLoop *loop_;</span><br><span class="line">            <span class="keyword">const</span> <span class="built_in">string</span> name_;</span><br><span class="line">            StateE state_;  </span><br><span class="line">            <span class="keyword">bool</span> reading_;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Socket&gt; socket_;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Channel&gt; channel_;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> InetAddress localAddr_;</span><br><span class="line">            <span class="keyword">const</span> InetAddress peerAddr_;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">size_t</span> highWaterMark_;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure><p>这个构造函数比较复杂：一个 TcpConnection 和一个 EventLoop 绑定；根据 sockfd 构造一个 Socket 对象；根据 EventLoop 和 sockfd 构造一个 Channel 对象。</p><p>localAddr_、peerAddr_ 和 highWaterMark_ 暂时还不知道代表什么；</p><p>每个 channel 可以设置 4 种 CallBack，在构造函数中都设置了，接下来依次看一下.</p><ol start="2"><li><p>4 种 CallBack</p><ol><li><p>ReadCallBack</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::handleRead</span><span class="params">(Timestamp receiveTime)</span> </span>&#123;</span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    <span class="keyword">int</span> savedErrno = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> n = inputBuffer_.readFd(channel_-&gt;fd(), &amp;savedErrno);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        messageCallback_(shared_from_this(), &amp;inputBuffer_, receiveTime);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        handleClose();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        errno = savedErrno;</span><br><span class="line">        LOG_SYSERR &lt;&lt; <span class="string">"TcpConnection::handleRead"</span>;</span><br><span class="line">    </span><br><span class="line">        handleError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReadCallback 的目标是从内核把数据读到 inputBuffer_ 中，然后执行注册好的 messageCallback_。</p></li><li><p>WriteCallBack</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::handleWrite</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    <span class="keyword">if</span> (channel_-&gt;isWriting()) &#123;</span><br><span class="line">        <span class="keyword">ssize_t</span> n = sockets::write(channel_-&gt;fd(), outputBuffer_.peek(), outputBuffer_.readableBytes());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            outputBuffer_.retrieve(n);</span><br><span class="line">            <span class="keyword">if</span> (outputBuffer_.readableBytes() == <span class="number">0</span>) &#123;</span><br><span class="line">                channel_-&gt;disableWriting();</span><br><span class="line">                <span class="keyword">if</span> (writeCompleteCallback_) &#123;</span><br><span class="line">                    loop_-&gt;queueInLoop(<span class="built_in">std</span>::bind(writeCompleteCallback_, shared_from_this()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (state_ == kDisconnecting) &#123;</span><br><span class="line">                    shutdownInLoop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LOG_SYSERR &lt;&lt; <span class="string">"TcpConnection::handleWrite"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOG_TRACE &lt;&lt; <span class="string">"Connection fd = "</span> &lt;&lt; channel_-&gt;fd() &lt;&lt; <span class="string">" is down, no more writing"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WriteCallBack 的目标是把 outputBuffer_ 中的数据写到内核缓冲区中。如果把 outputBuffer_ 中的数据都写完了的话，那么就调用注册好的 writeCompleteCallback_</p></li><li><p>CloseCallBack</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::handleClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">"fd = "</span> &lt;&lt; channel_-&gt;fd() &lt;&lt; <span class="string">" state = "</span> &lt;&lt; stateToString();</span><br><span class="line"></span><br><span class="line">    assert(state_ == kConnected || state_ == kDisconnecting);</span><br><span class="line"></span><br><span class="line">    setState(kDisconnected);</span><br><span class="line"></span><br><span class="line">    channel_-&gt;disableAll();</span><br><span class="line"></span><br><span class="line">    <span class="function">TcpConnectionPtr <span class="title">guardThis</span><span class="params">(shared_from_this())</span></span>;</span><br><span class="line">    connectionCallback_(guardThis);</span><br><span class="line">    <span class="comment">// must be the last line</span></span><br><span class="line">    closeCallback_(guardThis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 CloseCallBack 中不关闭 sockfd，，只是设置状态且关闭 Channel 的读写能力，并调用 connectionCallback_</p></li><li><p>ErrorCallBack</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::handleError</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> err = sockets::getSocketError(channel_-&gt;fd());</span><br><span class="line">    LOG_ERROR &lt;&lt; <span class="string">"TcpConnection::handleError ["</span> &lt;&lt; name_ &lt;&lt; <span class="string">"] - SO_ERROR = "</span> &lt;&lt; err &lt;&lt; <span class="string">" "</span> &lt;&lt; strerror_tl(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个比较简单，获取一下 SocketError 就可以了</p></li></ol></li><li><p>send 方法</p></li></ol><p>总共有 3 个 public 方法</p><p><code>TcpConnection.h</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">TcpConnection</span> :</span> noncopyable,</span><br><span class="line">                              <span class="keyword">public</span> <span class="built_in">std</span>::enable_shared_from_this&lt;TcpConnection&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *message, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">const</span> StringPiece &amp;message)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(Buffer *message)</span></span>;  <span class="comment">// this one will swap data</span></span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::send</span><span class="params">(<span class="keyword">const</span> StringPiece &amp;message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state_ == kConnected) &#123;</span><br><span class="line">        <span class="keyword">if</span> (loop_-&gt;isInLoopThread()) &#123;</span><br><span class="line">            sendInLoop(message);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">void</span> (TcpConnection::*fp)(<span class="keyword">const</span> StringPiece &amp;message)</span><br><span class="line">            = &amp;TcpConnection::sendInLoop;</span><br><span class="line">            loop_-&gt;runInLoop(<span class="built_in">std</span>::bind(fp,<span class="keyword">this</span>, message.as_string()));</span><br><span class="line">            <span class="comment">//std::forward&lt;string&gt;(message)));</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::sendInLoop</span><span class="params">(<span class="keyword">const</span> StringPiece &amp;message)</span> </span>&#123;</span><br><span class="line">    sendInLoop(message.data(), message.size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::sendInLoop</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    <span class="keyword">ssize_t</span> nwrote = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> remaining = len;</span><br><span class="line">    <span class="keyword">bool</span> faultError = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (state_ == kDisconnected) &#123;</span><br><span class="line">        LOG_WARN &lt;&lt; <span class="string">"disconnected, give up writing"</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if no thing in output queue, try writing directly</span></span><br><span class="line">    <span class="keyword">if</span> (!channel_-&gt;isWriting() &amp;&amp; outputBuffer_.readableBytes() == <span class="number">0</span>) &#123;</span><br><span class="line">        nwrote = sockets::write(channel_-&gt;fd(), data, len);</span><br><span class="line">        <span class="keyword">if</span> (nwrote &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            remaining = len - nwrote;</span><br><span class="line">            <span class="keyword">if</span> (remaining == <span class="number">0</span> &amp;&amp; writeCompleteCallback_) &#123;</span><br><span class="line">                loop_-&gt;queueInLoop(<span class="built_in">std</span>::bind(writeCompleteCallback_, shared_from_this()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="comment">// nwrote &lt; 0</span></span><br><span class="line">        &#123;</span><br><span class="line">            nwrote = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (errno != EWOULDBLOCK) &#123;</span><br><span class="line">                LOG_SYSERR &lt;&lt; <span class="string">"TcpConnection::sendInLoop"</span>;</span><br><span class="line">                <span class="keyword">if</span> (errno == EPIPE || errno == ECONNRESET) <span class="comment">// <span class="doctag">FIXME:</span> any others?</span></span><br><span class="line">                &#123;</span><br><span class="line">                    faultError = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(remaining &lt;= len);</span><br><span class="line">    <span class="keyword">if</span> (!faultError &amp;&amp; remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> oldLen = outputBuffer_.readableBytes();</span><br><span class="line">        <span class="keyword">if</span> (oldLen + remaining &gt;= highWaterMark_</span><br><span class="line">            &amp;&amp; oldLen &lt; highWaterMark_</span><br><span class="line">            &amp;&amp; highWaterMarkCallback_) &#123;</span><br><span class="line">            loop_-&gt;queueInLoop(<span class="built_in">std</span>::bind(highWaterMarkCallback_, shared_from_this(), oldLen + remaining));</span><br><span class="line">        &#125;</span><br><span class="line">        outputBuffer_.append(<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt;(data) + nwrote, remaining);</span><br><span class="line">        <span class="keyword">if</span> (!channel_-&gt;isWriting()) &#123;</span><br><span class="line">            channel_-&gt;enableWriting();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>send 方法的主要思想是：如果 outputBuffer_ 中没有数据了，那么尝试直接通过 sockfd 写，不经过 outBuffer_ 这一中间环节了；否则的话，就把数据先写到 outputBuffer_ 中，等待 Channel 有写事件的时候，再通过注册好的 handleWrite 方法中，从 outputBuffer 写到 sockfd 中。</p><ol start="4"><li>shutdown() 方法</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> use compare and swap</span></span><br><span class="line">    <span class="keyword">if</span> (state_ == kConnected) &#123;</span><br><span class="line">        setState(kDisconnecting);</span><br><span class="line">        <span class="comment">// <span class="doctag">FIXME:</span> shared_from_this()?</span></span><br><span class="line">        loop_-&gt;runInLoop(<span class="built_in">std</span>::bind(&amp;TcpConnection::shutdownInLoop, <span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::shutdownInLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    <span class="keyword">if</span> (!channel_-&gt;isWriting()) &#123;</span><br><span class="line">        <span class="comment">// we are not writing</span></span><br><span class="line">        socket_-&gt;shutdownWrite();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较简单，就是同步或者异步 shutdown socket</p><ol start="5"><li>forceClose 和 forceCloseWithDelay</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::forceClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> use compare and swap</span></span><br><span class="line">    <span class="keyword">if</span> (state_ == kConnected || state_ == kDisconnecting) &#123;</span><br><span class="line">        setState(kDisconnecting);</span><br><span class="line">        loop_-&gt;queueInLoop(<span class="built_in">std</span>::bind(&amp;TcpConnection::forceCloseInLoop,</span><br><span class="line">                shared_from_this()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::forceCloseWithDelay</span><span class="params">(<span class="keyword">double</span> seconds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state_ == kConnected || state_ == kDisconnecting) &#123;</span><br><span class="line">        setState(kDisconnecting);</span><br><span class="line">        loop_-&gt;runAfter(</span><br><span class="line">                seconds, makeWeakCallback(shared_from_this(), &amp;TcpConnection::forceClose));  <span class="comment">// not forceCloseInLoop to avoid race condition</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::forceCloseInLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    <span class="keyword">if</span> (state_ == kConnected || state_ == kDisconnecting) &#123;</span><br><span class="line">        <span class="comment">// as if we received 0 byte in handleRead();</span></span><br><span class="line">        handleClose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也比较简单，最终是同步或异步调用 CloseCallBack</p><h2 id="第五层"><a href="#第五层" class="headerlink" title="第五层"></a>第五层</h2><h3 id="1-EventLoopThreadPool"><a href="#1-EventLoopThreadPool" class="headerlink" title="1. EventLoopThreadPool"></a>1. EventLoopThreadPool</h3><p>用于创建 IO 线程池，也就是说把 TcpConnection 分派到一组运行 EventLoop 的线程上。它是 TcpServer 的成员，生命期由后者控制</p><ol><li>构造函数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">EventLoopThreadPool</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            EventLoopThreadPool(EventLoop *baseLoop, <span class="keyword">const</span> <span class="built_in">string</span> &amp;nameArg) : </span><br><span class="line">                baseLoop_(baseLoop),</span><br><span class="line">                name_(nameArg),</span><br><span class="line">                started_(<span class="literal">false</span>),</span><br><span class="line">                numThreads_(<span class="number">0</span>),</span><br><span class="line">                next_(<span class="number">0</span>) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            EventLoop *baseLoop_;</span><br><span class="line">            <span class="built_in">string</span> name_;</span><br><span class="line">            <span class="keyword">bool</span> started_;</span><br><span class="line">            <span class="keyword">int</span> numThreads_;</span><br><span class="line">            <span class="keyword">int</span> next_;</span><br><span class="line">            </span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure><p>EventLoopThreadPool 有一个基本的 baseLoop_</p><ol start="2"><li>start</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">EventLoopThreadPool</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">const</span> ThreadInitCallback &amp;cb = ThreadInitCallback())</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                assert(!started_);</span><br><span class="line">                baseLoop_-&gt;assertInLoopThread();</span><br><span class="line"></span><br><span class="line">                started_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numThreads_; ++i) &#123;</span><br><span class="line">                    <span class="keyword">char</span> buf[name_.size() + <span class="number">32</span>];</span><br><span class="line">                    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf, <span class="string">"%s%d"</span>, name_.c_str(), i);</span><br><span class="line"></span><br><span class="line">                    EventLoopThread *t = <span class="keyword">new</span> EventLoopThread(cb, buf);</span><br><span class="line">        </span><br><span class="line">                    threads_.push_back(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;EventLoopThread&gt;(t));</span><br><span class="line"></span><br><span class="line">                    loops_.push_back(t-&gt;startLoop());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (numThreads_ == <span class="number">0</span> &amp;&amp; cb) &#123;</span><br><span class="line">                    cb(baseLoop_);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;EventLoopThread&gt;&gt; threads_;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;EventLoop *&gt; loops_;</span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure><p>这个方法会开 numThreads_ 个线程，并且在 numThreads_ 线程里面让 EventLoop 开始 loop 起来，在 EventLoopThreadPool 中保存好这个 Thread 和这些 EventLoop</p><ol start="3"><li>getNextLoop</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">EventLoopThreadPool</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function">EventLoop *<span class="title">getNextLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                baseLoop_-&gt;assertInLoopThread();</span><br><span class="line">                assert(started_);</span><br><span class="line">                EventLoop *loop = baseLoop_;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!loops_.empty()) &#123;</span><br><span class="line">                    <span class="comment">// round-robin</span></span><br><span class="line">                    loop = loops_[next_];</span><br><span class="line">                    ++next_;</span><br><span class="line">                    <span class="keyword">if</span> (implicit_cast&lt;<span class="keyword">size_t</span>&gt;(next_) &gt;= loops_.size()) &#123;</span><br><span class="line">                        next_ = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> loop;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="keyword">int</span> numThreads_;</span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure><p>这个方法是用来把 TcpConnection 分派到一组运行 EventLoop 的线程上，采取的方式是 round-robin</p><h3 id="2-TcpServer"><a href="#2-TcpServer" class="headerlink" title="2. TcpServer"></a>2. TcpServer</h3><p>用于编写网络服务器，接受客户的连接</p><ol><li>构造函数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">TcpServer</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            TcpServer(EventLoop *loop,</span><br><span class="line">                      <span class="keyword">const</span> InetAddress &amp;listenAddr,</span><br><span class="line">                      <span class="keyword">const</span> <span class="built_in">string</span> &amp;nameArg,</span><br><span class="line">                      Option option = kNoReusePort) : </span><br><span class="line">                    loop_(CHECK_NOTNULL(loop)),</span><br><span class="line">                    ipPort_(listenAddr.toIpPort()),</span><br><span class="line">                    name_(nameArg),</span><br><span class="line">                    acceptor_(<span class="keyword">new</span> Acceptor(loop, listenAddr,option == kReusePort)),</span><br><span class="line">                    threadPool_(<span class="keyword">new</span> EventLoopThreadPool(loop, name_)),</span><br><span class="line">                    connectionCallback_(defaultConnectionCallback),</span><br><span class="line">                    messageCallback_(defaultMessageCallback),</span><br><span class="line">                    nextConnId_(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">                acceptor_-&gt;setNewConnectionCallback(<span class="built_in">std</span>::bind(&amp;TcpServer::newConnection, <span class="keyword">this</span>, _1, _2));</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            EventLoop *loop_;  <span class="comment">// the acceptor loop</span></span><br><span class="line">            <span class="keyword">const</span> <span class="built_in">string</span> ipPort_;</span><br><span class="line">            <span class="keyword">const</span> <span class="built_in">string</span> name_;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Acceptor&gt; acceptor_; <span class="comment">// avoid revealing Acceptor</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;EventLoopThreadPool&gt; threadPool_;</span><br><span class="line">            ConnectionCallback connectionCallback_;</span><br><span class="line">            MessageCallback messageCallback_;</span><br><span class="line">            <span class="keyword">int</span> nextConnId_;</span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure><p>这个构造函数里面也干了很多事情：绑定 EventLoop；构造 Acceptor、构造 EventLoopThreadPool、设置 connectionCallback_ 和 messageCallback_。</p><p>其中，acceptor_ 设置了 NewConnectionCallback ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpServer::newConnection</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> InetAddress &amp;peerAddr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    EventLoop *ioLoop = threadPool_-&gt;getNextLoop();</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">64</span>];</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf, <span class="string">"-%s#%d"</span>, ipPort_.c_str(), nextConnId_);</span><br><span class="line">    ++nextConnId_;</span><br><span class="line">    <span class="built_in">string</span> connName = name_ + buf;</span><br><span class="line"></span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">"TcpServer::newConnection ["</span> &lt;&lt; name_</span><br><span class="line">             &lt;&lt; <span class="string">"] - new connection ["</span> &lt;&lt; connName</span><br><span class="line">             &lt;&lt; <span class="string">"] from "</span> &lt;&lt; peerAddr.toIpPort();</span><br><span class="line">    <span class="function">InetAddress <span class="title">localAddr</span><span class="params">(sockets::getLocalAddr(sockfd))</span></span>;</span><br><span class="line">    <span class="comment">// FIXME poll with zero timeout to double confirm the new connection</span></span><br><span class="line">    <span class="comment">// FIXME use make_shared if necessary</span></span><br><span class="line">    <span class="function">TcpConnectionPtr <span class="title">conn</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">new</span> TcpConnection(ioLoop, connName, sockfd, localAddr, peerAddr))</span></span>;</span><br><span class="line">    connections_[connName] = conn;</span><br><span class="line">    </span><br><span class="line">    conn-&gt;setConnectionCallback(connectionCallback_);</span><br><span class="line">    conn-&gt;setMessageCallback(messageCallback_);</span><br><span class="line">    conn-&gt;setWriteCompleteCallback(writeCompleteCallback_);</span><br><span class="line">    conn-&gt;setCloseCallback(<span class="built_in">std</span>::bind(&amp;TcpServer::removeConnection, <span class="keyword">this</span>, _1)); <span class="comment">// <span class="doctag">FIXME:</span> unsafe</span></span><br><span class="line"></span><br><span class="line">    ioLoop-&gt;runInLoop(<span class="built_in">std</span>::bind(&amp;TcpConnection::connectEstablished, conn));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法比较重要。 Acceptor 用于接收 TCP 连接，它监听的是 listenfd；在连接到来后，会将 connfd 传入 newConnectionCallback_ 方法。</p><p>在这个 NewConnectionCallback 方法中，首先从 ThreadPool 中 Round-Robin 式的找一个 EventLoop，然后根据这个 connfd 新建一个 TcpConnection 传入这个 EventLoop 中，然后把这个 TcpConnection 的 4 种 CallBack 设置好，最终让这个 TcpConnection 放到 EventLoop 中开始跑。</p><p>接下来看看这 4 个 CallBack，这 4 个 CallBack 里面，connectionCallback_、messageCallback_ 和 writeCompleteCallback_ 都可以在 TcpServer 中外部 set，而 CloseCallback 是固定的：</p><ol start="2"><li><p>TcpConnection 的 4 个 CallBack</p><ol><li><p>connectionCallback_ </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> muduo::net::defaultConnectionCallback(<span class="keyword">const</span> TcpConnectionPtr &amp;conn) &#123;</span><br><span class="line"></span><br><span class="line">    LOG_TRACE &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; <span class="string">" -&gt; "</span> &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; <span class="string">" is "</span> &lt;&lt; (conn-&gt;connected() ? <span class="string">"UP"</span> : <span class="string">"DOWN"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do not call conn-&gt;forceClose(), because some users want to register message callback only.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Default 情况下啥也不干</p></li><li><p>messageCallback_</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> muduo::net::defaultMessageCallback(<span class="keyword">const</span> TcpConnectionPtr &amp;, Buffer *buf, Timestamp) &#123;</span><br><span class="line">    buf-&gt;retrieveAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>writeCompleteCallback_</p><p> 没有 Default</p></li><li><p>closeCallBack_</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">conn-&gt;setCloseCallback(<span class="built_in">std</span>::bind(&amp;TcpServer::removeConnection, <span class="keyword">this</span>, _1)); <span class="comment">// <span class="doctag">FIXME:</span> unsafe</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpServer::removeConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> unsafe</span></span><br><span class="line">    loop_-&gt;runInLoop(<span class="built_in">std</span>::bind(&amp;TcpServer::removeConnectionInLoop, <span class="keyword">this</span>, conn));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpServer::removeConnectionInLoop</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn)</span> </span>&#123;</span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">"TcpServer::removeConnectionInLoop ["</span> &lt;&lt; name_ &lt;&lt; <span class="string">"] - connection "</span> &lt;&lt; conn-&gt;name();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> n = connections_.erase(conn-&gt;name());</span><br><span class="line">    (<span class="keyword">void</span>) n;</span><br><span class="line">    assert(n == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    EventLoop *ioLoop = conn-&gt;getLoop();</span><br><span class="line">    ioLoop-&gt;queueInLoop(<span class="built_in">std</span>::bind(&amp;TcpConnection::connectDestroyed, conn));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::connectDestroyed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    <span class="keyword">if</span> (state_ == kConnected) &#123;</span><br><span class="line">        setState(kDisconnected);</span><br><span class="line">        channel_-&gt;disableAll();</span><br><span class="line">        connectionCallback_(shared_from_this());</span><br><span class="line">    &#125;</span><br><span class="line">    channel_-&gt;remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 CloseCallBack 的目标是移除对应 EventLoop 中的 Channel</p></li></ol></li><li><p>start 方法</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpServer::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (started_.getAndSet(<span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        threadPool_-&gt;start(threadInitCallback_);</span><br><span class="line"></span><br><span class="line">        assert(!acceptor_-&gt;listenning());</span><br><span class="line">        loop_-&gt;runInLoop(</span><br><span class="line">                <span class="built_in">std</span>::bind(&amp;Acceptor::listen, get_pointer(acceptor_)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先一个 CAS 操作保证一个 TcpServer 只 start 一次，然后让 ThreadPool 开始启动线程，同时让 Acceptor 开始监听端口</p><ol start="4"><li>析构函数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TcpServer::~TcpServer() &#123;</span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">"TcpServer::~TcpServer ["</span> &lt;&lt; name_ &lt;&lt; <span class="string">"] destructing"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;item : connections_) &#123;</span><br><span class="line">        <span class="function">TcpConnectionPtr <span class="title">conn</span><span class="params">(item.second)</span></span>;</span><br><span class="line">        item.second.reset();</span><br><span class="line">        conn-&gt;getLoop()-&gt;runInLoop(</span><br><span class="line">                <span class="built_in">std</span>::bind(&amp;TcpConnection::connectDestroyed, conn));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>析构函数中，让所有的 TcpConnection 对象的 Channel 都销毁掉。</p><h3 id="3-TcpClient"><a href="#3-TcpClient" class="headerlink" title="3. TcpClient"></a>3. TcpClient</h3><p>用于编写网络客户端，能发起连接，并且有重试功能。</p><ol><li>构造函数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">TcpClient</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            TcpClient(EventLoop *loop,</span><br><span class="line">                      <span class="keyword">const</span> InetAddress &amp;serverAddr,</span><br><span class="line">                      <span class="keyword">const</span> <span class="built_in">string</span> &amp;nameArg):</span><br><span class="line">                    loop_(CHECK_NOTNULL(loop)),</span><br><span class="line">                    connector_(<span class="keyword">new</span> Connector(loop, serverAddr)),</span><br><span class="line">                    name_(nameArg),</span><br><span class="line">                    connectionCallback_(defaultConnectionCallback),</span><br><span class="line">                    messageCallback_(defaultMessageCallback),</span><br><span class="line">                    retry_(<span class="literal">false</span>),</span><br><span class="line">                    connect_(<span class="literal">true</span>),</span><br><span class="line">                    nextConnId_(<span class="number">1</span>) &#123;</span><br><span class="line">    </span><br><span class="line">                connector_-&gt;setNewConnectionCallback(</span><br><span class="line">                <span class="built_in">std</span>::bind(&amp;TcpClient::newConnection, <span class="keyword">this</span>, _1));</span><br><span class="line">                LOG_INFO &lt;&lt; <span class="string">"TcpClient::TcpClient["</span> &lt;&lt; name_ &lt;&lt; <span class="string">"] - connector "</span> &lt;&lt; get_pointer(connector_);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            EventLoop *loop_;</span><br><span class="line">            ConnectorPtr connector_; <span class="comment">// avoid revealing Connector</span></span><br><span class="line">            <span class="keyword">const</span> <span class="built_in">string</span> name_;</span><br><span class="line">            ConnectionCallback connectionCallback_;</span><br><span class="line">            MessageCallback messageCallback_;</span><br><span class="line">            <span class="keyword">bool</span> retry_;   <span class="comment">// atomic</span></span><br><span class="line">            <span class="keyword">bool</span> connect_; <span class="comment">// atomic</span></span><br><span class="line">            <span class="comment">// always in loop thread</span></span><br><span class="line">            <span class="keyword">int</span> nextConnId_;</span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure><p>TcpClient 绑定一个 EventLoop，内部有一个 connector 用于新建 TCP 连接；connectionCallback_ 和 messageCallback_ 初始都设为 default，default 是啥也不干；Connector 要设置 NewConnection 的 Callback 如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpClient::newConnection</span><span class="params">(<span class="keyword">int</span> sockfd)</span> </span>&#123;</span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    <span class="function">InetAddress <span class="title">peerAddr</span><span class="params">(sockets::getPeerAddr(sockfd))</span></span>;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf,</span><br><span class="line">             <span class="string">":%s#%d"</span>, peerAddr.toIpPort().c_str(), nextConnId_);</span><br><span class="line">    ++nextConnId_;</span><br><span class="line">    <span class="built_in">string</span> connName = name_ + buf;</span><br><span class="line"></span><br><span class="line">    <span class="function">InetAddress <span class="title">localAddr</span><span class="params">(sockets::getLocalAddr(sockfd))</span></span>;</span><br><span class="line">    <span class="comment">// FIXME poll with zero timeout to double confirm the new connection</span></span><br><span class="line">    <span class="comment">// FIXME use make_shared if necessary</span></span><br><span class="line">    <span class="function">TcpConnectionPtr <span class="title">conn</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">new</span> TcpConnection(loop_, connName, sockfd, localAddr, peerAddr))</span></span>;</span><br><span class="line"></span><br><span class="line">    conn-&gt;setConnectionCallback(connectionCallback_);</span><br><span class="line">    conn-&gt;setMessageCallback(messageCallback_);</span><br><span class="line">    conn-&gt;setWriteCompleteCallback(writeCompleteCallback_);</span><br><span class="line">    conn-&gt;setCloseCallback(</span><br><span class="line">            <span class="built_in">std</span>::bind(&amp;TcpClient::removeConnection, <span class="keyword">this</span>, _1)); <span class="comment">// <span class="doctag">FIXME:</span> unsafe</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        connection_ = conn;</span><br><span class="line">    &#125;</span><br><span class="line">    conn-&gt;connectEstablished();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 Callback 的目标是打开一个 TcpConnection，这个 TcpConnection 注册好各种回调，然后 channel 开始监听。</p><ol start="2"><li>connect </li></ol><p>让内部的 connector 开始 connect </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpClient::connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> check state</span></span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">"TcpClient::connect["</span> &lt;&lt; name_ &lt;&lt; <span class="string">"] - connecting to "</span></span><br><span class="line">             &lt;&lt; connector_-&gt;serverAddress().toIpPort();</span><br><span class="line">    connect_ = <span class="literal">true</span>;</span><br><span class="line">    connector_-&gt;start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>disconnect</li></ol><p>断开 TcpConnection，对于 TcpClient，它只有一个 TcpConnection，这点和 TcpServer 明显不同</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpClient::disconnect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    connect_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (connection_) &#123;</span><br><span class="line">            connection_-&gt;shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>stop</li></ol><p>让内部的 connector stop</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpClient::stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    connect_ = <span class="literal">false</span>;</span><br><span class="line">    connector_-&gt;stop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>以上就把 muduo 中的 net 部分基本介绍完了，好累。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;类之间的耦合关系&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;最底层&lt;/p&gt;
&lt;p&gt; Buffer：√&lt;/p&gt;
&lt;p&gt; Socket：√&lt;/p&gt;
&lt;p&gt; Timer：√&lt;/p&gt;
&lt;p&gt; Channel ：和 EventLoop 相互耦合 √&lt;/p&gt;
&lt;/li&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="开源组件" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/"/>
    
      <category term="muduo" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/"/>
    
    
      <category term="Cpp" scheme="http://yoursite.com/tags/Cpp/"/>
    
      <category term="Net" scheme="http://yoursite.com/tags/Net/"/>
    
  </entry>
  
  <entry>
    <title>muduo 网络编程示例之零：前言</title>
    <link href="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B%E4%B9%8B%E9%9B%B6%EF%BC%9A%E5%89%8D%E8%A8%80/"/>
    <id>http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B%E4%B9%8B%E9%9B%B6%EF%BC%9A%E5%89%8D%E8%A8%80/</id>
    <published>2020-03-09T02:55:49.386Z</published>
    <updated>2020-03-09T02:56:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接 <a href="https://blog.csdn.net/Solstice/article/details/6171831" target="_blank" rel="noopener">https://blog.csdn.net/Solstice/article/details/6171831</a></p></blockquote><p>我将会写一系列文章，介绍用 muduo 网络库完成常见的 TCP 网络编程任务。目前计划如下：</p><ol><li>UNP 中的简单协议，包括 echo、daytime、time、discard 等。 </li><li>Boost.Asio 中的示例，包括 timer2~6、chat 等。</li><li>Java Netty 中的示例，包括 discard、echo、uptime 等，其中的 discard 和 echo 带流量统计功能。</li><li>Python twisted 中的示例，包括 finger01~07</li><li>用于测试两台机器的往返延迟的 roundtrip</li><li>用于测试两台机器的带宽的 pingpong</li><li>云风的串并转换连接服务器 multiplexer，包括单线程和多线程两个版本。</li><li>文件传输</li><li>一个基于 TCP 的应用层广播 hub</li><li>socks4a 代理服务器，包括简单的 TCP 中继(relay)。</li><li>一个 Sudoku 服务器的演变，从单线程到多线程，从阻塞到 event-based。</li><li>一个提供短址服务的 httpd 服务器</li></ol><p>其中前面 7 个已经放到了 muduo 代码的 examples 目录中，下载地址是： <a href="http://muduo.googlecode.com/files/muduo-0.1.5-alpha.tar.gz" target="_blank" rel="noopener">http://muduo.googlecode.com/files/muduo-0.1.5-alpha.tar.gz</a> </p><p>这些例子都比较简单，逻辑不复杂，代码也很短，适合摘取关键部分放到博客上。其中一些有一定的代表性与针对性，比如“如何传输完整的文件”估计是网络编程的初学者经常遇到的问题。请注意，<strong>muduo 是设计来开发内网的网络程序，它没有做任何安全方面的加强措施，如果用在公网上可能会受到攻击</strong>，在后面的例子中我会谈到这一点。</p><p>本系列文章适用于 <code>Linux 2.6.x (x &gt; 28)</code>，主要测试发行版为 <code>Ubuntu 10.04 LTS</code> 和 <code>Debian 6.0 Squeeze，64-bit x86</code> 硬件。</p><ul><li><a href="#1-tcp-%e7%bd%91%e7%bb%9c%e7%bc%96%e7%a8%8b%e6%9c%ac%e8%b4%a8%e8%ae%ba">1. TCP 网络编程本质论</a></li><li><a href="#2-muduo-%e7%ae%80%e4%bb%8b">2. Muduo 简介</a></li></ul><h2 id="1-TCP-网络编程本质论"><a href="#1-TCP-网络编程本质论" class="headerlink" title="1. TCP 网络编程本质论"></a>1. TCP 网络编程本质论</h2><p>我认为，TCP 网络编程最本质的是处理<strong>三个半事件</strong>：</p><ol><li><p><strong>连接的建立</strong>，包括服务端接受 (accept) 新连接和客户端成功发起 (connect) 连接。</p></li><li><p><strong>连接的断开</strong>，包括主动断开 (close 或 shutdown) 和被动断开 (read 返回 0)。</p></li><li><p><strong>消息到达，文件描述符可读</strong>。这是最为重要的一个事件，对它的处理方式决定了网络编程的风格（阻塞还是非阻塞，如何处理分包，应用层的缓冲如何设计等等）。</p></li><li><p><strong>消息发送完毕</strong>，这算半个。对于低流量的服务，可以不必关心这个事件；另外，<strong>这里“发送完毕”是指将数据写入操作系统的缓冲区，将由 TCP 协议栈负责数据的发送与重传</strong>，不代表对方已经收到数据。</p></li></ol><p>这其中有很多难点，也有很多细节需要注意，比方说：</p><ol><li><p><strong>如果要主动关闭连接，如何保证对方已经收到全部数据</strong>？如果应用层有缓冲（这在非阻塞网络编程中是必须的，见下文），那么如何保证先发送完缓冲区中的数据，然后再断开连接。直接调用 close(2) 恐怕是不行的。</p></li><li><p>如果主动发起连接，但是对方主动拒绝，<strong>如何定期 (带 back-off) 重试</strong>？</p></li><li><p><strong>非阻塞网络编程该用边沿触发(edge trigger)还是电平触发(level trigger)</strong>？（这两个中文术语有其他译法，我选择了一个电子工程师熟悉的说法。）如果是电平触发，那么什么时候关注 EPOLLOUT 事件？会不会造成 busy-loop？如果是边沿触发，如何防止漏读造成的饥饿？epoll 一定比 poll 快吗？</p></li><li><p>在非阻塞网络编程中，为什么要使用应用层缓冲区？假如一次读到的数据不够一个完整的数据包，那么这些已经读到的数据是不是应该先暂存在某个地方，等剩余的数据收到之后再一并处理？见 lighttpd 关于 /r/n/r/n 分包的 bug。假如数据是一个字节一个字节地到达，间隔 10ms，每个字节触发一次文件描述符可读 (readable) 事件，程序是否还能正常工作？lighttpd 在这个问题上出过安全漏洞。</p></li><li><p>在非阻塞网络编程中，如何设计并使用缓冲区？一方面我们希望减少系统调用，一次读的数据越多越划算，那么似乎应该准备一个大的缓冲区。另一方面，我们系统减少内存占用。如果有 10k 个连接，每个连接一建立就分配 64k 的读缓冲的话，将占用 640M 内存，而大多数时候这些缓冲区的使用率很低。muduo 用 readv 结合栈上空间巧妙地解决了这个问题。</p></li><li><p>如果使用发送缓冲区，万一接收方处理缓慢，数据会不会一直堆积在发送方，造成内存暴涨？如何做应用层的流量控制？</p></li><li><p><strong>如何设计并实现定时器</strong>？并使之与网络 IO 共用一个线程，以避免锁。</p></li></ol><p>这些问题在 muduo 的代码中可以找到答案。</p><h2 id="2-Muduo-简介"><a href="#2-Muduo-简介" class="headerlink" title="2. Muduo 简介"></a>2. Muduo 简介</h2><p>我编写 Muduo 网络库的目的之一就是简化日常的 TCP 网络编程，让程序员能把精力集中在业务逻辑的实现上，而不要天天和 Sockets API 较劲。借用 Brooks 的话说，我希望 Muduo 能减少网络编程中的偶发复杂性 (accidental complexity)。</p><p>Muduo 只支持 Linux 2.6.x 下的并发非阻塞 TCP 网络编程，它的安装方法见陈硕的 blog 文章。</p><p><strong>Muduo 的使用非常简单，不需要从指定的类派生，也不用覆写虚函数，只需要注册几个回调函数去处理前面提到的三个半事件就行了。</strong></p><p>以经典的 echo 回显服务为例：</p><ol><li>定义 <code>EchoServer class</code>，不需要派生自任何基类：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MUDUO_EXAMPLES_SIMPLE_ECHO_ECHO_H </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MUDUO_EXAMPLES_SIMPLE_ECHO_ECHO_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RFC 862 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">  EchoServer(muduo::net::EventLoop* loop, </span><br><span class="line">             <span class="keyword">const</span> muduo::net::InetAddress&amp; listenAddr);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onConnection</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr&amp; conn)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr&amp; conn, </span></span></span><br><span class="line"><span class="function"><span class="params">                 muduo::net::Buffer* buf, </span></span></span><br><span class="line"><span class="function"><span class="params">                 muduo::Timestamp time)</span></span>;</span><br><span class="line"></span><br><span class="line">  muduo::net::EventLoop* loop_; </span><br><span class="line">  muduo::net::TcpServer server_; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// MUDUO_EXAMPLES_SIMPLE_ECHO_ECHO_H</span></span></span><br></pre></td></tr></table></figure><p>在构造函数里注册回调函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">EchoServer::EchoServer(EventLoop* loop, </span><br><span class="line">                       <span class="keyword">const</span> InetAddress&amp; listenAddr) </span><br><span class="line">  : loop_(loop), </span><br><span class="line">    server_(loop, listenAddr, <span class="string">"EchoServer"</span>) &#123; </span><br><span class="line"></span><br><span class="line">    server_.setConnectionCallback(</span><br><span class="line">        boost::bind(&amp;EchoServer::onConnection, <span class="keyword">this</span>, _1)); </span><br><span class="line"></span><br><span class="line">    server_.setMessageCallback( </span><br><span class="line">        boost::bind(&amp;EchoServer::onMessage, <span class="keyword">this</span>, _1, _2, _3)); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EchoServer::start</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    server_.start(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>实现 EchoServer::onConnection() 和 EchoServer::onMessage()：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EchoServer::onConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn)</span> </span>&#123; </span><br><span class="line">    </span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">"EchoServer - "</span> &lt;&lt; conn-&gt;peerAddress().toHostPort() &lt;&lt; <span class="string">" -&gt; "</span> </span><br><span class="line">    &lt;&lt; conn-&gt;localAddress().toHostPort() &lt;&lt; <span class="string">" is "</span> </span><br><span class="line">    &lt;&lt; (conn-&gt;connected() ? <span class="string">"UP"</span> : <span class="string">"DOWN"</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EchoServer::onMessage</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn, </span></span></span><br><span class="line"><span class="function"><span class="params">                           Buffer* buf, </span></span></span><br><span class="line"><span class="function"><span class="params">                           Timestamp time)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">msg</span><span class="params">(buf-&gt;retrieveAsString())</span></span>; </span><br><span class="line">  LOG_INFO &lt;&lt; conn-&gt;name() &lt;&lt; <span class="string">" echo "</span> &lt;&lt; msg.size() &lt;&lt; <span class="string">" bytes at "</span> &lt;&lt; time.toString(); </span><br><span class="line"></span><br><span class="line">  conn-&gt;send(msg); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在 main() 里用 EventLoop 让整个程序跑起来：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"echo.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo; </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo::net;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">  LOG_INFO &lt;&lt; <span class="string">"pid = "</span> &lt;&lt; getpid(); </span><br><span class="line">  EventLoop loop; </span><br><span class="line">  <span class="function">InetAddress <span class="title">listenAddr</span><span class="params">(<span class="number">2007</span>)</span></span>; </span><br><span class="line">  <span class="function">EchoServer <span class="title">server</span><span class="params">(&amp;loop, listenAddr)</span></span>; </span><br><span class="line">  server.start(); </span><br><span class="line">  loop.loop(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的代码见 muduo/examples/simple/echo。</p><p>这个几十行的小程序实现了一个并发的 echo 服务程序，可以同时处理多个连接。</p><p>对这个程序的详细分析见下一篇博客《Muduo 网络编程示例之一：五个简单 TCP 协议》<br>————————————————<br>版权声明：本文为CSDN博主「陈硕」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/Solstice/article/details/6171831" target="_blank" rel="noopener">https://blog.csdn.net/Solstice/article/details/6171831</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文链接 &lt;a href=&quot;https://blog.csdn.net/Solstice/article/details/6171831&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/S
      
    
    </summary>
    
    
      <category term="开源组件" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/"/>
    
      <category term="muduo" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/"/>
    
    
      <category term="Cpp" scheme="http://yoursite.com/tags/Cpp/"/>
    
      <category term="Net" scheme="http://yoursite.com/tags/Net/"/>
    
  </entry>
  
  <entry>
    <title>以 boost 中的 function 和 bind 取代虚函数</title>
    <link href="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/%E4%BB%A5boost%E4%B8%AD%E7%9A%84function%E5%92%8Cbind%E5%8F%96%E4%BB%A3%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/%E4%BB%A5boost%E4%B8%AD%E7%9A%84function%E5%92%8Cbind%E5%8F%96%E4%BB%A3%E8%99%9A%E5%87%BD%E6%95%B0/</id>
    <published>2020-03-09T02:54:14.428Z</published>
    <updated>2020-03-09T02:54:59.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接： <a href="https://blog.csdn.net/Solstice/article/details/3066268" target="_blank" rel="noopener">https://blog.csdn.net/Solstice/article/details/3066268</a></p></blockquote><p>这是一篇比较情绪化的 blog，中心思想是“继承就像一条贼船，上去就下不来了”，而借助 <code>boost::function</code>和<code>boost::bind</code>，大多数情况下，你都不用上贼船。</p><p><code>boost::function</code> 和 <code>boost::bind</code> 已经纳入了 std::tr1，这或许是 C++0x 最值得期待的功能，它将彻底改变 C++ 库的设计方式，以及应用程序的编写方式。</p><p>Scott Meyers 的 Effective C++ 3rd ed.第35条款<strong>提到了以 <code>boost::function</code> 和 <code>boost:bind</code> 取代虚函数的做法</strong>，这里谈谈我自己使用的感受。</p><ul><li><a href="#1-%e5%9f%ba%e6%9c%ac%e7%94%a8%e9%80%94">1. 基本用途</a></li><li><a href="#2-%e5%af%b9%e7%a8%8b%e5%ba%8f%e5%ba%93%e7%9a%84%e5%bd%b1%e5%93%8d">2. 对程序库的影响</a><ul><li><a href="#%e4%be%8b1%e7%ba%bf%e7%a8%8b%e5%ba%93">例1：线程库</a><ul><li><a href="#%e5%b8%b8%e8%a7%84oo%e8%ae%be%e8%ae%a1">常规OO设计：</a></li><li><a href="#%e5%9f%ba%e4%ba%8eclosure%e7%9a%84%e8%ae%be%e8%ae%a1">基于closure的设计：</a></li></ul></li><li><a href="#%e4%be%8b2%e7%bd%91%e7%bb%9c%e5%ba%93">例2：网络库</a></li></ul></li><li><a href="#3-%e5%af%b9%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%e7%9a%84%e5%bd%b1%e5%93%8d">3. 对面向对象程序设计的影响</a></li><li><a href="#4-%e5%af%b9%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%e7%9a%84%e5%bd%b1%e5%93%8d">4. 对面向对象设计模式的影响</a></li><li><a href="#5-%e4%be%9d%e8%b5%96%e6%b3%a8%e5%85%a5%e4%b8%8e%e5%8d%95%e5%85%83%e6%b5%8b%e8%af%95">5. 依赖注入与单元测试</a></li><li><a href="#6-%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99%e4%bd%bf%e7%94%a8%e7%bb%a7%e6%89%bf">6. 什么时候使用继承？</a></li><li><a href="#7-%e5%9f%ba%e4%ba%8e%e6%8e%a5%e5%8f%a3%e7%9a%84%e8%ae%be%e8%ae%a1">7. 基于接口的设计</a></li><li><a href="#8-%e5%ae%9e%e7%8e%b0signalslot">8. 实现Signal/Slot</a></li></ul><h2 id="1-基本用途"><a href="#1-基本用途" class="headerlink" title="1. 基本用途"></a>1. 基本用途</h2><p><code>boost::function</code> 就像 C# 里的 <code>delegate</code>，可以指向任何函数，包括成员函数。当用 <code>bind</code> 把某个成员函数绑到某个对象上时，我们得到了一个closure（闭包）。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/function.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/bind.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Foo::methodA\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodInt</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Foo::methodInt\t"</span> &lt;&lt; a &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Bar::methodB\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    boost::function&lt;<span class="keyword">void</span>()&gt; f1; <span class="comment">// 无参数，无返回值</span></span><br><span class="line"></span><br><span class="line">    Foo foo;</span><br><span class="line">    f1 = boost::bind(&amp;Foo::methodA, &amp;foo);</span><br><span class="line">    f1(); <span class="comment">// 调用 foo.methodA();</span></span><br><span class="line"></span><br><span class="line">    Bar bar;</span><br><span class="line">    f1 = boost::bind(&amp;Bar::methodB, &amp;bar);</span><br><span class="line">    f1(); <span class="comment">// 调用 bar.methodB();</span></span><br><span class="line"></span><br><span class="line">    f1 = boost::bind(&amp;Foo::methodInt, &amp;foo, <span class="number">42</span>);</span><br><span class="line">    f1(); <span class="comment">// 调用 foo.methodInt(42);</span></span><br><span class="line"></span><br><span class="line">    boost::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)&gt; f2; <span class="comment">// int 参数，无返回值</span></span><br><span class="line">    f2 = boost::bind(&amp;Foo::methodInt, &amp;foo, _1);</span><br><span class="line">    f2(<span class="number">53</span>); <span class="comment">// 调用 foo.methodInt(53);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有 <code>boost::bind</code>，那么 <code>boost::function</code> 就什么都不是，而有了 <code>bind()</code>，“同一个类的不同对象可以 <code>delegate</code> 给不同的实现，从而实现不同的行为”（myan 语），简直就无敌了。</p><h2 id="2-对程序库的影响"><a href="#2-对程序库的影响" class="headerlink" title="2. 对程序库的影响"></a>2. 对程序库的影响</h2><p>程序库的设计不应该给使用者带来不必要的限制（耦合），<strong>而继承是仅次于最强的一种耦合（最强耦合的是友元）</strong>。如果一个程序库限制其使用者必须从某个class派生，那么我觉得这是一个糟糕的设计。不巧的是，目前有些程序库就是这么做的。</p><h3 id="例1：线程库"><a href="#例1：线程库" class="headerlink" title="例1：线程库"></a>例1：线程库</h3><h4 id="常规OO设计："><a href="#常规OO设计：" class="headerlink" title="常规OO设计："></a>常规OO设计：</h4><p>写一个 <code>Thread base class</code>，含有（纯）虚函数 <code>Thread#run()</code>，然后应用程序派生一个继承 <code>class</code>，覆写 <code>run()</code>。程序里的每一种线程对应一个 <code>Thread</code> 的派生类。例如 <code>Java</code> 的 <code>Thread</code> 可以这么用。</p><p>缺点：如果一个class的三个method需要在三个不同的线程中执行，就得写helper class(es)并玩一些OO把戏。</p><h4 id="基于closure的设计："><a href="#基于closure的设计：" class="headerlink" title="基于closure的设计："></a>基于closure的设计：</h4><p>令 <code>Thread</code> 是一个具体类，其构造函数接受 <code>Callable</code> 对象。应用程序只需提供一个 <code>Callable</code> 对象，创建一份<code>Thread</code> 实体，调用 <code>Thread#start()</code> 即可。<code>Java</code> 的 <code>Thread</code> 也可以这么用，传入一个 <code>Runnable</code> 对象。<code>C#</code> 的 <code>Thread</code> 只支持这一种用法，构造函数的参数是 <code>delegate ThreadStart</code>。<code>boost::thread</code> 也只支持这种用法。</p><p>一个基于 <code>closure</code> 的 <code>Thread class</code> 基本结构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/function.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/bind.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> boost::function&lt;<span class="keyword">void</span>()&gt; ThreadCallback;</span><br><span class="line"></span><br><span class="line">    Thread(ThreadCallback cb) : cb_(cb) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* some magic to call run() in new created thread */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cb_();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ThreadCallback cb_;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">runInThread</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Foo foo;</span><br><span class="line">    <span class="function">Thread <span class="title">thread</span><span class="params">(boost::bind(&amp;Foo::runInThread, &amp;foo))</span></span>;</span><br><span class="line"></span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例2：网络库"><a href="#例2：网络库" class="headerlink" title="例2：网络库"></a>例2：网络库</h3><p>以 <code>boost::function</code> 作为桥梁，<code>NetServer class</code> 对<strong>其使用者没有任何类型上的限制，只对成员函数的参数和返回类型有限制</strong>。使用者 <code>EchoService</code> 也完全不知道 <code>NetServer</code> 的存在，只要在 <code>main()</code> 里把两者装配到一起，程序就跑起来了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// library</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/noncopyable.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/function.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/bind.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Connection</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetServer</span> :</span> boost::noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> boost::function&lt;<span class="keyword">void</span>(Connection *)&gt; ConnectionCallback;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> boost::function&lt;<span class="keyword">void</span>(Connection *,</span><br><span class="line">                                 <span class="keyword">const</span> <span class="keyword">void</span> *, <span class="keyword">int</span> len)&gt; MessageCallback;</span><br><span class="line"></span><br><span class="line">    NetServer(<span class="keyword">uint16_t</span> port);</span><br><span class="line"></span><br><span class="line">    ~NetServer();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerConnectionCallback</span><span class="params">(<span class="keyword">const</span> ConnectionCallback &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerMessageCallback</span><span class="params">(<span class="keyword">const</span> MessageCallback &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(Connection *, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// user</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EchoService</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 符合NetServer::sendMessage的原型</span></span><br><span class="line">    <span class="keyword">typedef</span> boost::function&lt;<span class="keyword">void</span>(Connection *,</span><br><span class="line">                                 <span class="keyword">const</span> <span class="keyword">void</span> *, <span class="keyword">int</span>)&gt; SendMessageCallback;</span><br><span class="line"></span><br><span class="line">    EchoService(<span class="keyword">const</span> SendMessageCallback &amp;sendMsgCb) :</span><br><span class="line">            sendMessageCb_(sendMsgCb) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 符合NetServer::NetServer::MessageCallback的原型</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Connection *conn, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Received Msg from Connection %d: %.*s/n"</span>,</span><br><span class="line">               conn-&gt;id(), size, (<span class="keyword">const</span> <span class="keyword">char</span> *) buf);</span><br><span class="line">        sendMessageCb_(conn, buf, size); <span class="comment">// echo back</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 符合NetServer::NetServer::ConnectionCallback的原型</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onConnection</span><span class="params">(Connection *conn)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Connection from %s:%d is %s/n"</span>,</span><br><span class="line">               conn-&gt;ipAddr(), conn-&gt;port(),</span><br><span class="line">               conn-&gt;connected() ? <span class="string">"UP"</span> : <span class="string">"DOWN"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SendMessageCallback sendMessageCb_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扮演上帝的角色，把各部件拼起来</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">NetServer <span class="title">server</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line">    <span class="function">EchoService <span class="title">echo</span><span class="params">(bind(&amp;NetServer::sendMessage,</span></span></span><br><span class="line"><span class="function"><span class="params">            &amp;server, _1, _2, _3))</span></span>;</span><br><span class="line"></span><br><span class="line">    server.registerMessageCallback(</span><br><span class="line">            bind(&amp;EchoService::onMessage, &amp;echo, _1, _2, _3));</span><br><span class="line"></span><br><span class="line">    server.registerConnectionCallback(</span><br><span class="line">            bind(&amp;EchoService::onConnection, &amp;echo, _1));</span><br><span class="line"></span><br><span class="line">    server.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-对面向对象程序设计的影响"><a href="#3-对面向对象程序设计的影响" class="headerlink" title="3. 对面向对象程序设计的影响"></a>3. 对面向对象程序设计的影响</h2><p>一直以来，我对面向对象有一种厌恶感，叠床架屋，绕来绕去的，一拳拳打在棉花上，不解决实际问题。面向对象三要素是封装、继承和多态。我认为<strong>封装是根本的，继承和多态则是可有可无</strong>。用 <code>class</code> 来表示 <code>concept</code>，这是根本的；至于继承和多态，其耦合性太强，往往不划算。</p><p>继承和多态不仅规定了函数的名称、参数、返回类型，还规定了类的继承关系。在现代的 <code>OO</code> 编程语言里，借助反射和 <code>attribute/annotation</code>，已经大大放宽了限制。举例来说，<strong><code>JUnit 3.x</code> 是用反射，找出派生类里的名字符合 <code>void test*()</code> 的函数来执行</strong>，这里就没继承什么事，只是对函数的名称有部分限制（继承是全面限制，一字不差）。至于 <code>JUnit 4.x</code> 和 <code>NUnit 2.x</code> 则更进一步，以 <code>annoatation/attribute</code> 来标明 <code>test case</code>，更没继承什么事了。</p><p>我的猜测是，当初提出面向对象的时候，<code>closure</code> 还没有一个通用的实现，所以它没能算作基本的抽象工具之一。现在既然 <code>closure</code> 已经这么方便了，或许我们应该重新审视面向对象设计，至少不要那么滥用继承。</p><p>自从找到了 <code>boost::function+boost::bind</code> 这对神兵利器，不用再考虑类直接的继承关系，只需要基于对象的设计(<code>object-based</code>)，拳拳到肉，程序写起来顿时顺手了很多。</p><h2 id="4-对面向对象设计模式的影响"><a href="#4-对面向对象设计模式的影响" class="headerlink" title="4. 对面向对象设计模式的影响"></a>4. 对面向对象设计模式的影响</h2><p><strong>既然虚函数能用 <code>closure</code> 代替</strong>，那么很多 <code>OO</code> 设计模式，尤其是行为模式，失去了存在的必要。另外，既然没有继承体系，那么创建型模式似乎也没啥用了。</p><p><strong>最明显的是 <code>Strategy</code>，不用累赘的 <code>Strategy</code> 基类和<code>ConcreteStrategyA</code>、<code>ConcreteStrategyB</code> 等派生类，一个 <code>boost::function&lt;&gt;</code> 成员就解决问题</strong>。在《设计模式》这本书提到了23个模式，我认为 <code>iterator</code> 有用（或许再加个 <code>State</code>），其他都在摆谱，拉虚架子，没啥用。或许它们解决了面向对象中的常见问题，不过要是我的程序里连面向对象（指继承和多态）都不用，那似乎也不用叨扰面向对象设计模式了。</p><p>或许 <code>closure-based programming</code> 将作为一种新的 <code>programming paradiam</code> 而流行起来。</p><h2 id="5-依赖注入与单元测试"><a href="#5-依赖注入与单元测试" class="headerlink" title="5. 依赖注入与单元测试"></a>5. 依赖注入与单元测试</h2><p>前面的 <code>EchoService</code> 可算是依赖注入的例子，<code>EchoService</code> 需要一个什么东西来发送消息，它对这个“东西”的要求只是函数原型满足 <code>SendMessageCallback</code>，而并不关系数据到底发到网络上还是发到控制台。<strong>在正常使用的时候，数据应该发给网络，而在做单元测试的时候，数据应该发给某个 <code>DataSink</code></strong>。</p><p>安照面向对象的思路，先写一个 <code>AbstractDataSink interface</code>，包含 <code>sendMessage()</code> 这个虚函数，然后派生出两个 <code>classes</code>：<code>NetDataSink</code> 和 <code>MockDataSink</code>，前面那个干活用，后面那个单元测试用。<code>EchoService</code> 的构造函数应该以 <code>AbstractDataSink*</code> 为参数，这样就实现了所谓的接口与实现分离。</p><p>我认为这么做纯粹是脱了裤子放屁，直接传入一个 <code>SendMessageCallback</code> 对象就能解决问题。在单元测试的时候，可以 <code>boost::bind()</code> 到 <code>MockServer</code> 上，或某个全局函数上，完全不用继承和虚函数，也不会影响现有的设计。</p><h2 id="6-什么时候使用继承？"><a href="#6-什么时候使用继承？" class="headerlink" title="6. 什么时候使用继承？"></a>6. 什么时候使用继承？</h2><p>如果是指 <code>OO</code> 中的 <code>public</code> 继承，即为了接口与实现分离，那么我<strong>只会在派生类的数目和功能完全确定的情况下使用</strong>。换句话说，不为将来的扩展考虑，这时候面向对象或许是一种不错的描述方法。一旦要考虑扩展，什么办法都没用，还不如把程序写简单点，将来好大改或重写。</p><p>如果是功能继承，那么我会考虑继承 <code>boost::noncopyable</code> 或 <code>boost::enable_shared_from_this</code>，下一篇 blog 会讲到 <code>enable_shared_from_this</code> 在实现多线程安全的 <code>Signal/Slot</code> 时的妙用。</p><p>例如，<code>IO-Multiplex</code> 在不同的操作系统下有不同的推荐实现，最通用的 <code>select()</code>，<code>POSIX</code> 的 <code>poll()</code>，<code>Linux</code> 的 <code>epoll()</code>，<code>FreeBSD</code> 的 <code>kqueue</code> 等等，数目固定，功能也完全确定，不用考虑扩展。那么设计一个 <code>NetLoop base class</code> 加若干具体 <code>classes</code> 就是不错的解决办法。</p><h2 id="7-基于接口的设计"><a href="#7-基于接口的设计" class="headerlink" title="7. 基于接口的设计"></a>7. 基于接口的设计</h2><p>这个问题来自那个经典的讨论：不会飞的企鹅（Penguin）究竟应不应该继承自鸟（Bird），如果 Bird 定义了 virtual function fly() 的话。讨论的结果是，<strong>把具体的行为提出来，作为 <code>interface</code></strong>，比如 Flyable （能飞的），Runnable（能跑的），然后让企鹅实现 Runnable，麻雀实现 Flyable 和 Runnable。（其实麻雀只能双脚跳，不能跑，这里不作深究。）</p><p>进一步的讨论表明，<code>interface</code> 的粒度应足够小，或许包含一个 <code>method</code> 就够了，那么 <strong><code>interface</code> 实际上退化成了给类型打的标签(tag)</strong>。<strong>在这种情况下，完全可以使用boost::function来代替</strong>，比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/function.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/bind.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 企鹅能游泳，也能跑</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Penguin</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 麻雀能飞，也能跑</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sparrow</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以 closure 作为接口</span></span><br><span class="line"><span class="keyword">typedef</span> boost::function&lt;<span class="keyword">void</span>()&gt; FlyCallback;</span><br><span class="line"><span class="keyword">typedef</span> boost::function&lt;<span class="keyword">void</span>()&gt; RunCallback;</span><br><span class="line"><span class="keyword">typedef</span> boost::function&lt;<span class="keyword">void</span>()&gt; SwimCallback;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个既用到run，也用到fly的客户class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo(FlyCallback flyCb, RunCallback runCb) :</span><br><span class="line">            flyCb_(flyCb),</span><br><span class="line">            runCb_(runCb) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    FlyCallback flyCb_;</span><br><span class="line">    RunCallback runCb_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个既用到run，也用到swim的客户class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Bar(SwimCallback swimCb, RunCallback runCb) :</span><br><span class="line">            swimCb_(swimCb),</span><br><span class="line">            runCb_(runCb) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SwimCallback swimCb_;</span><br><span class="line">    RunCallback runCb_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Sparrow s;</span><br><span class="line">    Penguin p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 装配起来，Foo要麻雀，Bar要企鹅。</span></span><br><span class="line">    <span class="function">Foo <span class="title">foo</span><span class="params">(boost::bind(&amp;Sparrow::fly, &amp;s),</span></span></span><br><span class="line"><span class="function"><span class="params">            boost::bind(&amp;Sparrow::run, &amp;s))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Bar <span class="title">bar</span><span class="params">(boost::bind(&amp;Penguin::swim, &amp;p),</span></span></span><br><span class="line"><span class="function"><span class="params">            boost::bind(&amp;Penguin::run, &amp;p))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-实现Signal-Slot"><a href="#8-实现Signal-Slot" class="headerlink" title="8. 实现Signal/Slot"></a>8. 实现Signal/Slot</h2><p><code>boost::function</code> + <code>boost::bind</code> 描述了一对一的回调，在项目中，我们借助 <code>boost::shared_ptr</code> + <code>boost::weak_ptr</code> 简洁地实现了多播(multi-cast)，即一对多的回调，并且考虑了对象的生命期管理与多线程安全；并且，自然地，对使用者的类型不作任何限制，篇幅略长，留作下一篇blog吧。（<code>boost::signals</code> 也实现了 <code>Signal/Slot</code>，但可惜不是线程安全的。）</p><p>最后，向伟大的C语言致敬！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文链接： &lt;a href=&quot;https://blog.csdn.net/Solstice/article/details/3066268&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/
      
    
    </summary>
    
    
      <category term="开源组件" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/"/>
    
      <category term="muduo" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/"/>
    
    
      <category term="Cpp" scheme="http://yoursite.com/tags/Cpp/"/>
    
      <category term="Boost" scheme="http://yoursite.com/tags/Boost/"/>
    
  </entry>
  
</feed>
