{"meta":{"title":"Midudu's Home","subtitle":"","description":"Tech Blog","author":"Midudu","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"muduo 项目中的 CMakeLists","slug":"muduo项目中的CMakeLists","date":"2020-03-08T08:30:22.299Z","updated":"2020-03-08T08:30:23.000Z","comments":true,"path":"开源组件/muduo/muduo项目中的CMakeLists/","link":"","permalink":"http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84CMakeLists/","excerpt":"","text":"目录 base net test1 muduo base位置：muduo/muduo/base/CMakeLists.txt 这个目录下有一堆.cc文件和.h文件 1234567AsyncLogging.hAsyncLogging.ccAtomic.hBlockingQueue.hCountDownLatch.hCountDownLatch.cc... CMakeLists.txt 1234567891011121314151617181920212223242526272829303132333435# 所有的源文件 set 进 base_SRCS 这个变量set(base_SRCS AsyncLogging.cc Condition.cc CountDownLatch.cc CurrentThread.cc Date.cc Exception.cc FileUtil.cc LogFile.cc Logging.cc LogStream.cc ProcessInfo.cc Timestamp.cc Thread.cc ThreadPool.cc TimeZone.cc )# 将指定的源文件生成链接文件add_library(muduo_base $&#123;base_SRCS&#125;)# 将目标文件与库文件进行链接target_link_libraries(muduo_base pthread rt)COMPILE_FLAGS &quot;-std&#x3D;c++0x&quot;)install(TARGETS muduo_base DESTINATION lib)file(GLOB HEADERS &quot;*.h&quot;)install(FILES $&#123;HEADERS&#125; DESTINATION include&#x2F;muduo&#x2F;base)if(MUDUO_BUILD_EXAMPLES) add_subdirectory(tests)endif() net位置：muduo/muduo/net/CMakeLists.txt 当前目录下是一堆头文件和源文件 12345Acceptor.hAcceptor.ccBuffer.hBuffer.cc... CMakeLists.txt 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465include(CheckFunctionExists)check_function_exists(accept4 HAVE_ACCEPT4)if(NOT HAVE_ACCEPT4) set_source_files_properties(SocketsOps.cc PROPERTIES COMPILE_FLAGS &quot;-DNO_ACCEPT4&quot;)endif()set(net_SRCS Acceptor.cc Buffer.cc Channel.cc Connector.cc EventLoop.cc EventLoopThread.cc EventLoopThreadPool.cc InetAddress.cc Poller.cc poller&#x2F;DefaultPoller.cc poller&#x2F;EPollPoller.cc poller&#x2F;PollPoller.cc Socket.cc SocketsOps.cc TcpClient.cc TcpConnection.cc TcpServer.cc Timer.cc TimerQueue.cc )add_library(muduo_net $&#123;net_SRCS&#125;)target_link_libraries(muduo_net muduo_base)install(TARGETS muduo_net DESTINATION lib)set(HEADERS Buffer.h Callbacks.h Channel.h Endian.h EventLoop.h EventLoopThread.h EventLoopThreadPool.h InetAddress.h TcpClient.h TcpConnection.h TcpServer.h TimerId.h )install(FILES $&#123;HEADERS&#125; DESTINATION include&#x2F;muduo&#x2F;net)# 添加子目录 http 到 build 中. http 子目录中同样有头文件、源文件和 CMakeLists.txtadd_subdirectory(http)add_subdirectory(inspect)if(MUDUO_BUILD_EXAMPLES) add_subdirectory(tests)endif()if(PROTOBUF_FOUND) add_subdirectory(protobuf) add_subdirectory(protorpc)else() add_subdirectory(protobuf EXCLUDE_FROM_ALL) add_subdirectory(protorpc EXCLUDE_FROM_ALL)endif() test1位置：muduo/muduo/base/tests/CMakeLists.txt 这个目录下是各种 test 文件，包含了 123AsyncLogging_test.ccAtomic_unittest.cc... 这些 test 文件中包含了 main 方法，用多个 add_executable 编译成多个可执行文件 CMakeLists.txt 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586add_executable(asynclogging_test AsyncLogging_test.cc)target_link_libraries(asynclogging_test muduo_base)add_executable(atomic_unittest Atomic_unittest.cc)add_test(NAME atomic_unittest COMMAND atomic_unittest)# Add a test to the project to be run by __ctest__ commandadd_executable(blockingqueue_test BlockingQueue_test.cc)target_link_libraries(blockingqueue_test muduo_base)add_executable(blockingqueue_bench BlockingQueue_bench.cc)target_link_libraries(blockingqueue_bench muduo_base)add_executable(boundedblockingqueue_test BoundedBlockingQueue_test.cc)target_link_libraries(boundedblockingqueue_test muduo_base)add_executable(date_unittest Date_unittest.cc)target_link_libraries(date_unittest muduo_base)add_test(NAME date_unittest COMMAND date_unittest)add_executable(exception_test Exception_test.cc)target_link_libraries(exception_test muduo_base)add_test(NAME exception_test COMMAND exception_test)add_executable(fileutil_test FileUtil_test.cc)target_link_libraries(fileutil_test muduo_base)add_test(NAME fileutil_test COMMAND fileutil_test)add_executable(fork_test Fork_test.cc)target_link_libraries(fork_test muduo_base)if(ZLIB_FOUND) add_executable(gzipfile_test GzipFile_test.cc) target_link_libraries(gzipfile_test muduo_base z) add_test(NAME gzipfile_test COMMAND gzipfile_test)endif()add_executable(logfile_test LogFile_test.cc)target_link_libraries(logfile_test muduo_base)add_executable(logging_test Logging_test.cc)target_link_libraries(logging_test muduo_base)add_executable(logstream_bench LogStream_bench.cc)target_link_libraries(logstream_bench muduo_base)if(BOOSTTEST_LIBRARY)add_executable(logstream_test LogStream_test.cc)target_link_libraries(logstream_test muduo_base boost_unit_test_framework)add_test(NAME logstream_test COMMAND logstream_test)endif()add_executable(mutex_test Mutex_test.cc)target_link_libraries(mutex_test muduo_base)add_executable(processinfo_test ProcessInfo_test.cc)target_link_libraries(processinfo_test muduo_base)add_executable(singleton_test Singleton_test.cc)target_link_libraries(singleton_test muduo_base)add_executable(singleton_threadlocal_test SingletonThreadLocal_test.cc)target_link_libraries(singleton_threadlocal_test muduo_base)add_executable(thread_bench Thread_bench.cc)target_link_libraries(thread_bench muduo_base)add_executable(thread_test Thread_test.cc)target_link_libraries(thread_test muduo_base)add_executable(threadlocal_test ThreadLocal_test.cc)target_link_libraries(threadlocal_test muduo_base)add_executable(threadlocalsingleton_test ThreadLocalSingleton_test.cc)target_link_libraries(threadlocalsingleton_test muduo_base)add_executable(threadpool_test ThreadPool_test.cc)target_link_libraries(threadpool_test muduo_base)add_executable(timestamp_unittest Timestamp_unittest.cc)target_link_libraries(timestamp_unittest muduo_base)add_test(NAME timestamp_unittest COMMAND timestamp_unittest)add_executable(timezone_unittest TimeZone_unittest.cc)target_link_libraries(timezone_unittest muduo_base)add_test(NAME timezone_unittest COMMAND timezone_unittest) muduo位置：muduo/CMakeLists.txt 这个目录下有： 1234add_subdirectory(muduo&#x2F;base)add_subdirectory(muduo&#x2F;net)add_subdirectory(contrib)add_subdirectory(examples) CMakeLists.txt 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116cmake_minimum_required(VERSION 2.6)project(muduo C CXX)enable_testing()if(NOT CMAKE_BUILD_TYPE) set(CMAKE_BUILD_TYPE &quot;Release&quot;)endif()# only build examples if this is the main projectif(CMAKE_PROJECT_NAME STREQUAL &quot;muduo&quot;) option(MUDUO_BUILD_EXAMPLES &quot;Build Muduo examples&quot; ON)endif()set(CXX_FLAGS -g # -DVALGRIND -DCHECK_PTHREAD_RETURN_VALUE -D_FILE_OFFSET_BITS&#x3D;64 -Wall -Wextra -Werror -Wconversion -Wno-unused-parameter -Wold-style-cast -Woverloaded-virtual -Wpointer-arith -Wshadow -Wwrite-strings -march&#x3D;native # -MMD -std&#x3D;c++11 -rdynamic )if(CMAKE_BUILD_BITS EQUAL 32) list(APPEND CXX_FLAGS &quot;-m32&quot;)endif()if(CMAKE_CXX_COMPILER_ID STREQUAL &quot;Clang&quot;) list(APPEND CXX_FLAGS &quot;-Wno-null-dereference&quot;) list(APPEND CXX_FLAGS &quot;-Wno-sign-conversion&quot;) list(APPEND CXX_FLAGS &quot;-Wno-unused-local-typedef&quot;) list(APPEND CXX_FLAGS &quot;-Wthread-safety&quot;) list(REMOVE_ITEM CXX_FLAGS &quot;-rdynamic&quot;)endif()string(REPLACE &quot;;&quot; &quot; &quot; CMAKE_CXX_FLAGS &quot;$&#123;CXX_FLAGS&#125;&quot;)set(CMAKE_CXX_FLAGS_DEBUG &quot;-O0&quot;)set(CMAKE_CXX_FLAGS_RELEASE &quot;-O2 -DNDEBUG&quot;)set(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_BINARY_DIR&#125;&#x2F;bin)set(LIBRARY_OUTPUT_PATH $&#123;PROJECT_BINARY_DIR&#125;&#x2F;lib)find_package(Boost REQUIRED)find_package(Protobuf)find_package(CURL)find_package(ZLIB)find_path(CARES_INCLUDE_DIR ares.h)find_library(CARES_LIBRARY NAMES cares)find_path(MHD_INCLUDE_DIR microhttpd.h)find_library(MHD_LIBRARY NAMES microhttpd)find_library(BOOSTTEST_LIBRARY NAMES boost_unit_test_framework)find_library(BOOSTPO_LIBRARY NAMES boost_program_options)find_library(BOOSTSYSTEM_LIBRARY NAMES boost_system)find_path(TCMALLOC_INCLUDE_DIR gperftools&#x2F;heap-profiler.h)find_library(TCMALLOC_LIBRARY NAMES tcmalloc_and_profiler)find_path(HIREDIS_INCLUDE_DIR hiredis&#x2F;hiredis.h)find_library(HIREDIS_LIBRARY NAMES hiredis)find_path(GD_INCLUDE_DIR gd.h)find_library(GD_LIBRARY NAMES gd)find_program(THRIFT_COMPILER thrift)find_path(THRIFT_INCLUDE_DIR thrift)find_library(THRIFT_LIBRARY NAMES thrift)if(CARES_INCLUDE_DIR AND CARES_LIBRARY) message(STATUS &quot;found cares&quot;)endif()if(CURL_FOUND) message(STATUS &quot;found curl&quot;)endif()if(PROTOBUF_FOUND) message(STATUS &quot;found protobuf&quot;)endif()if(TCMALLOC_INCLUDE_DIR AND TCMALLOC_LIBRARY) message(STATUS &quot;found tcmalloc&quot;)endif()if(ZLIB_FOUND) message(STATUS &quot;found zlib&quot;)endif()if(HIREDIS_INCLUDE_DIR AND HIREDIS_LIBRARY) message(STATUS &quot;found hiredis&quot;)endif()if(GD_INCLUDE_DIR AND GD_LIBRARY) message(STATUS &quot;found gd&quot;)endif()if(THRIFT_COMPILER AND THRIFT_INCLUDE_DIR AND THRIFT_LIBRARY) message(STATUS &quot;found thrift&quot;)endif()include_directories($&#123;Boost_INCLUDE_DIRS&#125;)include_directories($&#123;PROJECT_SOURCE_DIR&#125;)string(TOUPPER $&#123;CMAKE_BUILD_TYPE&#125; BUILD_TYPE)message(STATUS &quot;CXX_FLAGS &#x3D; &quot; $&#123;CMAKE_CXX_FLAGS&#125; &quot; &quot; $&#123;CMAKE_CXX_FLAGS_$&#123;BUILD_TYPE&#125;&#125;)add_subdirectory(muduo&#x2F;base)add_subdirectory(muduo&#x2F;net)if(MUDUO_BUILD_EXAMPLES) add_subdirectory(contrib) add_subdirectory(examples)else() if(CARES_INCLUDE_DIR AND CARES_LIBRARY) add_subdirectory(examples&#x2F;cdns) endif()endif()","categories":[{"name":"开源组件","slug":"开源组件","permalink":"http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/"},{"name":"muduo","slug":"开源组件/muduo","permalink":"http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"http://yoursite.com/tags/Cpp/"},{"name":"CMake","slug":"CMake","permalink":"http://yoursite.com/tags/CMake/"}]},{"title":"发布一个基于 Reactor 模式的 C++ 网络库","slug":"发布一个基于 Reactor 模式的 C++ 网络库","date":"2020-03-08T08:21:03.674Z","updated":"2020-03-08T08:22:59.000Z","comments":true,"path":"开源组件/muduo/发布一个基于 Reactor 模式的 C++ 网络库/","link":"","permalink":"http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/%E5%8F%91%E5%B8%83%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8E%20Reactor%20%E6%A8%A1%E5%BC%8F%E7%9A%84%20C++%20%E7%BD%91%E7%BB%9C%E5%BA%93/","excerpt":"","text":"1来源 https:&#x2F;&#x2F;blog.csdn.net&#x2F;Solstice&#x2F;article&#x2F;details&#x2F;5848547 123陈硕 (giantchen_AT_gmail)Blog.csdn.net&#x2F;Solstice2010 Aug 30 本文主要介绍 muduo 网络库的使用。其设计与实现将有另文讲解。 目录 由来 下载与编译 例子 基本结构 公开接口 内部实现 线程模型 结语 由来半年前我写了一篇《学之者生，用之者死——ACE历史与简评》，其中提到“我心目中理想的网络库”的样子： 线程安全，支持多核多线程 不考虑可移植性，不跨平台，只支持 Linux，不支持 Windows。 在不增加复杂度的前提下可以支持 FreeBSD/Darwin，方便将来用 Mac 作为开发用机，但不为它做性能优化。也就是说 IO multiplexing 使用 poll 和 epoll。 主要支持 x86-64，兼顾 IA32 不支持 UDP，只支持 TCP 不支持 IPv6，只支持 IPv4 不考虑广域网应用，只考虑局域网 只支持一种使用模式：non-blocking IO + one event loop per thread，不考虑阻塞 IO API 简单易用，只暴露具体类和标准库里的类，不使用 - non-trivial templates，也不使用虚函数 只满足常用需求的 90%，不面面俱到，必要的时候以 app 来适应 lib 只做 library，不做成 framework 争取全部代码在 5000 行以内（不含测试） 以上条件都满足时，可以考虑搭配 Google Protocol Buffers RPC 在想清楚这些目标之后，我开始第三次尝试编写自己的 C++ 网络库。与前两次不同，这次我一开始就想好了库的名字，叫 muduo （木铎），并在 Google code 上创建了项目： http://code.google.com/p/muduo/ 。muduo 的主体内容在 5 月底已经基本完成，现在我把它开源。 本文主要介绍 muduo 网络库的使用，其设计与实现将有另文讲解。 下载与编译下载地址： http://muduo.googlecode.com/files/muduo-0.1.0-alpha.tar.gz SHA1 Checksum: 5d3642e311177ded89ed0d15c10921738f8c984c Muduo 使用了 Linux 较新的系统调用，要求 Linux 的内核版本大于 2.6.28 （我自己用的是 2.6.32 ）。在 Debian Squeeze / Ubuntu 10.04 LTS 上编译测试通过，32 位和 64 位系统都能使用。 Muduo 采用 CMake 为 build system，安装方法： $ sudo apt-get install cmake Muduo 依赖 Boost，很容易安装： $ sudo apt-get install libboost1.40-dev # 或 libboost1.42-dev 编译方法很简单： $ tar zxf muduo-0.1.0-alpha.tar.gz $ cd muduo/ $ ./build.sh 编译生成的可执行文件和静态库文件分别位于 ../build/debug/{bin,lib} 如果要编译 release 版，可执行 $ BUILD_TYPE=release ./build.sh 编译生成的可执行文件和静态库文件分别位于 ../build/release/{bin,lib} 编译完成之后请试运行其中的例子。比如 bin/inspector_test ，然后通过浏览器访问 http://10.0.0.10:12345/ 或 http://10.0.0.10:12345/proc/status，其中 10.0.0.10 替换为你的 Linux box 的 IP。 例子Muduo 附带了几十个小例子，位于 examples 目录。其中包括从 Boost.Asio、JBoss Netty、Python Twisted 等处移植过来的例子。 examples 12345678910111213141516171819202122232425262728293031323334353637|-- simple # 简单网络协议的实现| |-- allinone # 在一个程序里同时实现下面 5 个协议| |-- chargen # RFC 864，可测试带宽| |-- daytime # RFC 867| |-- discard # RFC 863| |-- echo # RFC 862| |-- time # RFC 868| &#96;-- timeclient # time 协议的客户端|-- hub # 一个简单的 pub&#x2F;sub&#x2F;hub 服务，演示应用级的广播|-- roundtrip # 测试两台机器的网络延时与时间差|-- asio # 从 Boost.Asio 移植的例子| |-- chat # 聊天服务| &#96;-- tutorial # 一系列 timers|-- netty # 从 JBoss Netty 移植的例子| |-- discard # 可用于测试带宽，服务器可多线程运行| |-- echo # 可用于测试带宽，服务器可多线程运行| &#96;-- uptime # TCP 长连接&#96;-- twisted # 从 Python Twisted 移植的例子 &#96;-- finger # finger01 ~ 07 基本结构Muduo 的目录结构如下。 1234567891011muduo|-- base # 与网络无关的基础代码，已提前发布&#96;-- net # 网络库 |-- http # 一个简单的可嵌入的 web 服务器 |-- inspect # 基于以上 web 服务器的“窥探器”，用于报告进程的状态 &#96;-- poller # poll(2) 和 epoll(4) 两种 IO multiplexing 后端 Muduo 是基于 Reactor 模式的网络库，其核心是个事件循环 EventLoop，用于响应计时器和 IO 事件。Muduo 采用基于对象（object based）而非面向对象（object oriented）的设计风格，其接口多以 boost::function + boost::bind 表达。 Muduo 的头文件明确分为客户可见和客户不可见两类。客户可见的为白底，客户不可见的为灰底。 这里简单介绍各个头文件及 class 的作用，详细的介绍留给以后的博客。 公开接口 Buffer 仿 Netty ChannelBuffer 的 buffer class，数据的读写通过 buffer 进行 InetAddress 封装 IPv4 地址 (end point)，注意，muduo 目前不能解析域名，只认 IP EventLoop 反应器 Reactor，用户可以注册计时器回调 EventLoopThread 启动一个线程，在其中运行 EventLoop::loop() TcpConnection 整个网络库的核心，封装一次 TCP 连接 TcpClient 用于编写网络客户端，能发起连接，并且有重试功能 TcpServer 用于编写网络服务器，接受客户的连接 在这些类中，TcpConnection 的生命期依靠 shared_ptr 控制（即用户和库共同控制）。Buffer 的生命期由 TcpConnection 控制。其余类的生命期由用户控制。 HttpServer 和 Inspector，暴露出一个 http 界面，用于监控进程的状态，类似于 Java JMX。这么做的原因是，《程序员修炼之道》第 6 章第 34 条提到“对于更大、更复杂的服务器代码，提供其操作的内部试图的一种漂亮技术是使用内建的 Web 服务器”，Jeff Dean 也说“（每个 Google 的服务器进程）Export HTML-based status pages for easy diagnosis”。 内部实现 Channel 是 selectable IO channel，负责注册与响应 IO 事件，它不拥有 file descriptor。它是 Acceptor、Connector、EventLoop、TimerQueue、TcpConnection 的成员，生命期由后者控制。 Socket 封装一个 file descriptor，并在析构时关闭 fd。它是 Acceptor、TcpConnection 的成员，生命期由后者控制。EventLoop、TimerQueue 也拥有 fd，但是不封装为 Socket。SocketsOps 封装各种 sockets 系统调用。 EventLoop 封装事件循环，也是事件分派的中心。它用 eventfd(2) 来异步唤醒，这有别于传统的用一对 pipe(2) 的办法。它用 TimerQueue 作为计时器管理，用 Poller 作为 IO Multiplexing。 Poller 是 PollPoller 和 EPollPoller 的基类，采用“电平触发”的语意。它是 EventLoop 的成员，生命期由后者控制。 PollPoller 和 EPollPoller 封装 poll(2) 和 epoll(4) 两种 IO Multiplexing 后端。Poll 的存在价值是便于调试，因为 poll(2) 调用是上下文无关的，用 strace 很容易知道库的行为是否正确。 Connector 用于发起 TCP 连接，它是 TcpClient 的成员，生命期由后者控制。 Acceptor 用于接受 TCP 连接，它是 TcpServer 的成员，生命期由后者控制。 TimerQueue 用 timerfd 实现定时，这有别于传统的设置 poll/epoll_wait 的等待时长的办法。为了简单起见，目前用链表来管理 Timer，如果有必要可改为优先队列，这样复杂度可从 O(n) 降为O(ln n) （某些操作甚至是 O(1)）。它是 EventLoop 的成员，生命期由后者控制。 EventLoopThreadPool 用于创建 IO 线程池，也就是说把 TcpConnection 分派到一组运行 EventLoop 的线程上。它是 TcpServer 的成员，生命期由后者控制。 类图 线程模型Muduo 的线程模型符合我主张的 one loop per thread + thread pool 模型。每个线程最多有一个 EventLoop。每个 TcpConnection 必须归某个 EventLoop 管理，所有的 IO 会转移到这个线程，换句话说一个 file descriptor 只能由一个线程读写。TcpConnection 所在的线程由其所属的 EventLoop 决定，这样我们可以很方便地把不同的 TCP 连接放到不同的线程去，也可以把一些 TCP 连接放到一个线程里。TcpConnection 和 EventLoop 是线程安全的，可以跨线程调用。TcpServer 直接支持多线程，它有两种模式： 单线程，accept 与 TcpConnection 用同一个线程做 IO。 多线程，accept 与 EventLoop 在同一个线程，另外创建一个 EventLoopThreadPool，新到的连接会按 round-robin 方式分配到线程池中。 结语Muduo 是我对常见网络编程任务的总结，用它我能很容易地编写多线程的 TCP 服务器和客户端。Muduo 是我业余时间的作品，代码估计还有很多 bug，功能也不完善（例如不支持 signal 处理），待日后慢慢改进吧。","categories":[{"name":"开源组件","slug":"开源组件","permalink":"http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/"},{"name":"muduo","slug":"开源组件/muduo","permalink":"http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/"}],"tags":[{"name":"Cpp","slug":"Cpp","permalink":"http://yoursite.com/tags/Cpp/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"IO","slug":"IO","permalink":"http://yoursite.com/tags/IO/"},{"name":"Reactor","slug":"Reactor","permalink":"http://yoursite.com/tags/Reactor/"}]}]}