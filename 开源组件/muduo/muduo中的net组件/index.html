
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>muduo 中的 net 组件 | Midudu&#39;s Home</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="类之间的耦合关系  最底层  Buffer：√  Socket：√  Timer：√  Channel ：和 EventLoop 相互耦合 √  第二层  TimerId ：依赖 Timer √  Poller ：依赖 Channel，和 EventLoop 相互耦合 √  Connector ：依赖 Channel，和 EventLoop 相互耦合 √  Acceptor ：依赖 Channe">
<meta property="og:type" content="article">
<meta property="og:title" content="muduo 中的 net 组件">
<meta property="og:url" content="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E4%B8%AD%E7%9A%84net%E7%BB%84%E4%BB%B6/index.html">
<meta property="og:site_name" content="Midudu&#39;s Home">
<meta property="og:description" content="类之间的耦合关系  最底层  Buffer：√  Socket：√  Timer：√  Channel ：和 EventLoop 相互耦合 √  第二层  TimerId ：依赖 Timer √  Poller ：依赖 Channel，和 EventLoop 相互耦合 √  Connector ：依赖 Channel，和 EventLoop 相互耦合 √  Acceptor ：依赖 Channe">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-03-09T02:57:01.062Z">
<meta property="article:modified_time" content="2020-03-09T02:57:36.000Z">
<meta property="article:author" content="Midudu">
<meta property="article:tag" content="Cpp">
<meta property="article:tag" content="Net">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="Midudu&#39;s Home" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
<link rel="stylesheet" href="/css/style.css">

  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
<meta name="generator" content="Hexo 4.2.0"></head>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Midudu&#39;s Home</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="yoursite.com">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main"><article id="post-muduo中的net组件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E4%B8%AD%E7%9A%84net%E7%BB%84%E4%BB%B6/" class="article-date">
  <time datetime="2020-03-09T02:57:01.062Z" itemprop="datePublished">2020-03-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/">开源组件</a>►<a class="article-category-link" href="/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/">muduo</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      muduo 中的 net 组件
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><p>类之间的耦合关系</p>
<ol>
<li><p>最底层</p>
<p> Buffer：√</p>
<p> Socket：√</p>
<p> Timer：√</p>
<p> Channel ：和 EventLoop 相互耦合 √</p>
</li>
<li><p>第二层</p>
<p> TimerId ：依赖 Timer √</p>
<p> Poller ：依赖 Channel，和 EventLoop 相互耦合 √</p>
<p> Connector ：依赖 Channel，和 EventLoop 相互耦合 √</p>
<p> Acceptor ：依赖 Channel 和 Socket，和 EventLoop 相互耦合 √</p>
<p> TimerQueue ：依赖 Timer 和 Channel，和 EventLoop 相互耦合 √</p>
</li>
<li><p>第三层</p>
<p> EventLoop ：和 Channel、Poller 和 TimerQueue 相互耦合 √</p>
</li>
<li><p>第四层</p>
<p> EventLoopThread ：依赖 EventLoop √</p>
<p> TcpConnection ：依赖 EventLoop、Socket、Channel 和 Buffer √</p>
</li>
<li><p>第五层</p>
<p> EventLoopThreadPool ：依赖 EventLoopThread √</p>
<p> TcpServer ：依赖 EventLoop、Acceptor、EventLoopThread 和 TcpConnection √</p>
<p> TcpClient ：依赖 EventLoop 、 Connector 和 TcpConnection √</p>
</li>
</ol>
</li>
</ol>
<ul>
<li><a href="#%e6%9c%80%e5%ba%95%e5%b1%82">最底层</a><ul>
<li><a href="#1-buffer">1. Buffer</a></li>
<li><a href="#2-socket">2. Socket</a></li>
<li><a href="#3-timer">3. Timer</a></li>
<li><a href="#4-channel">4. Channel</a></li>
</ul>
</li>
<li><a href="#%e7%ac%ac%e4%ba%8c%e5%b1%82">第二层</a><ul>
<li><a href="#1-timerid">1. TimerId</a></li>
<li><a href="#2-poller">2. Poller</a></li>
<li><a href="#3-acceptor">3. Acceptor</a></li>
<li><a href="#4-timerqueue">4. TimerQueue</a></li>
<li><a href="#5-connector">5. Connector</a></li>
</ul>
</li>
<li><a href="#%e7%ac%ac%e4%b8%89%e5%b1%82">第三层</a><ul>
<li><a href="#1-eventloop">1. EventLoop</a></li>
</ul>
</li>
<li><a href="#%e7%ac%ac%e5%9b%9b%e5%b1%82">第四层</a><ul>
<li><a href="#1-eventloopthread">1. EventLoopThread</a></li>
<li><a href="#2-tcpconnection">2. TcpConnection</a></li>
</ul>
</li>
<li><a href="#%e7%ac%ac%e4%ba%94%e5%b1%82">第五层</a><ul>
<li><a href="#1-eventloopthreadpool">1. EventLoopThreadPool</a></li>
<li><a href="#2-tcpserver">2. TcpServer</a></li>
<li><a href="#3-tcpclient">3. TcpClient</a></li>
</ul>
</li>
</ul>
<h2 id="最底层"><a href="#最底层" class="headerlink" title="最底层"></a>最底层</h2><h3 id="1-Buffer"><a href="#1-Buffer" class="headerlink" title="1. Buffer"></a>1. Buffer</h3><p>见 “./5_Buffer类的设计.md”</p>
<h3 id="2-Socket"><a href="#2-Socket" class="headerlink" title="2. Socket"></a>2. Socket</h3><p>socket_fd 的 wrapper，目标是提供了几种 Socket 的封装，例如 listen、bind 等。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">InetAddress</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Socket</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="keyword">explicit</span> <span class="title">Socket</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span></span><br><span class="line"><span class="function">                    : <span class="title">sockfd_</span><span class="params">(sockfd)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">bindAddress</span><span class="params">(<span class="keyword">const</span> InetAddress &amp;localaddr)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(InetAddress *peeraddr)</span></span>;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> sockfd_;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<h3 id="3-Timer"><a href="#3-Timer" class="headerlink" title="3. Timer"></a>3. Timer</h3><p>用于时间事件的内部类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Timer</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            Timer(TimerCallback cb, Timestamp when, <span class="keyword">double</span> interval)</span><br><span class="line">                    : callback_(<span class="built_in">std</span>::move(cb)),</span><br><span class="line">                      expiration_(when),</span><br><span class="line">                      interval_(interval),</span><br><span class="line">                      repeat_(interval &gt; <span class="number">0.0</span>),</span><br><span class="line">                      sequence_(s_numCreated_.incrementAndGet()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">                callback_();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">restart</span><span class="params">(Timestamp now)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (repeat_) &#123;</span><br><span class="line">                    expiration_ = addTime(now, interval_);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    expiration_ = Timestamp::invalid();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">Timestamp <span class="title">expiration</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">            <span class="function"><span class="keyword">bool</span> <span class="title">repeat</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">            <span class="function"><span class="keyword">int64_t</span> <span class="title">sequence</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">            <span class="function"><span class="keyword">static</span> <span class="keyword">int64_t</span> <span class="title">numCreated</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="keyword">const</span> TimerCallback callback_;</span><br><span class="line">            Timestamp expiration_;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">double</span> interval_;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">bool</span> repeat_;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int64_t</span> sequence_;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">static</span> AtomicInt64 s_numCreated_;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<h3 id="4-Channel"><a href="#4-Channel" class="headerlink" title="4. Channel"></a>4. Channel</h3><p>用于注册与响应 IO 事件</p>
<ol>
<li>构造函数中和一个 EventLoop 绑定、和一个文件描述符 fd 绑定</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">EventLoop</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Channel</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            Channel(EventLoop *loop, <span class="keyword">int</span> fd);</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>IO 事件类型分为两种：ReadEventCallback 和 EventCallback；有四种回调函数类型：readCallback_、writeCallback_、closeCallback_ 和 errorCallback_，可以通过 setXXX 函数来注册（注意 std::move() 将左值转化为了右值引用以减少拷贝次数）</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Channel</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; EventCallback;</span><br><span class="line">            <span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(Timestamp)&gt; ReadEventCallback;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">setReadCallback</span><span class="params">(ReadEventCallback cb)</span> </span>&#123; readCallback_ = <span class="built_in">std</span>::move(cb); &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">setWriteCallback</span><span class="params">(EventCallback cb)</span> </span>&#123; writeCallback_ = <span class="built_in">std</span>::move(cb); &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">setCloseCallback</span><span class="params">(EventCallback cb)</span> </span>&#123; closeCallback_ = <span class="built_in">std</span>::move(cb); &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">setErrorCallback</span><span class="params">(EventCallback cb)</span> </span>&#123; errorCallback_ = <span class="built_in">std</span>::move(cb); &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            ReadEventCallback readCallback_;</span><br><span class="line">            EventCallback writeCallback_;</span><br><span class="line">            EventCallback closeCallback_;</span><br><span class="line">            EventCallback errorCallback_;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>设置事件读写能力，通过对 events_ 变量设置掩码完成，并且通知绑定的 EventLoop update</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Channel</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">enableReading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                events_ |= kReadEvent;</span><br><span class="line">                update();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">disableReading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                events_ &amp;= ~kReadEvent;</span><br><span class="line">                update();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">enableWriting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                events_ |= kWriteEvent;</span><br><span class="line">                update();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">disableWriting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                events_ &amp;= ~kWriteEvent;</span><br><span class="line">                update();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">disableAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                events_ = kNoneEvent;</span><br><span class="line">                update();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kNoneEvent = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kReadEvent = POLLIN | POLLPRI;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kWriteEvent = POLLOUT;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> events_;</span><br><span class="line"></span><br><span class="line">            update() &#123;</span><br><span class="line">                addedToLoop_ = <span class="literal">true</span>;</span><br><span class="line">                loop_-&gt;updateChannel(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>处理事件</p>
<p> revents_ 变量由 Poller 设置，表征事件的类型；处理事件时根据事件类型，调用注册好的几种回调函数</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Channel::handleEventWithGuard</span><span class="params">(Timestamp receiveTime)</span> </span>&#123;</span><br><span class="line">    eventHandling_ = <span class="literal">true</span>;</span><br><span class="line">    LOG_TRACE &lt;&lt; reventsToString();</span><br><span class="line">    <span class="keyword">if</span> ((revents_ &amp; POLLHUP) &amp;&amp; !(revents_ &amp; POLLIN)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logHup_) &#123;</span><br><span class="line">            LOG_WARN &lt;&lt; <span class="string">"fd = "</span> &lt;&lt; fd_ &lt;&lt; <span class="string">" Channel::handle_event() POLLHUP"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (closeCallback_) &#123;</span><br><span class="line">            closeCallback_();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (revents_ &amp; POLLNVAL) &#123;</span><br><span class="line">        LOG_WARN &lt;&lt; <span class="string">"fd = "</span> &lt;&lt; fd_ &lt;&lt; <span class="string">" Channel::handle_event() POLLNVAL"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (revents_ &amp; (POLLERR | POLLNVAL)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errorCallback_) &#123;</span><br><span class="line">            errorCallback_();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (revents_ &amp; (POLLIN | POLLPRI | POLLRDHUP)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (readCallback_) &#123;</span><br><span class="line">            readCallback_(receiveTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (revents_ &amp; POLLOUT) &#123;</span><br><span class="line">        <span class="keyword">if</span> (writeCallback_) &#123;</span><br><span class="line">            writeCallback_();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    eventHandling_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第二层"><a href="#第二层" class="headerlink" title="第二层"></a>第二层</h2><h3 id="1-TimerId"><a href="#1-TimerId" class="headerlink" title="1. TimerId"></a>1. TimerId</h3><p>用于取消 Timer</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Timer</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">TimerId</span> :</span> <span class="keyword">public</span> muduo::copyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            TimerId()</span><br><span class="line">                    : timer_(<span class="literal">NULL</span>),</span><br><span class="line">                      sequence_(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">            TimerId(Timer *timer, <span class="keyword">int64_t</span> seq)</span><br><span class="line">                    : timer_(timer),</span><br><span class="line">                      sequence_(seq) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// default copy-ctor, dtor and assignment are okay</span></span><br><span class="line">            <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerQueue</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            Timer *timer_;</span><br><span class="line">            <span class="keyword">int64_t</span> sequence_;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<h3 id="2-Poller"><a href="#2-Poller" class="headerlink" title="2. Poller"></a>2. Poller</h3><ol>
<li><p>IO 多路复用的虚基类，和一个 EventLoop 对象绑定，poll 方法必须在 loop 线程中调用。</p>
</li>
<li><p>一个 Poller 对象中可以包含多个 Channel，代表多个 IO 事件</p>
</li>
<li><p>有两个实现类：PollPoller 底层使用 poll；EPollPoller 底层使用 epoll</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Channel</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Poller</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Channel *&gt; ChannelList;</span><br><span class="line"></span><br><span class="line">            Poller(EventLoop *loop);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">virtual</span> ~Poller();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// Polls the I/O events.</span></span><br><span class="line">            <span class="comment">/// Must be called in the loop thread.</span></span><br><span class="line">            <span class="function"><span class="keyword">virtual</span> Timestamp <span class="title">poll</span><span class="params">(<span class="keyword">int</span> timeoutMs, ChannelList *activeChannels)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// Changes the interested I/O events.</span></span><br><span class="line">            <span class="comment">/// Must be called in the loop thread.</span></span><br><span class="line">            <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">updateChannel</span><span class="params">(Channel *channel)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// Remove the channel, when it destructs.</span></span><br><span class="line">            <span class="comment">/// Must be called in the loop thread.</span></span><br><span class="line">            <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">removeChannel</span><span class="params">(Channel *channel)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hasChannel</span><span class="params">(Channel *channel)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">static</span> Poller *<span class="title">newDefaultPoller</span><span class="params">(EventLoop *loop)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">assertInLoopThread</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">                ownerLoop_-&gt;assertInLoopThread();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span>:</span><br><span class="line">            <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, Channel *&gt; ChannelMap;</span><br><span class="line">            ChannelMap channels_;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            EventLoop *ownerLoop_;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<h3 id="3-Acceptor"><a href="#3-Acceptor" class="headerlink" title="3. Acceptor"></a>3. Acceptor</h3><p>用于接受 TCP 连接</p>
<ol>
<li>构造函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Acceptor</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            Acceptor(EventLoop *loop, <span class="keyword">const</span> InetAddress &amp;listenAddr, <span class="keyword">bool</span> reuseport) : </span><br><span class="line">                loop_(loop), </span><br><span class="line">                acceptSocket_(sockets::createNonblockingOrDie(listenAddr.family())),</span><br><span class="line">                acceptChannel_(loop, acceptSocket_.fd()),</span><br><span class="line">                listenning_(<span class="literal">false</span>),</span><br><span class="line">                idleFd_(::open(<span class="string">"/dev/null"</span>, O_RDONLY | O_CLOEXEC)) &#123;</span><br><span class="line"></span><br><span class="line">                assert(idleFd_ &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                acceptSocket_.setReuseAddr(<span class="literal">true</span>);</span><br><span class="line">                acceptSocket_.setReusePort(reuseport);</span><br><span class="line">                acceptSocket_.bindAddress(listenAddr);</span><br><span class="line">                acceptChannel_.setReadCallback(</span><br><span class="line">                <span class="built_in">std</span>::bind(&amp;Acceptor::handleRead, <span class="keyword">this</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            EventLoop *loop_;</span><br><span class="line">            Socket acceptSocket_;</span><br><span class="line">            Channel acceptChannel_;</span><br><span class="line">            NewConnectionCallback newConnectionCallback_;</span><br><span class="line">            <span class="keyword">bool</span> listenning_;</span><br><span class="line">            <span class="keyword">int</span> idleFd_;    </span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<p>每个 Acceptor 和一个 EventLoop 绑定，并且传入一个 InetAddress 对象用于构造 Socket 监听的端口。</p>
<p>在构造函数中，acceptSocket_ 对象初始化好，acceptChannel_ 也初始化好，并且注册 Read 事件的 CallBack 为 Acceptor::handleRead。</p>
<p>Acceptor::handleRead 的代码是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Acceptor::handleRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    InetAddress peerAddr;</span><br><span class="line">    <span class="comment">//FIXME loop until no more</span></span><br><span class="line">    <span class="keyword">int</span> connfd = acceptSocket_.accept(&amp;peerAddr);</span><br><span class="line">    <span class="keyword">if</span> (connfd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// string hostport = peerAddr.toIpPort();</span></span><br><span class="line">        <span class="comment">// LOG_TRACE &lt;&lt; "Accepts of " &lt;&lt; hostport;</span></span><br><span class="line">        <span class="keyword">if</span> (newConnectionCallback_) &#123;</span><br><span class="line">            newConnectionCallback_(connfd, peerAddr);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sockets::close(connfd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOG_SYSERR &lt;&lt; <span class="string">"in Acceptor::handleRead"</span>;</span><br><span class="line">        <span class="comment">// Read the section named "The special problem of</span></span><br><span class="line">        <span class="comment">// accept()ing when you can't" in libev's doc.</span></span><br><span class="line">        <span class="comment">// By Marc Lehmann, author of libev.</span></span><br><span class="line">        <span class="keyword">if</span> (errno == EMFILE) &#123;</span><br><span class="line">            ::close(idleFd_);</span><br><span class="line">            idleFd_ = ::accept(acceptSocket_.fd(), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">            ::close(idleFd_);</span><br><span class="line">            idleFd_ = ::open(<span class="string">"/dev/null"</span>, O_RDONLY | O_CLOEXEC);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，一旦 acceptChannel_ 产生了 read 事件，它就会调用 Acceptor 注册好的 newConnectionCallback_ 回调函数。</p>
<ol start="2">
<li>listen</li>
</ol>
<p>让 acceptSocket_ 开始 listen 某个端口（这个不是阻塞的），然后打开 acceptChannel_ 的读事件能力。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Acceptor::listen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    listenning_ = <span class="literal">true</span>;</span><br><span class="line">    acceptSocket_.listen();</span><br><span class="line">    acceptChannel_.enableReading();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-TimerQueue"><a href="#4-TimerQueue" class="headerlink" title="4. TimerQueue"></a>4. TimerQueue</h3><p>一个 Timer 队列，用于管理定时事件</p>
<ol>
<li>构造函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">TimerQueue</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="keyword">explicit</span> <span class="title">TimerQueue</span><span class="params">(EventLoop *loop)</span>: </span></span><br><span class="line">                loop_(loop),</span><br><span class="line">                timerfd_(createTimerfd()),</span><br><span class="line">                timerfdChannel_(loop, timerfd_),</span><br><span class="line">                timers_(),</span><br><span class="line">                callingExpiredTimers_(<span class="literal">false</span>) &#123;</span><br><span class="line"></span><br><span class="line">                timerfdChannel_.setReadCallback(<span class="built_in">std</span>::bind(&amp;TimerQueue::handleRead, <span class="keyword">this</span>));</span><br><span class="line">    </span><br><span class="line">                timerfdChannel_.enableReading();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">typedef</span> <span class="built_in">std</span>::pair&lt;Timestamp, Timer *&gt; Entry;</span><br><span class="line">            <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">set</span>&lt;Entry&gt; TimerList;</span><br><span class="line"></span><br><span class="line">            EventLoop *loop_;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> timerfd_;</span><br><span class="line">            Channel timerfdChannel_;</span><br><span class="line">            <span class="comment">// Timer list sorted by expiration</span></span><br><span class="line">            TimerList timers_;</span><br><span class="line">            <span class="keyword">bool</span> callingExpiredTimers_; <span class="comment">/* atomic */</span></span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<p>在构造函数中，首先将一个 TimerQueue 和一个 EventLoop 绑定，然后创建一个 timer 的 fd，然后用这个 fd 构造一个 timerfdChannel_。这个 timerfdChannel_ 会设置一个 Read 事件的 CallBack 回调函数，看一下这个回调函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TimerQueue::handleRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    <span class="function">Timestamp <span class="title">now</span><span class="params">(Timestamp::now())</span></span>;</span><br><span class="line">    readTimerfd(timerfd_, now);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Entry&gt; expired = getExpired(now);</span><br><span class="line"></span><br><span class="line">    callingExpiredTimers_ = <span class="literal">true</span>;</span><br><span class="line">    cancelingTimers_.clear();</span><br><span class="line">    <span class="comment">// safe to callback outside critical section</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> Entry &amp;it : expired) &#123;</span><br><span class="line">        it.second-&gt;run();</span><br><span class="line">    &#125;</span><br><span class="line">    callingExpiredTimers_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    reset(expired, now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个回调函数的大致原理是：如果 timerfdChannel_ 变得可读，说明有时间事件到达了；此时找一下过期的 timer 们，执行一下 timer 的 callback 函数</p>
<ol start="2">
<li>addTimer</li>
</ol>
<p>添加一个 Timer。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">TimerQueue</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function">TimerId <span class="title">addTimer</span><span class="params">(TimerCallback cb, Timestamp when, <span class="keyword">double</span> interval)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                Timer *timer = <span class="keyword">new</span> Timer(<span class="built_in">std</span>::move(cb), when, interval);</span><br><span class="line">    </span><br><span class="line">                loop_-&gt;runInLoop(<span class="built_in">std</span>::bind(&amp;TimerQueue::addTimerInLoop, <span class="keyword">this</span>, timer));</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> TimerId(timer, timer-&gt;sequence());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<p>具体方式是先 new 一个 Timer 对象，然后向绑定的 EventLoop 对象添加。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::runInLoop</span><span class="params">(Functor cb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isInLoopThread()) &#123;</span><br><span class="line">        cb();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        queueInLoop(<span class="built_in">std</span>::move(cb));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EventLoop 要么直接执行，要么稍后执行（对于添加 Timer 这个行为，很可能发生在其他线程），但是无论如何最终都会执行 addTimerInLoop 方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TimerQueue::addTimerInLoop</span><span class="params">(Timer *timer)</span> </span>&#123;</span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    <span class="keyword">bool</span> earliestChanged = insert(timer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (earliestChanged) &#123;</span><br><span class="line">        resetTimerfd(timerfd_, timer-&gt;expiration());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>细节没有关注，整体思路就是更新 timer 列表</p>
<ol start="3">
<li>cancel</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">TimerQueue</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">(TimerId timerId)</span> </span>&#123;</span><br><span class="line">                loop_-&gt;runInLoop(<span class="built_in">std</span>::bind(&amp;TimerQueue::cancelInLoop, <span class="keyword">this</span>, timerId));</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<p>和 addTimer 一样，最终也是到 EventLoop 中执行，接下来看 cancelInLoop</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TimerQueue::cancelInLoop</span><span class="params">(TimerId timerId)</span> </span>&#123;</span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    assert(timers_.size() == activeTimers_.size());</span><br><span class="line">    <span class="function">ActiveTimer <span class="title">timer</span><span class="params">(timerId.timer_, timerId.sequence_)</span></span>;</span><br><span class="line">    ActiveTimerSet::iterator it = activeTimers_.find(timer);</span><br><span class="line">    <span class="keyword">if</span> (it != activeTimers_.end()) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> n = timers_.erase(Entry(it-&gt;first-&gt;expiration(), it-&gt;first));</span><br><span class="line">        assert(n == <span class="number">1</span>);</span><br><span class="line">        (<span class="keyword">void</span>) n;</span><br><span class="line">        <span class="keyword">delete</span> it-&gt;first; <span class="comment">// <span class="doctag">FIXME:</span> no delete please</span></span><br><span class="line">        activeTimers_.erase(it);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (callingExpiredTimers_) &#123;</span><br><span class="line">        cancelingTimers_.insert(timer);</span><br><span class="line">    &#125;</span><br><span class="line">    assert(timers_.size() == activeTimers_.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本思路也是更新 TimerQueue 中的 Timer 列表</p>
<h3 id="5-Connector"><a href="#5-Connector" class="headerlink" title="5. Connector"></a>5. Connector</h3><p>属于 TcpClient 的底层组件，用于发起 TCP 连接，它是 TcpClient 的成员，生命期由后者控制。</p>
<ol>
<li>构造函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Connector</span> :</span> noncopyable,</span><br><span class="line">                          <span class="keyword">public</span> <span class="built_in">std</span>::enable_shared_from_this&lt;Connector&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            Connector(EventLoop *loop, <span class="keyword">const</span> InetAddress &amp;serverAddr) : </span><br><span class="line">                loop_(loop),</span><br><span class="line">                serverAddr_(serverAddr),</span><br><span class="line">                connect_(<span class="literal">false</span>),</span><br><span class="line">                state_(kDisconnected),</span><br><span class="line">                retryDelayMs_(kInitRetryDelayMs) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kInitRetryDelayMs = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">            EventLoop *loop_;</span><br><span class="line">            InetAddress serverAddr_;</span><br><span class="line">            <span class="keyword">bool</span> connect_; <span class="comment">// atomic</span></span><br><span class="line">            States state_;  <span class="comment">// <span class="doctag">FIXME:</span> use atomic variable</span></span><br><span class="line">            <span class="keyword">int</span> retryDelayMs_;</span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<p>绑定一个 EventLoop，指定一下 server 的地址和端口</p>
<ol start="2">
<li>start</li>
</ol>
<p>可以在任何线程中调用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Connector::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    connect_ = <span class="literal">true</span>;</span><br><span class="line">    loop_-&gt;runInLoop(<span class="built_in">std</span>::bind(&amp;Connector::startInLoop, <span class="keyword">this</span>)); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Connector::startInLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    assert(state_ == kDisconnected);</span><br><span class="line">    <span class="keyword">if</span> (connect_) &#123;</span><br><span class="line">        connect();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOG_DEBUG &lt;&lt; <span class="string">"do not connect"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Connector::connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = sockets::createNonblockingOrDie(serverAddr_.family());</span><br><span class="line">    <span class="keyword">int</span> ret = sockets::connect(sockfd, serverAddr_.getSockAddr());</span><br><span class="line">    <span class="keyword">int</span> savedErrno = (ret == <span class="number">0</span>) ? <span class="number">0</span> : errno;</span><br><span class="line">    <span class="keyword">switch</span> (savedErrno) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">case</span> EINPROGRESS:</span><br><span class="line">        <span class="keyword">case</span> EINTR:</span><br><span class="line">        <span class="keyword">case</span> EISCONN:</span><br><span class="line">            connecting(sockfd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EAGAIN:</span><br><span class="line">        <span class="keyword">case</span> EADDRINUSE:</span><br><span class="line">        <span class="keyword">case</span> EADDRNOTAVAIL:</span><br><span class="line">        <span class="keyword">case</span> ECONNREFUSED:</span><br><span class="line">        <span class="keyword">case</span> ENETUNREACH:</span><br><span class="line">            retry(sockfd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EACCES:</span><br><span class="line">        <span class="keyword">case</span> EPERM:</span><br><span class="line">        <span class="keyword">case</span> EAFNOSUPPORT:</span><br><span class="line">        <span class="keyword">case</span> EALREADY:</span><br><span class="line">        <span class="keyword">case</span> EBADF:</span><br><span class="line">        <span class="keyword">case</span> EFAULT:</span><br><span class="line">        <span class="keyword">case</span> ENOTSOCK:</span><br><span class="line">            LOG_SYSERR &lt;&lt; <span class="string">"connect error in Connector::startInLoop "</span> &lt;&lt; savedErrno;</span><br><span class="line">            sockets::close(sockfd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            LOG_SYSERR &lt;&lt; <span class="string">"Unexpected error in Connector::startInLoop "</span> &lt;&lt; savedErrno;</span><br><span class="line">            sockets::close(sockfd);</span><br><span class="line">            <span class="comment">// connectErrorCallback_();</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>start 方法从客户端开启一个 TCP 连接。基本做法是把 connect 放在 EventLoop 中执行，最终会开启 socket::connect</p>
<p>在 connect 方法中有很多种情况，最终归结为 3 大类：connecting、retry 和 close，close 就是 socket::close 就行了，重点看一下前两个。</p>
<p>先看 retry，retry 的操作是先把原来的 sockfd close 掉，然后设一个定时任务 runAfter，而这个延时时延每次翻倍，直到到达最大阈值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Connector::retry</span><span class="params">(<span class="keyword">int</span> sockfd)</span> </span>&#123;</span><br><span class="line">    sockets::close(sockfd);</span><br><span class="line">    setState(kDisconnected);</span><br><span class="line">    <span class="keyword">if</span> (connect_) &#123;</span><br><span class="line">        LOG_INFO &lt;&lt; <span class="string">"Connector::retry - Retry connecting to "</span> &lt;&lt; serverAddr_.toIpPort()</span><br><span class="line">                 &lt;&lt; <span class="string">" in "</span> &lt;&lt; retryDelayMs_ &lt;&lt; <span class="string">" milliseconds. "</span>;</span><br><span class="line">        loop_-&gt;runAfter(retryDelayMs_ / <span class="number">1000.0</span>,</span><br><span class="line">                        <span class="built_in">std</span>::bind(&amp;Connector::startInLoop, shared_from_this()));</span><br><span class="line">        retryDelayMs_ = <span class="built_in">std</span>::min(retryDelayMs_ * <span class="number">2</span>, kMaxRetryDelayMs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOG_DEBUG &lt;&lt; <span class="string">"do not connect"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种是 connecting，能进入 connecting 说明 connect 阻塞过程已经结束，接下来正式进入通讯过程，因此设置 channel 的两个回调。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Connector::connecting</span><span class="params">(<span class="keyword">int</span> sockfd)</span> </span>&#123;</span><br><span class="line">    setState(kConnecting);</span><br><span class="line">    assert(!channel_);</span><br><span class="line"></span><br><span class="line">    channel_.reset(<span class="keyword">new</span> Channel(loop_, sockfd));</span><br><span class="line">    channel_-&gt;setWriteCallback(</span><br><span class="line">            <span class="built_in">std</span>::bind(&amp;Connector::handleWrite, <span class="keyword">this</span>)); </span><br><span class="line">    channel_-&gt;setErrorCallback(</span><br><span class="line">            <span class="built_in">std</span>::bind(&amp;Connector::handleError, <span class="keyword">this</span>)); </span><br><span class="line">    channel_-&gt;enableWriting();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先看一下 WriteCallback，基本就是执行一下设置好的 newConnectionCallback_</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Connector::handleWrite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">"Connector::handleWrite "</span> &lt;&lt; state_;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (state_ == kConnecting) &#123;</span><br><span class="line">        <span class="keyword">int</span> sockfd = removeAndResetChannel();</span><br><span class="line">        <span class="keyword">int</span> err = sockets::getSocketError(sockfd);</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            LOG_WARN &lt;&lt; <span class="string">"Connector::handleWrite - SO_ERROR = "</span></span><br><span class="line">                     &lt;&lt; err &lt;&lt; <span class="string">" "</span> &lt;&lt; strerror_tl(err);</span><br><span class="line">            retry(sockfd);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sockets::isSelfConnect(sockfd)) &#123;</span><br><span class="line">            LOG_WARN &lt;&lt; <span class="string">"Connector::handleWrite - Self connect"</span>;</span><br><span class="line">            retry(sockfd);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            setState(kConnected);</span><br><span class="line">            <span class="keyword">if</span> (connect_) &#123;</span><br><span class="line">                newConnectionCallback_(sockfd);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sockets::close(sockfd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// what happened?</span></span><br><span class="line">        assert(state_ == kDisconnected);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看一下 ErrorCallback，基本操作就是 log 然后 retry。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Connector::handleError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOG_ERROR &lt;&lt; <span class="string">"Connector::handleError state="</span> &lt;&lt; state_;</span><br><span class="line">    <span class="keyword">if</span> (state_ == kConnecting) &#123;</span><br><span class="line">        <span class="keyword">int</span> sockfd = removeAndResetChannel();</span><br><span class="line">        <span class="keyword">int</span> err = sockets::getSocketError(sockfd);</span><br><span class="line">        LOG_TRACE &lt;&lt; <span class="string">"SO_ERROR = "</span> &lt;&lt; err &lt;&lt; <span class="string">" "</span> &lt;&lt; strerror_tl(err);</span><br><span class="line">        retry(sockfd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>restart</li>
</ol>
<p>restart 只能在 loop thread 中被调用，目标是重新设置各项 connector 参数，然后重启这个 connector</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Connector::restart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    setState(kDisconnected);</span><br><span class="line">    retryDelayMs_ = kInitRetryDelayMs;</span><br><span class="line">    connect_ = <span class="literal">true</span>;</span><br><span class="line">    startInLoop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="第三层"><a href="#第三层" class="headerlink" title="第三层"></a>第三层</h2><h3 id="1-EventLoop"><a href="#1-EventLoop" class="headerlink" title="1. EventLoop"></a>1. EventLoop</h3><p>封装事件循环，也是事件分派的中心。它用 TimerQueue 作为计时器管理，用 Poller 作为 IO Multiplexing。</p>
<ol>
<li>构造函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">EventLoop</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            EventLoop()</span><br><span class="line">                : </span><br><span class="line">                looping_(<span class="literal">false</span>),</span><br><span class="line">                quit_(<span class="literal">false</span>),</span><br><span class="line">                eventHandling_(<span class="literal">false</span>),</span><br><span class="line">                callingPendingFunctors_(<span class="literal">false</span>),</span><br><span class="line">                iteration_(<span class="number">0</span>),</span><br><span class="line">                threadId_(CurrentThread::tid()),</span><br><span class="line">                poller_(Poller::newDefaultPoller(<span class="keyword">this</span>)),</span><br><span class="line">                timerQueue_(<span class="keyword">new</span> TimerQueue(<span class="keyword">this</span>)),</span><br><span class="line">                wakeupFd_(createEventfd()),</span><br><span class="line">                wakeupChannel_(<span class="keyword">new</span> Channel(<span class="keyword">this</span>, wakeupFd_)),</span><br><span class="line">                currentActiveChannel_(<span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">                LOG_DEBUG &lt;&lt; <span class="string">"EventLoop created "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">" in thread "</span> &lt;&lt; threadId_;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (t_loopInThisThread) &#123;</span><br><span class="line">                    LOG_FATAL &lt;&lt; <span class="string">"Another EventLoop "</span> &lt;&lt; t_loopInThisThread &lt;&lt; <span class="string">" exists in this thread "</span> &lt;&lt; threadId_;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    t_loopInThisThread = <span class="keyword">this</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                wakeupChannel_-&gt;setReadCallback(<span class="built_in">std</span>::bind(&amp;EventLoop::handleRead, <span class="keyword">this</span>));</span><br><span class="line">    </span><br><span class="line">                wakeupChannel_-&gt;enableReading();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="keyword">bool</span> looping_; <span class="comment">/* atomic */</span></span><br><span class="line">            <span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; quit_;</span><br><span class="line">            <span class="keyword">bool</span> eventHandling_; <span class="comment">/* atomic */</span></span><br><span class="line">            <span class="keyword">bool</span> callingPendingFunctors_; <span class="comment">/* atomic */</span></span><br><span class="line">            <span class="keyword">int64_t</span> iteration_;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">pid_t</span> threadId_;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Poller&gt; poller_;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;TimerQueue&gt; timerQueue_;</span><br><span class="line">            <span class="keyword">int</span> wakeupFd_;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Channel&gt; wakeupChannel_;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<p>在构造函数中，构造了 Poller 和 TimerQueue。</p>
<p>另外就是构造了 wakeupChannel_，这个 channel 的 fd 是 eventfd，注册的 read 回调函数是下面这样，目前不知道这个 channel 是干啥的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::handleRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> one = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> n = sockets::read(wakeupFd_, &amp;one, <span class="keyword">sizeof</span> one);</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="keyword">sizeof</span> one) &#123;</span><br><span class="line">        LOG_ERROR &lt;&lt; <span class="string">"EventLoop::handleRead() reads "</span> &lt;&lt; n &lt;&lt; <span class="string">" bytes instead of 8"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Channel 相关</li>
</ol>
<p>一共有 3 个相关的函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">EventLoop</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">updateChannel</span><span class="params">(Channel *channel)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">removeChannel</span><span class="params">(Channel *channel)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">bool</span> <span class="title">hasChannel</span><span class="params">(Channel *channel)</span></span>;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Poller&gt; poller_;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<p>这几个函数的本质是向内部的 poller_ 对象注册或注销</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::updateChannel</span><span class="params">(Channel *channel)</span> </span>&#123;</span><br><span class="line">    assert(channel-&gt;ownerLoop() == <span class="keyword">this</span>);</span><br><span class="line">    assertInLoopThread();</span><br><span class="line">    poller_-&gt;updateChannel(channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::removeChannel</span><span class="params">(Channel *channel)</span> </span>&#123;</span><br><span class="line">    assert(channel-&gt;ownerLoop() == <span class="keyword">this</span>);</span><br><span class="line">    assertInLoopThread();</span><br><span class="line">    <span class="keyword">if</span> (eventHandling_) &#123;</span><br><span class="line">        assert(currentActiveChannel_ == channel ||</span><br><span class="line">               <span class="built_in">std</span>::find(activeChannels_.begin(), activeChannels_.end(), channel) == activeChannels_.end());</span><br><span class="line">    &#125;</span><br><span class="line">    poller_-&gt;removeChannel(channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EventLoop::hasChannel</span><span class="params">(Channel *channel)</span> </span>&#123;</span><br><span class="line">    assert(channel-&gt;ownerLoop() == <span class="keyword">this</span>);</span><br><span class="line">    assertInLoopThread();</span><br><span class="line">    <span class="keyword">return</span> poller_-&gt;hasChannel(channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Timer 相关</li>
</ol>
<p>一共有 4 个相关方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">EventLoop</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function">TimerId <span class="title">runAt</span><span class="params">(Timestamp time, TimerCallback cb)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function">TimerId <span class="title">runAfter</span><span class="params">(<span class="keyword">double</span> delay, TimerCallback cb)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function">TimerId <span class="title">runEvery</span><span class="params">(<span class="keyword">double</span> interval, TimerCallback cb)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">(TimerId timerId)</span></span>;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;TimerQueue&gt; timerQueue_;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<p>这几个方法的目标是注册定时回调函数或取消，实现靠的是内部的 TimerQueue 对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TimerId <span class="title">EventLoop::runAt</span><span class="params">(Timestamp time, TimerCallback cb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> timerQueue_-&gt;addTimer(<span class="built_in">std</span>::move(cb), time, <span class="number">0.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TimerId <span class="title">EventLoop::runAfter</span><span class="params">(<span class="keyword">double</span> delay, TimerCallback cb)</span> </span>&#123;</span><br><span class="line">    <span class="function">Timestamp <span class="title">time</span><span class="params">(addTime(Timestamp::now(), delay))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> runAt(time, <span class="built_in">std</span>::move(cb));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TimerId <span class="title">EventLoop::runEvery</span><span class="params">(<span class="keyword">double</span> interval, TimerCallback cb)</span> </span>&#123;</span><br><span class="line">    <span class="function">Timestamp <span class="title">time</span><span class="params">(addTime(Timestamp::now(), interval))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> timerQueue_-&gt;addTimer(<span class="built_in">std</span>::move(cb), time, interval);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::cancel</span><span class="params">(TimerId timerId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> timerQueue_-&gt;cancel(timerId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>loop </li>
</ol>
<p><code>EventLoop.h</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">EventLoop</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; Functor;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="keyword">bool</span> looping_; <span class="comment">/* atomic */</span></span><br><span class="line">            <span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; quit_;</span><br><span class="line">            <span class="keyword">int64_t</span> iteration_;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Poller&gt; poller_;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// scratch variables</span></span><br><span class="line">            ChannelList activeChannels_;</span><br><span class="line">            Channel *currentActiveChannel_;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<p><code>EventLoop.cc</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kPollTimeMs = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    assert(!looping_);</span><br><span class="line">    assertInLoopThread();</span><br><span class="line"></span><br><span class="line">    looping_ = <span class="literal">true</span>;</span><br><span class="line">    quit_ = <span class="literal">false</span>;  </span><br><span class="line"></span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">"EventLoop "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">" start looping"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!quit_) &#123;</span><br><span class="line">        activeChannels_.clear();</span><br><span class="line">        pollReturnTime_ = poller_-&gt;poll(kPollTimeMs, &amp;activeChannels_);</span><br><span class="line">        ++iteration_;</span><br><span class="line">        <span class="keyword">if</span> (Logger::logLevel() &lt;= Logger::TRACE) &#123;</span><br><span class="line">            printActiveChannels();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// TODO sort channel by priority</span></span><br><span class="line">        eventHandling_ = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (Channel *channel : activeChannels_) &#123;</span><br><span class="line">            currentActiveChannel_ = channel;</span><br><span class="line">            currentActiveChannel_-&gt;handleEvent(pollReturnTime_);</span><br><span class="line">        &#125;</span><br><span class="line">        currentActiveChannel_ = <span class="literal">NULL</span>;</span><br><span class="line">        eventHandling_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        doPendingFunctors();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">"EventLoop "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">" stop looping"</span>;</span><br><span class="line">    looping_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>loop 方法是一个死循环，它的主体是让 poller_ 监听一段时间的 IO 事件，然后调用已经注册好的这些 Channel 的各种 CallBack 函数进行处理；处理完这些事件以后，每一次循环会 doPendingFunctors 一次，看一下这个方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::doPendingFunctors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Functor&gt; functors;</span><br><span class="line">    callingPendingFunctors_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        functors.swap(pendingFunctors_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> Functor &amp;functor : functors) &#123;</span><br><span class="line">        functor();</span><br><span class="line">    &#125;</span><br><span class="line">    callingPendingFunctors_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的作用是有一些未执行的方法 pendingFunctors，在这个里面依次执行一下，pendingFunctors_ 是在以下的函数中被更新的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::runInLoop</span><span class="params">(Functor cb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isInLoopThread()) &#123;</span><br><span class="line">        cb();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        queueInLoop(<span class="built_in">std</span>::move(cb));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::queueInLoop</span><span class="params">(Functor cb)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        pendingFunctors_.push_back(<span class="built_in">std</span>::move(cb));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isInLoopThread() || callingPendingFunctors_) &#123;</span><br><span class="line">        wakeup();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>外部调用的接口是 runInLoop，如果 cb 没有被立刻执行，那么它就会加入到 pendingFunctors_ 中，等待在每次循环中执行掉。</p>
<p>事件包括了两部分：刚才说的是 IO 事件，还有一部分是 Timer 定时的事件，Timer 事件其实也跟 doPendingFunctors 有关：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TimerId <span class="title">EventLoop::runAt</span><span class="params">(Timestamp time, TimerCallback cb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> timerQueue_-&gt;addTimer(<span class="built_in">std</span>::move(cb), time, <span class="number">0.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TimerId <span class="title">TimerQueue::addTimer</span><span class="params">(TimerCallback cb,</span></span></span><br><span class="line"><span class="function"><span class="params">                             Timestamp when,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">double</span> interval)</span> </span>&#123;</span><br><span class="line">    Timer *timer = <span class="keyword">new</span> Timer(<span class="built_in">std</span>::move(cb), when, interval);</span><br><span class="line">    loop_-&gt;runInLoop(</span><br><span class="line">            <span class="built_in">std</span>::bind(&amp;TimerQueue::addTimerInLoop, <span class="keyword">this</span>, timer));</span><br><span class="line">    <span class="keyword">return</span> &#123;timer, timer-&gt;sequence()&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在 addTimer 时，本质上也把回调函数加到了 EventLoop 的 runInLoop 中，只不过回调函数是 TimerQueue::addTimerInLoop。</p>
<p>Timer 一旦注册好以后，跟 IO 事件一样，因为 timer 本身也有一个 timerfd，到时以后会唤醒，本质上还是一个 fd 的 IO。</p>
<p>TimerQueue 和 刚才的 wakeupChannel_ 的本质其实是一样的，TimerQueue 内部也有一个 Channel，对应一个 timerfd</p>
<p><code>TimerQueue.h</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">TimerQueue</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> timerfd_;</span><br><span class="line">            Channel timerfdChannel_;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="keyword">namespace</span> detail &#123;</span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">createTimerfd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> timerfd = ::timerfd_create(CLOCK_MONOTONIC, TFD_NONBLOCK | TFD_CLOEXEC);</span><br><span class="line">                <span class="keyword">if</span> (timerfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    LOG_SYSFATAL &lt;&lt; <span class="string">"Failed in timerfd_create"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> timerfd;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;  <span class="comment">// namespace detail</span></span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br><span class="line">```        </span><br><span class="line"></span><br><span class="line">`EventLoop.h`</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">EventLoop</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="keyword">int</span> wakeupFd_;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Channel&gt; wakeupChannel_;</span><br><span class="line">            </span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">createEventfd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> evtfd = ::eventfd(<span class="number">0</span>, EFD_NONBLOCK | EFD_CLOEXEC);</span><br><span class="line">        <span class="keyword">if</span> (evtfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            LOG_SYSERR &lt;&lt; <span class="string">"Failed in eventfd"</span>;</span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> evtfd;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>它们的底层都是一个系统调用，各产生一个 fd：timerfd 产生的是定时事件，eventfd 产生的事件，目标是让 poll 快速返回：向 eventfd 写入一个字节，就会产生一个可读事件，从而实现 poll 阻塞方法的快速返回。</p>
<p>无论是 TimerQueue 中的 timerfdChannel_，还是 EventLoop 中的 wakeupChannel_，都需要向 poller 中注册从而监听，这部分代码藏的比较深，在 Channel 的 enableReading 里面：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Channel::enableReading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    events_ |= kReadEvent;</span><br><span class="line">    update();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Channel::update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    addedToLoop_ = <span class="literal">true</span>;</span><br><span class="line">    loop_-&gt;updateChannel(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::updateChannel</span><span class="params">(Channel *channel)</span> </span>&#123;</span><br><span class="line">    assert(channel-&gt;ownerLoop() == <span class="keyword">this</span>);</span><br><span class="line">    assertInLoopThread();</span><br><span class="line">    poller_-&gt;updateChannel(channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>套了好几层，最终还是向 poller 注册上了。。。</p>
<p>总之，这个 loop 方法是 Reactor 模式的核心：一个 loop 一个 Thread，先向 poller 注册好要监听的 Channel，Channel 又包括了 3 种类型：要监听的 IO 端口、timerfd 抽象成的时间事件 Channel 和 为了快速推出阻塞而额外留好的 eventfd 抽象成的 Channel。产生事件以后，poller 退出阻塞，调用各个 channel 上注册好的处理回调函数。另外，在 loop 期间其他线程加入的方法，先 pending，然后一并处理一下。</p>
<ol start="5">
<li>quit</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">EventLoop</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                quit_ = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">                <span class="keyword">if</span> (!isInLoopThread()) &#123;</span><br><span class="line">                    wakeup();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">wakeup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">uint64_t</span> one = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">ssize_t</span> n = sockets::write(wakeupFd_, &amp;one, <span class="keyword">sizeof</span> one);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (n != <span class="keyword">sizeof</span> one) &#123;</span><br><span class="line">                    LOG_ERROR &lt;&lt; <span class="string">"EventLoop::wakeup() writes "</span> &lt;&lt; n &lt;&lt; <span class="string">" bytes instead of 8"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<p>quit 函数的目标是结束整个 loop：如果调用者就在当前线程，那么直接把 while 循环开始时的 quit 变量置为 true 即可；反之，为了快速退出 poller 的阻塞，向提前预留好的 wakeupfd 写一个字节，这样 poller 监听的 channel 就产生了可读事件，从而让阻塞退出。</p>
<h2 id="第四层"><a href="#第四层" class="headerlink" title="第四层"></a>第四层</h2><h3 id="1-EventLoopThread"><a href="#1-EventLoopThread" class="headerlink" title="1. EventLoopThread"></a>1. EventLoopThread</h3><p>启动一个线程，在其中运行 EventLoop::loop()</p>
<ol>
<li>构造函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">EventLoopThread</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(EventLoop *)&gt; ThreadInitCallback;</span><br><span class="line"></span><br><span class="line">            explicit EventLoopThread(const ThreadInitCallback &amp;cb = ThreadInitCallback(), const string &amp;name = string()) : loop_(NULL),</span><br><span class="line">                        exiting_(<span class="literal">false</span>),</span><br><span class="line">                        thread_(<span class="built_in">std</span>::bind(&amp;EventLoopThread::threadFunc, <span class="keyword">this</span>), name),</span><br><span class="line">                        mutex_(),</span><br><span class="line">                        cond_(mutex_),</span><br><span class="line">                        callback_(cb) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="function">EventLoop *loop_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">            <span class="keyword">bool</span> exiting_;</span><br><span class="line">            Thread thread_;</span><br><span class="line">            MutexLock mutex_;</span><br><span class="line">            <span class="function">Condition cond_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">            ThreadInitCallback callback_;</span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<p>其中，内部的 thread_ 对象注册的 func 是</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoopThread::threadFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EventLoop loop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (callback_) &#123;</span><br><span class="line">        callback_(&amp;loop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        loop_ = &amp;loop;</span><br><span class="line">        cond_.notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    loop.loop();</span><br><span class="line">    <span class="comment">//assert(exiting_);</span></span><br><span class="line">    <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    loop_ = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，在新开的 Thread 中，会先跑 ThreadInitCallBack，然后运行 loop.loop()</p>
<ol start="2">
<li>startLoop</li>
</ol>
<p>开始一个 loop，注意这里用 mutex 和 cond 保护 loop 的初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EventLoop *<span class="title">EventLoopThread::startLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assert(!thread_.started());</span><br><span class="line">    thread_.start();</span><br><span class="line"></span><br><span class="line">    EventLoop *loop = <span class="literal">NULL</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (loop_ == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            cond_.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        loop = loop_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-TcpConnection"><a href="#2-TcpConnection" class="headerlink" title="2. TcpConnection"></a>2. TcpConnection</h3><p>整个网络库的核心，封装一次 TCP 连接。每个 TcpConnection 必须归某个 EventLoop 管理，所有的 IO 会转移到这个线程。TcpConnection 既可以用于 Server，也可以用于 Client。</p>
<ol>
<li>构造函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">TcpConnection</span> :</span> noncopyable,</span><br><span class="line">                              <span class="keyword">public</span> <span class="built_in">std</span>::enable_shared_from_this&lt;TcpConnection&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            TcpConnection(EventLoop *loop,</span><br><span class="line">                          <span class="keyword">const</span> <span class="built_in">string</span> &amp;name,</span><br><span class="line">                          <span class="keyword">int</span> sockfd,</span><br><span class="line">                          <span class="keyword">const</span> InetAddress &amp;localAddr,</span><br><span class="line">                          <span class="keyword">const</span> InetAddress &amp;peerAddr): </span><br><span class="line">                    loop_(CHECK_NOTNULL(loop)),</span><br><span class="line">                    name_(nameArg),</span><br><span class="line">                    state_(kConnecting),</span><br><span class="line">                    reading_(<span class="literal">true</span>),</span><br><span class="line">                    socket_(<span class="keyword">new</span> Socket(sockfd)),</span><br><span class="line">                    channel_(<span class="keyword">new</span> Channel(loop, sockfd)),</span><br><span class="line">                    localAddr_(localAddr),</span><br><span class="line">                    peerAddr_(peerAddr),</span><br><span class="line">                    highWaterMark_(<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>) &#123;</span><br><span class="line"></span><br><span class="line">                channel_-&gt;setReadCallback(<span class="built_in">std</span>::bind(&amp;TcpConnection::handleRead, <span class="keyword">this</span>, _1));</span><br><span class="line"></span><br><span class="line">                channel_-&gt;setWriteCallback(<span class="built_in">std</span>::bind(&amp;TcpConnection::handleWrite, <span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">                channel_-&gt;setCloseCallback(<span class="built_in">std</span>::bind(&amp;TcpConnection::handleClose, <span class="keyword">this</span>));</span><br><span class="line">    </span><br><span class="line">                channel_-&gt;setErrorCallback(<span class="built_in">std</span>::bind(&amp;TcpConnection::handleError, <span class="keyword">this</span>));</span><br><span class="line">    </span><br><span class="line">                LOG_DEBUG &lt;&lt; <span class="string">"TcpConnection::ctor["</span> &lt;&lt; name_ &lt;&lt; <span class="string">"] at "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">" fd="</span> &lt;&lt; sockfd;</span><br><span class="line">    </span><br><span class="line">                socket_-&gt;setKeepAlive(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="keyword">enum</span> StateE &#123;</span><br><span class="line">                kDisconnected, kConnecting, kConnected, kDisconnecting</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            EventLoop *loop_;</span><br><span class="line">            <span class="keyword">const</span> <span class="built_in">string</span> name_;</span><br><span class="line">            StateE state_;  </span><br><span class="line">            <span class="keyword">bool</span> reading_;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Socket&gt; socket_;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Channel&gt; channel_;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> InetAddress localAddr_;</span><br><span class="line">            <span class="keyword">const</span> InetAddress peerAddr_;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">size_t</span> highWaterMark_;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<p>这个构造函数比较复杂：一个 TcpConnection 和一个 EventLoop 绑定；根据 sockfd 构造一个 Socket 对象；根据 EventLoop 和 sockfd 构造一个 Channel 对象。</p>
<p>localAddr_、peerAddr_ 和 highWaterMark_ 暂时还不知道代表什么；</p>
<p>每个 channel 可以设置 4 种 CallBack，在构造函数中都设置了，接下来依次看一下.</p>
<ol start="2">
<li><p>4 种 CallBack</p>
<ol>
<li><p>ReadCallBack</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::handleRead</span><span class="params">(Timestamp receiveTime)</span> </span>&#123;</span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    <span class="keyword">int</span> savedErrno = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> n = inputBuffer_.readFd(channel_-&gt;fd(), &amp;savedErrno);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        messageCallback_(shared_from_this(), &amp;inputBuffer_, receiveTime);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        handleClose();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        errno = savedErrno;</span><br><span class="line">        LOG_SYSERR &lt;&lt; <span class="string">"TcpConnection::handleRead"</span>;</span><br><span class="line">    </span><br><span class="line">        handleError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReadCallback 的目标是从内核把数据读到 inputBuffer_ 中，然后执行注册好的 messageCallback_。</p>
</li>
<li><p>WriteCallBack</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::handleWrite</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    <span class="keyword">if</span> (channel_-&gt;isWriting()) &#123;</span><br><span class="line">        <span class="keyword">ssize_t</span> n = sockets::write(channel_-&gt;fd(), outputBuffer_.peek(), outputBuffer_.readableBytes());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            outputBuffer_.retrieve(n);</span><br><span class="line">            <span class="keyword">if</span> (outputBuffer_.readableBytes() == <span class="number">0</span>) &#123;</span><br><span class="line">                channel_-&gt;disableWriting();</span><br><span class="line">                <span class="keyword">if</span> (writeCompleteCallback_) &#123;</span><br><span class="line">                    loop_-&gt;queueInLoop(<span class="built_in">std</span>::bind(writeCompleteCallback_, shared_from_this()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (state_ == kDisconnecting) &#123;</span><br><span class="line">                    shutdownInLoop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LOG_SYSERR &lt;&lt; <span class="string">"TcpConnection::handleWrite"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOG_TRACE &lt;&lt; <span class="string">"Connection fd = "</span> &lt;&lt; channel_-&gt;fd() &lt;&lt; <span class="string">" is down, no more writing"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WriteCallBack 的目标是把 outputBuffer_ 中的数据写到内核缓冲区中。如果把 outputBuffer_ 中的数据都写完了的话，那么就调用注册好的 writeCompleteCallback_</p>
</li>
<li><p>CloseCallBack</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::handleClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">"fd = "</span> &lt;&lt; channel_-&gt;fd() &lt;&lt; <span class="string">" state = "</span> &lt;&lt; stateToString();</span><br><span class="line"></span><br><span class="line">    assert(state_ == kConnected || state_ == kDisconnecting);</span><br><span class="line"></span><br><span class="line">    setState(kDisconnected);</span><br><span class="line"></span><br><span class="line">    channel_-&gt;disableAll();</span><br><span class="line"></span><br><span class="line">    <span class="function">TcpConnectionPtr <span class="title">guardThis</span><span class="params">(shared_from_this())</span></span>;</span><br><span class="line">    connectionCallback_(guardThis);</span><br><span class="line">    <span class="comment">// must be the last line</span></span><br><span class="line">    closeCallback_(guardThis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 CloseCallBack 中不关闭 sockfd，，只是设置状态且关闭 Channel 的读写能力，并调用 connectionCallback_</p>
</li>
<li><p>ErrorCallBack</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::handleError</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> err = sockets::getSocketError(channel_-&gt;fd());</span><br><span class="line">    LOG_ERROR &lt;&lt; <span class="string">"TcpConnection::handleError ["</span> &lt;&lt; name_ &lt;&lt; <span class="string">"] - SO_ERROR = "</span> &lt;&lt; err &lt;&lt; <span class="string">" "</span> &lt;&lt; strerror_tl(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个比较简单，获取一下 SocketError 就可以了</p>
</li>
</ol>
</li>
<li><p>send 方法</p>
</li>
</ol>
<p>总共有 3 个 public 方法</p>
<p><code>TcpConnection.h</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">TcpConnection</span> :</span> noncopyable,</span><br><span class="line">                              <span class="keyword">public</span> <span class="built_in">std</span>::enable_shared_from_this&lt;TcpConnection&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *message, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">const</span> StringPiece &amp;message)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(Buffer *message)</span></span>;  <span class="comment">// this one will swap data</span></span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::send</span><span class="params">(<span class="keyword">const</span> StringPiece &amp;message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state_ == kConnected) &#123;</span><br><span class="line">        <span class="keyword">if</span> (loop_-&gt;isInLoopThread()) &#123;</span><br><span class="line">            sendInLoop(message);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">void</span> (TcpConnection::*fp)(<span class="keyword">const</span> StringPiece &amp;message)</span><br><span class="line">            = &amp;TcpConnection::sendInLoop;</span><br><span class="line">            loop_-&gt;runInLoop(<span class="built_in">std</span>::bind(fp,<span class="keyword">this</span>, message.as_string()));</span><br><span class="line">            <span class="comment">//std::forward&lt;string&gt;(message)));</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::sendInLoop</span><span class="params">(<span class="keyword">const</span> StringPiece &amp;message)</span> </span>&#123;</span><br><span class="line">    sendInLoop(message.data(), message.size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::sendInLoop</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    <span class="keyword">ssize_t</span> nwrote = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> remaining = len;</span><br><span class="line">    <span class="keyword">bool</span> faultError = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (state_ == kDisconnected) &#123;</span><br><span class="line">        LOG_WARN &lt;&lt; <span class="string">"disconnected, give up writing"</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if no thing in output queue, try writing directly</span></span><br><span class="line">    <span class="keyword">if</span> (!channel_-&gt;isWriting() &amp;&amp; outputBuffer_.readableBytes() == <span class="number">0</span>) &#123;</span><br><span class="line">        nwrote = sockets::write(channel_-&gt;fd(), data, len);</span><br><span class="line">        <span class="keyword">if</span> (nwrote &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            remaining = len - nwrote;</span><br><span class="line">            <span class="keyword">if</span> (remaining == <span class="number">0</span> &amp;&amp; writeCompleteCallback_) &#123;</span><br><span class="line">                loop_-&gt;queueInLoop(<span class="built_in">std</span>::bind(writeCompleteCallback_, shared_from_this()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="comment">// nwrote &lt; 0</span></span><br><span class="line">        &#123;</span><br><span class="line">            nwrote = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (errno != EWOULDBLOCK) &#123;</span><br><span class="line">                LOG_SYSERR &lt;&lt; <span class="string">"TcpConnection::sendInLoop"</span>;</span><br><span class="line">                <span class="keyword">if</span> (errno == EPIPE || errno == ECONNRESET) <span class="comment">// <span class="doctag">FIXME:</span> any others?</span></span><br><span class="line">                &#123;</span><br><span class="line">                    faultError = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(remaining &lt;= len);</span><br><span class="line">    <span class="keyword">if</span> (!faultError &amp;&amp; remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> oldLen = outputBuffer_.readableBytes();</span><br><span class="line">        <span class="keyword">if</span> (oldLen + remaining &gt;= highWaterMark_</span><br><span class="line">            &amp;&amp; oldLen &lt; highWaterMark_</span><br><span class="line">            &amp;&amp; highWaterMarkCallback_) &#123;</span><br><span class="line">            loop_-&gt;queueInLoop(<span class="built_in">std</span>::bind(highWaterMarkCallback_, shared_from_this(), oldLen + remaining));</span><br><span class="line">        &#125;</span><br><span class="line">        outputBuffer_.append(<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt;(data) + nwrote, remaining);</span><br><span class="line">        <span class="keyword">if</span> (!channel_-&gt;isWriting()) &#123;</span><br><span class="line">            channel_-&gt;enableWriting();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>send 方法的主要思想是：如果 outputBuffer_ 中没有数据了，那么尝试直接通过 sockfd 写，不经过 outBuffer_ 这一中间环节了；否则的话，就把数据先写到 outputBuffer_ 中，等待 Channel 有写事件的时候，再通过注册好的 handleWrite 方法中，从 outputBuffer 写到 sockfd 中。</p>
<ol start="4">
<li>shutdown() 方法</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> use compare and swap</span></span><br><span class="line">    <span class="keyword">if</span> (state_ == kConnected) &#123;</span><br><span class="line">        setState(kDisconnecting);</span><br><span class="line">        <span class="comment">// <span class="doctag">FIXME:</span> shared_from_this()?</span></span><br><span class="line">        loop_-&gt;runInLoop(<span class="built_in">std</span>::bind(&amp;TcpConnection::shutdownInLoop, <span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::shutdownInLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    <span class="keyword">if</span> (!channel_-&gt;isWriting()) &#123;</span><br><span class="line">        <span class="comment">// we are not writing</span></span><br><span class="line">        socket_-&gt;shutdownWrite();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较简单，就是同步或者异步 shutdown socket</p>
<ol start="5">
<li>forceClose 和 forceCloseWithDelay</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::forceClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> use compare and swap</span></span><br><span class="line">    <span class="keyword">if</span> (state_ == kConnected || state_ == kDisconnecting) &#123;</span><br><span class="line">        setState(kDisconnecting);</span><br><span class="line">        loop_-&gt;queueInLoop(<span class="built_in">std</span>::bind(&amp;TcpConnection::forceCloseInLoop,</span><br><span class="line">                shared_from_this()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::forceCloseWithDelay</span><span class="params">(<span class="keyword">double</span> seconds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state_ == kConnected || state_ == kDisconnecting) &#123;</span><br><span class="line">        setState(kDisconnecting);</span><br><span class="line">        loop_-&gt;runAfter(</span><br><span class="line">                seconds, makeWeakCallback(shared_from_this(), &amp;TcpConnection::forceClose));  <span class="comment">// not forceCloseInLoop to avoid race condition</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::forceCloseInLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    <span class="keyword">if</span> (state_ == kConnected || state_ == kDisconnecting) &#123;</span><br><span class="line">        <span class="comment">// as if we received 0 byte in handleRead();</span></span><br><span class="line">        handleClose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也比较简单，最终是同步或异步调用 CloseCallBack</p>
<h2 id="第五层"><a href="#第五层" class="headerlink" title="第五层"></a>第五层</h2><h3 id="1-EventLoopThreadPool"><a href="#1-EventLoopThreadPool" class="headerlink" title="1. EventLoopThreadPool"></a>1. EventLoopThreadPool</h3><p>用于创建 IO 线程池，也就是说把 TcpConnection 分派到一组运行 EventLoop 的线程上。它是 TcpServer 的成员，生命期由后者控制</p>
<ol>
<li>构造函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">EventLoopThreadPool</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            EventLoopThreadPool(EventLoop *baseLoop, <span class="keyword">const</span> <span class="built_in">string</span> &amp;nameArg) : </span><br><span class="line">                baseLoop_(baseLoop),</span><br><span class="line">                name_(nameArg),</span><br><span class="line">                started_(<span class="literal">false</span>),</span><br><span class="line">                numThreads_(<span class="number">0</span>),</span><br><span class="line">                next_(<span class="number">0</span>) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            EventLoop *baseLoop_;</span><br><span class="line">            <span class="built_in">string</span> name_;</span><br><span class="line">            <span class="keyword">bool</span> started_;</span><br><span class="line">            <span class="keyword">int</span> numThreads_;</span><br><span class="line">            <span class="keyword">int</span> next_;</span><br><span class="line">            </span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<p>EventLoopThreadPool 有一个基本的 baseLoop_</p>
<ol start="2">
<li>start</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">EventLoopThreadPool</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">const</span> ThreadInitCallback &amp;cb = ThreadInitCallback())</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                assert(!started_);</span><br><span class="line">                baseLoop_-&gt;assertInLoopThread();</span><br><span class="line"></span><br><span class="line">                started_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numThreads_; ++i) &#123;</span><br><span class="line">                    <span class="keyword">char</span> buf[name_.size() + <span class="number">32</span>];</span><br><span class="line">                    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf, <span class="string">"%s%d"</span>, name_.c_str(), i);</span><br><span class="line"></span><br><span class="line">                    EventLoopThread *t = <span class="keyword">new</span> EventLoopThread(cb, buf);</span><br><span class="line">        </span><br><span class="line">                    threads_.push_back(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;EventLoopThread&gt;(t));</span><br><span class="line"></span><br><span class="line">                    loops_.push_back(t-&gt;startLoop());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (numThreads_ == <span class="number">0</span> &amp;&amp; cb) &#123;</span><br><span class="line">                    cb(baseLoop_);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;EventLoopThread&gt;&gt; threads_;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;EventLoop *&gt; loops_;</span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<p>这个方法会开 numThreads_ 个线程，并且在 numThreads_ 线程里面让 EventLoop 开始 loop 起来，在 EventLoopThreadPool 中保存好这个 Thread 和这些 EventLoop</p>
<ol start="3">
<li>getNextLoop</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">EventLoopThreadPool</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function">EventLoop *<span class="title">getNextLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                baseLoop_-&gt;assertInLoopThread();</span><br><span class="line">                assert(started_);</span><br><span class="line">                EventLoop *loop = baseLoop_;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!loops_.empty()) &#123;</span><br><span class="line">                    <span class="comment">// round-robin</span></span><br><span class="line">                    loop = loops_[next_];</span><br><span class="line">                    ++next_;</span><br><span class="line">                    <span class="keyword">if</span> (implicit_cast&lt;<span class="keyword">size_t</span>&gt;(next_) &gt;= loops_.size()) &#123;</span><br><span class="line">                        next_ = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> loop;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="keyword">int</span> numThreads_;</span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<p>这个方法是用来把 TcpConnection 分派到一组运行 EventLoop 的线程上，采取的方式是 round-robin</p>
<h3 id="2-TcpServer"><a href="#2-TcpServer" class="headerlink" title="2. TcpServer"></a>2. TcpServer</h3><p>用于编写网络服务器，接受客户的连接</p>
<ol>
<li>构造函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">TcpServer</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            TcpServer(EventLoop *loop,</span><br><span class="line">                      <span class="keyword">const</span> InetAddress &amp;listenAddr,</span><br><span class="line">                      <span class="keyword">const</span> <span class="built_in">string</span> &amp;nameArg,</span><br><span class="line">                      Option option = kNoReusePort) : </span><br><span class="line">                    loop_(CHECK_NOTNULL(loop)),</span><br><span class="line">                    ipPort_(listenAddr.toIpPort()),</span><br><span class="line">                    name_(nameArg),</span><br><span class="line">                    acceptor_(<span class="keyword">new</span> Acceptor(loop, listenAddr,option == kReusePort)),</span><br><span class="line">                    threadPool_(<span class="keyword">new</span> EventLoopThreadPool(loop, name_)),</span><br><span class="line">                    connectionCallback_(defaultConnectionCallback),</span><br><span class="line">                    messageCallback_(defaultMessageCallback),</span><br><span class="line">                    nextConnId_(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">                acceptor_-&gt;setNewConnectionCallback(<span class="built_in">std</span>::bind(&amp;TcpServer::newConnection, <span class="keyword">this</span>, _1, _2));</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            EventLoop *loop_;  <span class="comment">// the acceptor loop</span></span><br><span class="line">            <span class="keyword">const</span> <span class="built_in">string</span> ipPort_;</span><br><span class="line">            <span class="keyword">const</span> <span class="built_in">string</span> name_;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Acceptor&gt; acceptor_; <span class="comment">// avoid revealing Acceptor</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;EventLoopThreadPool&gt; threadPool_;</span><br><span class="line">            ConnectionCallback connectionCallback_;</span><br><span class="line">            MessageCallback messageCallback_;</span><br><span class="line">            <span class="keyword">int</span> nextConnId_;</span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<p>这个构造函数里面也干了很多事情：绑定 EventLoop；构造 Acceptor、构造 EventLoopThreadPool、设置 connectionCallback_ 和 messageCallback_。</p>
<p>其中，acceptor_ 设置了 NewConnectionCallback ：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpServer::newConnection</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> InetAddress &amp;peerAddr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    EventLoop *ioLoop = threadPool_-&gt;getNextLoop();</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">64</span>];</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf, <span class="string">"-%s#%d"</span>, ipPort_.c_str(), nextConnId_);</span><br><span class="line">    ++nextConnId_;</span><br><span class="line">    <span class="built_in">string</span> connName = name_ + buf;</span><br><span class="line"></span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">"TcpServer::newConnection ["</span> &lt;&lt; name_</span><br><span class="line">             &lt;&lt; <span class="string">"] - new connection ["</span> &lt;&lt; connName</span><br><span class="line">             &lt;&lt; <span class="string">"] from "</span> &lt;&lt; peerAddr.toIpPort();</span><br><span class="line">    <span class="function">InetAddress <span class="title">localAddr</span><span class="params">(sockets::getLocalAddr(sockfd))</span></span>;</span><br><span class="line">    <span class="comment">// FIXME poll with zero timeout to double confirm the new connection</span></span><br><span class="line">    <span class="comment">// FIXME use make_shared if necessary</span></span><br><span class="line">    <span class="function">TcpConnectionPtr <span class="title">conn</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">new</span> TcpConnection(ioLoop, connName, sockfd, localAddr, peerAddr))</span></span>;</span><br><span class="line">    connections_[connName] = conn;</span><br><span class="line">    </span><br><span class="line">    conn-&gt;setConnectionCallback(connectionCallback_);</span><br><span class="line">    conn-&gt;setMessageCallback(messageCallback_);</span><br><span class="line">    conn-&gt;setWriteCompleteCallback(writeCompleteCallback_);</span><br><span class="line">    conn-&gt;setCloseCallback(<span class="built_in">std</span>::bind(&amp;TcpServer::removeConnection, <span class="keyword">this</span>, _1)); <span class="comment">// <span class="doctag">FIXME:</span> unsafe</span></span><br><span class="line"></span><br><span class="line">    ioLoop-&gt;runInLoop(<span class="built_in">std</span>::bind(&amp;TcpConnection::connectEstablished, conn));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法比较重要。 Acceptor 用于接收 TCP 连接，它监听的是 listenfd；在连接到来后，会将 connfd 传入 newConnectionCallback_ 方法。</p>
<p>在这个 NewConnectionCallback 方法中，首先从 ThreadPool 中 Round-Robin 式的找一个 EventLoop，然后根据这个 connfd 新建一个 TcpConnection 传入这个 EventLoop 中，然后把这个 TcpConnection 的 4 种 CallBack 设置好，最终让这个 TcpConnection 放到 EventLoop 中开始跑。</p>
<p>接下来看看这 4 个 CallBack，这 4 个 CallBack 里面，connectionCallback_、messageCallback_ 和 writeCompleteCallback_ 都可以在 TcpServer 中外部 set，而 CloseCallback 是固定的：</p>
<ol start="2">
<li><p>TcpConnection 的 4 个 CallBack</p>
<ol>
<li><p>connectionCallback_ </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> muduo::net::defaultConnectionCallback(<span class="keyword">const</span> TcpConnectionPtr &amp;conn) &#123;</span><br><span class="line"></span><br><span class="line">    LOG_TRACE &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; <span class="string">" -&gt; "</span> &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; <span class="string">" is "</span> &lt;&lt; (conn-&gt;connected() ? <span class="string">"UP"</span> : <span class="string">"DOWN"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do not call conn-&gt;forceClose(), because some users want to register message callback only.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Default 情况下啥也不干</p>
</li>
<li><p>messageCallback_</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> muduo::net::defaultMessageCallback(<span class="keyword">const</span> TcpConnectionPtr &amp;, Buffer *buf, Timestamp) &#123;</span><br><span class="line">    buf-&gt;retrieveAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>writeCompleteCallback_</p>
<p> 没有 Default</p>
</li>
<li><p>closeCallBack_</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">conn-&gt;setCloseCallback(<span class="built_in">std</span>::bind(&amp;TcpServer::removeConnection, <span class="keyword">this</span>, _1)); <span class="comment">// <span class="doctag">FIXME:</span> unsafe</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpServer::removeConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> unsafe</span></span><br><span class="line">    loop_-&gt;runInLoop(<span class="built_in">std</span>::bind(&amp;TcpServer::removeConnectionInLoop, <span class="keyword">this</span>, conn));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpServer::removeConnectionInLoop</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn)</span> </span>&#123;</span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">"TcpServer::removeConnectionInLoop ["</span> &lt;&lt; name_ &lt;&lt; <span class="string">"] - connection "</span> &lt;&lt; conn-&gt;name();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> n = connections_.erase(conn-&gt;name());</span><br><span class="line">    (<span class="keyword">void</span>) n;</span><br><span class="line">    assert(n == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    EventLoop *ioLoop = conn-&gt;getLoop();</span><br><span class="line">    ioLoop-&gt;queueInLoop(<span class="built_in">std</span>::bind(&amp;TcpConnection::connectDestroyed, conn));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::connectDestroyed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    <span class="keyword">if</span> (state_ == kConnected) &#123;</span><br><span class="line">        setState(kDisconnected);</span><br><span class="line">        channel_-&gt;disableAll();</span><br><span class="line">        connectionCallback_(shared_from_this());</span><br><span class="line">    &#125;</span><br><span class="line">    channel_-&gt;remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 CloseCallBack 的目标是移除对应 EventLoop 中的 Channel</p>
</li>
</ol>
</li>
<li><p>start 方法</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpServer::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (started_.getAndSet(<span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        threadPool_-&gt;start(threadInitCallback_);</span><br><span class="line"></span><br><span class="line">        assert(!acceptor_-&gt;listenning());</span><br><span class="line">        loop_-&gt;runInLoop(</span><br><span class="line">                <span class="built_in">std</span>::bind(&amp;Acceptor::listen, get_pointer(acceptor_)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先一个 CAS 操作保证一个 TcpServer 只 start 一次，然后让 ThreadPool 开始启动线程，同时让 Acceptor 开始监听端口</p>
<ol start="4">
<li>析构函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TcpServer::~TcpServer() &#123;</span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">"TcpServer::~TcpServer ["</span> &lt;&lt; name_ &lt;&lt; <span class="string">"] destructing"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;item : connections_) &#123;</span><br><span class="line">        <span class="function">TcpConnectionPtr <span class="title">conn</span><span class="params">(item.second)</span></span>;</span><br><span class="line">        item.second.reset();</span><br><span class="line">        conn-&gt;getLoop()-&gt;runInLoop(</span><br><span class="line">                <span class="built_in">std</span>::bind(&amp;TcpConnection::connectDestroyed, conn));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>析构函数中，让所有的 TcpConnection 对象的 Channel 都销毁掉。</p>
<h3 id="3-TcpClient"><a href="#3-TcpClient" class="headerlink" title="3. TcpClient"></a>3. TcpClient</h3><p>用于编写网络客户端，能发起连接，并且有重试功能。</p>
<ol>
<li>构造函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">TcpClient</span> :</span> noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            TcpClient(EventLoop *loop,</span><br><span class="line">                      <span class="keyword">const</span> InetAddress &amp;serverAddr,</span><br><span class="line">                      <span class="keyword">const</span> <span class="built_in">string</span> &amp;nameArg):</span><br><span class="line">                    loop_(CHECK_NOTNULL(loop)),</span><br><span class="line">                    connector_(<span class="keyword">new</span> Connector(loop, serverAddr)),</span><br><span class="line">                    name_(nameArg),</span><br><span class="line">                    connectionCallback_(defaultConnectionCallback),</span><br><span class="line">                    messageCallback_(defaultMessageCallback),</span><br><span class="line">                    retry_(<span class="literal">false</span>),</span><br><span class="line">                    connect_(<span class="literal">true</span>),</span><br><span class="line">                    nextConnId_(<span class="number">1</span>) &#123;</span><br><span class="line">    </span><br><span class="line">                connector_-&gt;setNewConnectionCallback(</span><br><span class="line">                <span class="built_in">std</span>::bind(&amp;TcpClient::newConnection, <span class="keyword">this</span>, _1));</span><br><span class="line">                LOG_INFO &lt;&lt; <span class="string">"TcpClient::TcpClient["</span> &lt;&lt; name_ &lt;&lt; <span class="string">"] - connector "</span> &lt;&lt; get_pointer(connector_);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            EventLoop *loop_;</span><br><span class="line">            ConnectorPtr connector_; <span class="comment">// avoid revealing Connector</span></span><br><span class="line">            <span class="keyword">const</span> <span class="built_in">string</span> name_;</span><br><span class="line">            ConnectionCallback connectionCallback_;</span><br><span class="line">            MessageCallback messageCallback_;</span><br><span class="line">            <span class="keyword">bool</span> retry_;   <span class="comment">// atomic</span></span><br><span class="line">            <span class="keyword">bool</span> connect_; <span class="comment">// atomic</span></span><br><span class="line">            <span class="comment">// always in loop thread</span></span><br><span class="line">            <span class="keyword">int</span> nextConnId_;</span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;  <span class="comment">// namespace net</span></span><br><span class="line">&#125;  <span class="comment">// namespace muduo</span></span><br></pre></td></tr></table></figure>

<p>TcpClient 绑定一个 EventLoop，内部有一个 connector 用于新建 TCP 连接；connectionCallback_ 和 messageCallback_ 初始都设为 default，default 是啥也不干；Connector 要设置 NewConnection 的 Callback 如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpClient::newConnection</span><span class="params">(<span class="keyword">int</span> sockfd)</span> </span>&#123;</span><br><span class="line">    loop_-&gt;assertInLoopThread();</span><br><span class="line">    <span class="function">InetAddress <span class="title">peerAddr</span><span class="params">(sockets::getPeerAddr(sockfd))</span></span>;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf,</span><br><span class="line">             <span class="string">":%s#%d"</span>, peerAddr.toIpPort().c_str(), nextConnId_);</span><br><span class="line">    ++nextConnId_;</span><br><span class="line">    <span class="built_in">string</span> connName = name_ + buf;</span><br><span class="line"></span><br><span class="line">    <span class="function">InetAddress <span class="title">localAddr</span><span class="params">(sockets::getLocalAddr(sockfd))</span></span>;</span><br><span class="line">    <span class="comment">// FIXME poll with zero timeout to double confirm the new connection</span></span><br><span class="line">    <span class="comment">// FIXME use make_shared if necessary</span></span><br><span class="line">    <span class="function">TcpConnectionPtr <span class="title">conn</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">new</span> TcpConnection(loop_, connName, sockfd, localAddr, peerAddr))</span></span>;</span><br><span class="line"></span><br><span class="line">    conn-&gt;setConnectionCallback(connectionCallback_);</span><br><span class="line">    conn-&gt;setMessageCallback(messageCallback_);</span><br><span class="line">    conn-&gt;setWriteCompleteCallback(writeCompleteCallback_);</span><br><span class="line">    conn-&gt;setCloseCallback(</span><br><span class="line">            <span class="built_in">std</span>::bind(&amp;TcpClient::removeConnection, <span class="keyword">this</span>, _1)); <span class="comment">// <span class="doctag">FIXME:</span> unsafe</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        connection_ = conn;</span><br><span class="line">    &#125;</span><br><span class="line">    conn-&gt;connectEstablished();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 Callback 的目标是打开一个 TcpConnection，这个 TcpConnection 注册好各种回调，然后 channel 开始监听。</p>
<ol start="2">
<li>connect </li>
</ol>
<p>让内部的 connector 开始 connect </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpClient::connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> check state</span></span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">"TcpClient::connect["</span> &lt;&lt; name_ &lt;&lt; <span class="string">"] - connecting to "</span></span><br><span class="line">             &lt;&lt; connector_-&gt;serverAddress().toIpPort();</span><br><span class="line">    connect_ = <span class="literal">true</span>;</span><br><span class="line">    connector_-&gt;start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>disconnect</li>
</ol>
<p>断开 TcpConnection，对于 TcpClient，它只有一个 TcpConnection，这点和 TcpServer 明显不同</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpClient::disconnect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    connect_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (connection_) &#123;</span><br><span class="line">            connection_-&gt;shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>stop</li>
</ol>
<p>让内部的 connector stop</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpClient::stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    connect_ = <span class="literal">false</span>;</span><br><span class="line">    connector_-&gt;stop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>以上就把 muduo 中的 net 部分基本介绍完了，好累。。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E4%B8%AD%E7%9A%84net%E7%BB%84%E4%BB%B6/" data-id="ck7jvsf1f000atgveb4bgam8l" class="article-share-link">分享到</a>
      

      
        <a href="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E4%B8%AD%E7%9A%84net%E7%BB%84%E4%BB%B6/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cpp/" rel="tag">Cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Net/" rel="tag">Net</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B%E4%B9%8B%E4%B8%80%EF%BC%9A%E4%BA%94%E4%B8%AA%E7%AE%80%E5%8D%95TCP%E5%8D%8F%E8%AE%AE/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">
        
          muduo 网络编程示例之一：五个简单 TCP 协议
        
      </div>
    </a>
  
  
    <a href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B%E4%B9%8B%E9%9B%B6%EF%BC%9A%E5%89%8D%E8%A8%80/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">muduo 网络编程示例之零：前言</div>
    </a>
  
</nav>

  
</article>


  <section id="comments">
    <div id="ds-thread" class="ds-thread" data-thread-key="开源组件/muduo/muduo中的net组件/" data-title="muduo 中的 net 组件" data-url="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E4%B8%AD%E7%9A%84net%E7%BB%84%E4%BB%B6/"></div>
  </section>
</section>
      
      <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/">开源组件</a><span class="category-list-count">12</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/">muduo</a><span class="category-list-count">12</span></li></ul></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Boost/" rel="tag">Boost</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CMake/" rel="tag">CMake</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cpp/" rel="tag">Cpp</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IO/" rel="tag">IO</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Net/" rel="tag">Net</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reactor/" rel="tag">Reactor</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP/" rel="tag">TCP</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Boost/" style="font-size: 13.33px;">Boost</a> <a href="/tags/CMake/" style="font-size: 10px;">CMake</a> <a href="/tags/Cpp/" style="font-size: 20px;">Cpp</a> <a href="/tags/IO/" style="font-size: 13.33px;">IO</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Net/" style="font-size: 16.67px;">Net</a> <a href="/tags/Reactor/" style="font-size: 10px;">Reactor</a> <a href="/tags/TCP/" style="font-size: 13.33px;">TCP</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a><span class="archive-list-count">12</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%EF%BC%9A%E4%B8%80%E4%B8%AASudoku%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%BC%94%E5%8F%98/">muduo 多线程模型：一个 Sudoku 服务器演变</a>
          </li>
        
          <li>
            <a href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B%E4%B9%8B%E4%BA%8C%EF%BC%9ABoost.Asio%E7%9A%84%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/">muduo 网络编程示例之二： Boost.Asio 的聊天服务器</a>
          </li>
        
          <li>
            <a href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/%E4%B8%BA%E4%BB%80%E4%B9%88muduo%E7%9A%84shutdown()%E6%B2%A1%E6%9C%89%E7%9B%B4%E6%8E%A5%E5%85%B3%E9%97%ADTCP%E8%BF%9E%E6%8E%A5%EF%BC%9F/">为什么 muduo 的 shutdown() 没有直接关闭 TCP 连接？</a>
          </li>
        
          <li>
            <a href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B%E4%B9%8B%E4%B8%80%EF%BC%9A%E4%BA%94%E4%B8%AA%E7%AE%80%E5%8D%95TCP%E5%8D%8F%E8%AE%AE/">muduo 网络编程示例之一：五个简单 TCP 协议</a>
          </li>
        
          <li>
            <a href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E4%B8%AD%E7%9A%84net%E7%BB%84%E4%BB%B6/">muduo 中的 net 组件</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">友情链接</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="https://github.com/midudu" target="_blank">GitHub</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Midudu<br>
      Powered by <a href="//hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/xiangming/landscape-plus" target="_blank">Landscape-plus</a>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->

<!-- 多说公共js代码 start -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"midudu"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共js代码 end -->


<!-- 百度分享 start -->

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>




<! -- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
                processEscapes: true
                    
}
  
        });
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
                  
}
    
        });
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Queue(function() {
            var all = MathJax.Hub.getAllJax(), i;
            for(i=0; i < all.length; i += 1) {
                            all[i].SourceElement().parentNode.className += ' has-jax';
                                    
            }
                
        });
</script>

<script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



<script src="/js/script.js"></script>


</div>
</body>
</html>
