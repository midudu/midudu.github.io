
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>muduo 网络编程示例之二： Boost.Asio 的聊天服务器 | Midudu&#39;s Home</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="原文链接 https:&#x2F;&#x2F;blog.csdn.net&#x2F;Solstice&#x2F;article&#x2F;details&#x2F;6172391  本文将介绍一个与 Boost.Asio 的示例代码中的聊天服务器功能类似的网络服务程序，包括客户端与服务端的 muduo 实现。这个例子的主要目的是介绍如何处理分包，并初步涉及 Muduo 的多线程功能。Muduo 的下载地址： http:&#x2F;&#x2F;muduo.googlecode">
<meta property="og:type" content="article">
<meta property="og:title" content="muduo 网络编程示例之二： Boost.Asio 的聊天服务器">
<meta property="og:url" content="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B%E4%B9%8B%E4%BA%8C%EF%BC%9ABoost.Asio%E7%9A%84%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/index.html">
<meta property="og:site_name" content="Midudu&#39;s Home">
<meta property="og:description" content="原文链接 https:&#x2F;&#x2F;blog.csdn.net&#x2F;Solstice&#x2F;article&#x2F;details&#x2F;6172391  本文将介绍一个与 Boost.Asio 的示例代码中的聊天服务器功能类似的网络服务程序，包括客户端与服务端的 muduo 实现。这个例子的主要目的是介绍如何处理分包，并初步涉及 Muduo 的多线程功能。Muduo 的下载地址： http:&#x2F;&#x2F;muduo.googlecode">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-03-09T03:00:45.855Z">
<meta property="article:modified_time" content="2020-03-09T03:01:30.000Z">
<meta property="article:author" content="Midudu">
<meta property="article:tag" content="Cpp">
<meta property="article:tag" content="Net">
<meta property="article:tag" content="Boost">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="Midudu&#39;s Home" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
<link rel="stylesheet" href="/css/style.css">

  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
<meta name="generator" content="Hexo 4.2.0"></head>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Midudu&#39;s Home</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="yoursite.com">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main"><article id="post-muduo网络编程示例之二：Boost.Asio的聊天服务器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B%E4%B9%8B%E4%BA%8C%EF%BC%9ABoost.Asio%E7%9A%84%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/" class="article-date">
  <time datetime="2020-03-09T03:00:45.855Z" itemprop="datePublished">2020-03-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/">开源组件</a>►<a class="article-category-link" href="/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/">muduo</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      muduo 网络编程示例之二： Boost.Asio 的聊天服务器
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>原文链接 <a href="https://blog.csdn.net/Solstice/article/details/6172391" target="_blank" rel="noopener">https://blog.csdn.net/Solstice/article/details/6172391</a></p>
</blockquote>
<p>本文将介绍一个与 Boost.Asio 的示例代码中的聊天服务器功能类似的网络服务程序，包括客户端与服务端的 muduo 实现。这个例子的<strong>主要目的是介绍如何处理分包</strong>，并初步涉及 Muduo 的<strong>多线程功能</strong>。Muduo 的下载地址： <a href="http://muduo.googlecode.com/files/muduo-0.1.7-alpha.tar.gz" target="_blank" rel="noopener">http://muduo.googlecode.com/files/muduo-0.1.7-alpha.tar.gz</a> ，SHA1 873567e43b3c2cae592101ea809b30ba730f2ee6，本文的完整代码可在线阅读<br><a href="http://code.google.com/p/muduo/source/browse/trunk/examples/asio/chat/" target="_blank" rel="noopener">http://code.google.com/p/muduo/source/browse/trunk/examples/asio/chat/</a> 。</p>
<ul>
<li><a href="#%e4%b8%80tcp-%e5%88%86%e5%8c%85">一、TCP 分包</a></li>
<li><a href="#%e4%ba%8c%e8%81%8a%e5%a4%a9%e6%9c%8d%e5%8a%a1">二、聊天服务</a></li>
<li><a href="#%e4%b8%89%e6%b6%88%e6%81%af%e6%a0%bc%e5%bc%8f">三、消息格式</a></li>
<li><a href="#%e5%9b%9b%e6%89%93%e5%8c%85%e7%9a%84%e4%bb%a3%e7%a0%81">四、打包的代码</a></li>
<li><a href="#%e4%ba%94%e5%88%86%e5%8c%85%e7%9a%84%e4%bb%a3%e7%a0%81">五、分包的代码</a></li>
<li><a href="#%e5%85%ad%e7%bc%96%e8%a7%a3%e7%a0%81%e5%99%a8-lengthheadercodec">六、编解码器 LengthHeaderCodec</a></li>
<li><a href="#%e4%b8%83%e6%9c%8d%e5%8a%a1%e7%ab%af%e7%9a%84%e5%ae%9e%e7%8e%b0">七、服务端的实现</a></li>
<li><a href="#%e5%85%ab%e5%ae%a2%e6%88%b7%e7%ab%af%e7%9a%84%e5%ae%9e%e7%8e%b0">八、客户端的实现</a></li>
<li><a href="#%e4%b9%9d%e7%ae%80%e5%8d%95%e6%b5%8b%e8%af%95">九、简单测试</a></li>
</ul>
<h2 id="一、TCP-分包"><a href="#一、TCP-分包" class="headerlink" title="一、TCP 分包"></a>一、TCP 分包</h2><p>前面一篇《五个简单 TCP 协议》中处理的协议没有涉及分包，在 TCP 这种字节流协议上做<strong>应用层分包</strong>是网络编程的基本需求。<strong>分包</strong>指的是在发送一个消息(message)或一帧(frame)数据时，通过一定的处理，让接收方能从字节流中识别并截取（还原）出一个个消息。“粘包问题”是个伪问题。</p>
<p><strong>对于短连接的 TCP 服务，分包不是一个问题</strong>，只要发送方主动关闭连接，就表示一条消息发送完毕，<strong>接收方 read() 返回 0，从而知道消息的结尾</strong>。例如前一篇文章里的 daytime 和 time 协议。</p>
<p><strong>注：一方主动关闭 TCP 连接时，另一方 read() 返回 0 ，则代表对方已经关闭连接。</strong></p>
<p>对于长连接的 TCP 服务，分包有四种方法：</p>
<ul>
<li><strong>消息长度固定</strong>，比如 muduo 的 roundtrip 示例就采用了固定的 16 字节消息；</li>
<li><strong>使用特殊的字符或字符串作为消息的边界</strong>，例如 HTTP 协议的 headers 以 “/r/n” 为字段的分隔符；</li>
<li><strong>在每条消息的头部加一个长度字段</strong>，这恐怕是<strong>最常见的做法</strong>，本文的聊天协议也采用这一办法；</li>
<li>利用消息本身的格式来分包，例如 XML 格式的消息中 <code>...</code> 的配对，或者 JSON 格式中的 <code>{ ... }</code> 的配对。解析这种消息格式通常会用到状态机。</li>
</ul>
<p>在后文的代码讲解中还会仔细讨论用长度字段分包的常见陷阱。</p>
<h2 id="二、聊天服务"><a href="#二、聊天服务" class="headerlink" title="二、聊天服务"></a>二、聊天服务</h2><p>本文实现的聊天服务非常简单，由服务端程序和客户端程序组成，<strong>协议如下</strong>：</p>
<ul>
<li>服务端程序中某个端口侦听 (listen) 新的连接；</li>
<li>客户端向服务端发起连接；</li>
<li>连接建立之后，客户端随时准备接收服务端的消息并在屏幕上显示出来；</li>
<li>客户端接受键盘输入，以回车为界，把消息发送给服务端；</li>
<li>服务端接收到消息之后，依次发送给每个连接到它的客户端；原来发送消息的客户端进程也会收到这条消息；</li>
<li>一个服务端进程可以同时服务多个客户端进程，当有消息到达服务端后，每个客户端进程都会收到同一条消息，服务端广播发送消息的顺序是任意的，不一定哪个客户端会先收到这条消息。</li>
<li>（可选）如果消息 A 先于消息 B 到达服务端，那么每个客户端都会先收到 A 再收到 B。</li>
</ul>
<p>这实际上是一个简单的基于 TCP 的应用层广播协议，<strong>由服务端负责把消息发送给每个连接到它的客户端</strong>。参与“聊天”的既可以是人，也可以是程序。在以后的文章中，我将介绍一个稍微复杂的一点的例子 hub，它有“聊天室”的功能，客户端可以注册特定的 topic(s)，并往某个 topic 发送消息，这样代码更有意思。</p>
<h2 id="三、消息格式"><a href="#三、消息格式" class="headerlink" title="三、消息格式"></a>三、消息格式</h2><p>本聊天服务的消息格式非常简单，“消息”本身是一个字符串，<strong>每条消息的有一个 4 字节的头部，以网络序存放字符串的长度</strong>。消息之间没有间隙，字符串也不一定以 ‘/0’ 结尾。比方说有两条消息 “hello” 和 “chenshuo”，那么打包后的字节流是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00, 0x00, 0x00, 0x05, &#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, 0x00, 0x00, 0x00, 0x08, &#39;c&#39;, &#39;h&#39;, &#39;e&#39;, &#39;n&#39;, &#39;s&#39;, &#39;h&#39;, &#39;u&#39;, &#39;o&#39;</span><br></pre></td></tr></table></figure>

<p>共 21 字节。</p>
<h2 id="四、打包的代码"><a href="#四、打包的代码" class="headerlink" title="四、打包的代码"></a>四、打包的代码</h2><p>这段代码把 const string&amp; message 打包为 muduo::net::Buffer，并通过 conn 发送。</p>
<p><code>muduo/examples/asio/chat/codec.h</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(muduo::net::TcpConnection* conn, <span class="keyword">const</span> <span class="built_in">string</span>&amp; message)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    muduo::net::Buffer buf;</span><br><span class="line">    buf.append(message.data(), message.size());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> len = muduo::net::sockets::hostToNetwork32(<span class="keyword">static_cast</span>(message.size()));</span><br><span class="line">    buf.prepend(&amp;len, <span class="keyword">sizeof</span> len);</span><br><span class="line"></span><br><span class="line">    conn-&gt;send(&amp;buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>muduo::Buffer 有一个很好的功能，它在头部预留了 8 个字节的空间，这样第 6 行的 prepend() 操作就不需要移动已有的数据，效率较高。</p>
<h2 id="五、分包的代码"><a href="#五、分包的代码" class="headerlink" title="五、分包的代码"></a>五、分包的代码</h2><p>解析数据往往比生成数据复杂，分包打包也不例外。</p>
<p><code>muduo/examples/asio/chat/codec.h</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr&amp; conn, muduo::net::Buffer* buf, muduo::Timestamp receiveTime)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (buf-&gt;readableBytes() &gt;= kHeaderLen) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">void</span>* data = buf-&gt;peek();</span><br><span class="line">        <span class="keyword">int32_t</span> tmp = *<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">int32_t</span>*&gt;(data);</span><br><span class="line">        <span class="keyword">int32_t</span> len = muduo::net::sockets::networkToHost32(tmp);</span><br><span class="line">        <span class="keyword">if</span> (len &gt; <span class="number">65536</span> || len &lt; <span class="number">0</span>) &#123; </span><br><span class="line">            LOG_ERROR &lt;&lt; <span class="string">"Invalid length "</span> &lt;&lt; len;</span><br><span class="line">            conn-&gt;shutdown();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (buf-&gt;readableBytes() &gt;= len + kHeaderLen) &#123;</span><br><span class="line">            buf-&gt;retrieve(kHeaderLen);</span><br><span class="line">            <span class="function">muduo::<span class="built_in">string</span> <span class="title">message</span><span class="params">(buf-&gt;peek(), len)</span></span>;</span><br><span class="line">            buf-&gt;retrieve(len);</span><br><span class="line">            messageCallback_(conn, message, receiveTime);  <span class="comment">// 收到完整的消息，通知用户</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码第 7 行用了 while 循环来反复读取数据，直到 Buffer 中的数据不够一条完整的消息。请读者思考，如果换成 if (buf-&gt;readableBytes() &gt;= kHeaderLen) 会有什么后果。</p>
<p>以前面提到的两条消息的字节流为例：</p>
<p>0x00, 0x00, 0x00, 0x05, ‘h’, ‘e’, ‘l’, ‘l’, ‘o’, 0x00, 0x00, 0x00, 0x08, ‘c’, ‘h’, ‘e’, ‘n’, ‘s’, ‘h’, ‘u’, ‘o’</p>
<p>假设数据最终都全部到达，onMessage() 至少要能正确处理以下各种数据到达的次序，每种情况下 messageCallback_ 都应该被调用两次：</p>
<ol>
<li>每次收到一个字节的数据，onMessage() 被调用 21 次；</li>
<li>数据分两次到达，第一次收到 2 个字节，不足消息的长度字段；</li>
<li>数据分两次到达，第一次收到 4 个字节，刚好够长度字段，但是没有 body；</li>
<li>数据分两次到达，第一次收到 8 个字节，长度完整，但 body 不完整；</li>
<li>数据分两次到达，第一次收到 9 个字节，长度完整，body 也完整；</li>
<li>数据分两次到达，第一次收到 10 个字节，第一条消息的长度完整、body 也完整，第二条消息长度不完整；</li>
<li>请自行移动分割点，验证各种情况；</li>
<li>数据一次就全部到达，这时必须用 while 循环来读出两条消息，否则消息会堆积。</li>
</ol>
<p>请读者验证 onMessage() 是否做到了以上几点。这个例子充分说明了 non-blocking read 必须和 input buffer 一起使用。这也解释了为什么该用 while 而不是 if 。</p>
<h2 id="六、编解码器-LengthHeaderCodec"><a href="#六、编解码器-LengthHeaderCodec" class="headerlink" title="六、编解码器 LengthHeaderCodec"></a>六、编解码器 LengthHeaderCodec</h2><p>有人评论 Muduo 的接收缓冲区不能设置回调函数的触发条件，确实如此。每当 socket 可读，Muduo 的 TcpConnection 会读取数据并存入 Input Buffer，然后回调用户的函数。不过，<strong>一个简单的间接层就能解决问题</strong>，让用户代码只关心“消息到达”而不是“数据到达”，如本例中的 LengthHeaderCodec 所展示的那一样。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MUDUO_EXAMPLES_ASIO_CHAT_CODEC_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MUDUO_EXAMPLES_ASIO_CHAT_CODEC_H</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">using</span> muduo::Logger;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LengthHeaderCodec</span> :</span> boost::noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> boost::function&lt;<span class="keyword">void</span> (<span class="keyword">const</span> muduo::net::TcpConnectionPtr&amp;, <span class="keyword">const</span> muduo::<span class="built_in">string</span>&amp; message, muduo::Timestamp)&gt; StringMessageCallback;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">LengthHeaderCodec</span><span class="params">(<span class="keyword">const</span> StringMessageCallback&amp; cb)</span> : <span class="title">messageCallback_</span><span class="params">(cb)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="keyword">const</span> muduo::net::TcpConnectionPtr&amp; conn, muduo::net::Buffer* buf, muduo::Timestamp receiveTime)</span> </span>&#123; 同上 &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(muduo::net::TcpConnection* conn, <span class="keyword">const</span> muduo::<span class="built_in">string</span>&amp; message)</span> </span>&#123; 同上 &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    StringMessageCallback messageCallback_;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">size_t</span> kHeaderLen = <span class="keyword">sizeof</span>(<span class="keyword">int32_t</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// MUDUO_EXAMPLES_ASIO_CHAT_CODEC_H</span></span></span><br></pre></td></tr></table></figure>

<p>这段代码把以 Buffer* 为参数的 MessageCallback 转换成了以 const string&amp; 为参数的 StringMessageCallback，<strong>让用户代码不必关心分包操作。客户端和服务端都能从中受益</strong>。</p>
<h2 id="七、服务端的实现"><a href="#七、服务端的实现" class="headerlink" title="七、服务端的实现"></a>七、服务端的实现</h2><p>聊天服务器的服务端代码小于 100 行，不到 asio 的一半。</p>
<p>请先阅读第 68 行起的数据成员的定义。除了经常见到的 EventLoop 和 TcpServer，ChatServer 还定义了 codec_ 和 std::set connections_ 作为成员，connections_ 是目前已建立的客户连接，<strong>在收到消息之后，服务器会遍历整个容器，把消息广播给其中每一个 TCP 连接</strong>。</p>
<p>首先，在构造函数里注册回调：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"codec.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo::net;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChatServer</span> :</span> boost::noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ChatServer(EventLoop* loop, <span class="keyword">const</span> InetAddress&amp; listenAddr): </span><br><span class="line">            loop_(loop),</span><br><span class="line">            server_(loop, listenAddr, <span class="string">"ChatServer"</span>),</span><br><span class="line">            codec_(boost::bind(&amp;ChatServer::onStringMessage, <span class="keyword">this</span>, _1, _2, _3)) &#123;</span><br><span class="line">  </span><br><span class="line">        server_.setConnectionCallback(boost::bind(&amp;ChatServer::onConnection, <span class="keyword">this</span>, _1));</span><br><span class="line">        server_.setMessageCallback(boost::bind(&amp;LengthHeaderCodec::onMessage, &amp;codec_, _1, _2, _3));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        server_.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里有几点值得注意，<strong>在以往的代码里是直接把本 class 的 onMessage() 注册给 server_；这里我们把 LengthHeaderCodec::onMessage() 注册给 server_，然后向 codec_ 注册了 ChatServer::onStringMessage()，等于说让 codec_ 负责解析消息，然后把完整的消息回调给 ChatServer</strong>。这正是我前面提到的“一个简单的间接层”，在不增加 Muduo 库的复杂度的前提下，提供了足够的灵活性让我们在用户代码里完成需要的工作。</p>
<p>另外，<strong>server_.start() 绝对不能在构造函数里调用，这么做将来会有线程安全的问题</strong>，见我在《当析构函数遇到多线程 ── C++ 中线程安全的对象回调》一文中的论述。</p>
<p>以下是处理连接的建立和断开的代码，注意它把新建的连接加入到 connections_ 容器中，把已断开的连接从容器中删除。这么做是为了避免内存和资源泄漏，<strong>TcpConnectionPtr 是 boost::shared_ptr，是 muduo 里唯一一个默认采用 shared_ptr 来管理生命期的对象</strong>。以后我们会谈到这么做的原因。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn)</span> </span>&#123;</span><br><span class="line">        LOG_INFO &lt;&lt; conn-&gt;localAddress().toHostPort() &lt;&lt; <span class="string">" -&gt; "</span> &lt;&lt; conn-&gt;peerAddress().toHostPort() &lt;&lt; <span class="string">" is "</span> &lt;&lt; (conn-&gt;connected() ? <span class="string">"UP"</span> : <span class="string">"DOWN"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (conn-&gt;connected()) &#123;</span><br><span class="line">            connections_.insert(conn);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            connections_.erase(conn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>以下是服务端处理消息的代码，它遍历整个 connections_ 容器，把消息打包发送给各个客户连接。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onStringMessage</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp; message, Timestamp)</span> </span>&#123;</span><br><span class="line">    <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (ConnectionList::iterator it = connections_.begin(); it != connections_.end(); ++it) &#123; </span><br><span class="line">        codec_.send(get_pointer(*it), message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据成员：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">set</span> ConnectionList;</span><br><span class="line">EventLoop* loop_;</span><br><span class="line">TcpServer server_;</span><br><span class="line">LengthHeaderCodec codec_;</span><br><span class="line">MutexLock mutex_;</span><br><span class="line">ConnectionList connections_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>main() 函数里边是例行公事的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">"pid = "</span> &lt;&lt; getpid();</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        EventLoop loop;</span><br><span class="line">        <span class="keyword">uint16_t</span> port = <span class="keyword">static_cast</span>(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">        <span class="function">InetAddress <span class="title">serverAddr</span><span class="params">(port)</span></span>;</span><br><span class="line">        <span class="function">ChatServer <span class="title">server</span><span class="params">(&amp;loop, serverAddr)</span></span>;</span><br><span class="line">        server.start();</span><br><span class="line">        loop.loop();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage: %s port/n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你读过 asio 的对应代码，会不会觉得 Reactor 往往比 Proactor 容易使用？</p>
<h2 id="八、客户端的实现"><a href="#八、客户端的实现" class="headerlink" title="八、客户端的实现"></a>八、客户端的实现</h2><p>我有时觉得服务端的程序常常比客户端的更容易写，聊天服务器再次验证了我的看法。客户端的复杂性来自于它要读取键盘输入，而 EventLoop 是独占线程的，<strong>所以我用了两个线程，main() 函数所在的线程负责读键盘，另外用一个 EventLoopThread 来处理网络 IO</strong>。我暂时没有把标准输入输出融入 Reactor 的想法，因为服务器程序的 stdin 和 stdout 往往是重定向了的。</p>
<p>来看代码，首先，在构造函数里注册回调，并使用了跟前面一样的 LengthHeaderCodec <strong>作为中间层</strong>，负责打包分包。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"codec.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo::net;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChatClient</span> :</span> boost::noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ChatClient(EventLoop* loop, <span class="keyword">const</span> InetAddress&amp; listenAddr)</span><br><span class="line">            : loop_(loop),</span><br><span class="line">              client_(loop, listenAddr, <span class="string">"ChatClient"</span>),</span><br><span class="line">              codec_(boost::bind(&amp;ChatClient::onStringMessage, <span class="keyword">this</span>, _1, _2, _3)) &#123;</span><br><span class="line">        client_.setConnectionCallback(boost::bind(&amp;ChatClient::onConnection, <span class="keyword">this</span>, _1));</span><br><span class="line">        client_.setMessageCallback(boost::bind(&amp;LengthHeaderCodec::onMessage, &amp;codec_, _1, _2, _3));</span><br><span class="line">        client_.enableRetry();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        client_.connect();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>disconnect() 目前为空，客户端的连接由操作系统在进程终止时关闭。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disconnect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// client_.disconnect();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>write() 会由 main 线程调用，所以要加锁，这个锁不是为了保护 TcpConnection，而是保护 shared_ptr。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; message)</span> </span>&#123;</span><br><span class="line">    <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (connection_) &#123;</span><br><span class="line">        codec_.send(get_pointer(connection_), message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>onConnection() 会由 EventLoop 线程调用，所以要加锁以保护 shared_ptr。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp; conn)</span> </span>&#123;</span><br><span class="line">        LOG_INFO &lt;&lt; conn-&gt;localAddress().toHostPort() &lt;&lt; <span class="string">" -&gt; "</span> &lt;&lt; conn-&gt;peerAddress().toHostPort() &lt;&lt; <span class="string">" is "</span> &lt;&lt; (conn-&gt;connected() ? <span class="string">"UP"</span> : <span class="string">"DOWN"</span>);</span><br><span class="line">  </span><br><span class="line">        <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (conn-&gt;connected()) &#123;</span><br><span class="line">            connection_ = conn;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            connection_.reset();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>把收到的消息打印到屏幕，这个函数由 EventLoop 线程调用，但是不用加锁，因为 printf() 是线程安全的。<br><strong>注意这里不能用 cout，它不是线程安全的</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onStringMessage</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp; message, Timestamp)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&lt;&lt;&lt; %s/n"</span>, message.c_str());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据成员：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EventLoop* loop_;</span><br><span class="line">TcpClient client_;</span><br><span class="line">LengthHeaderCodec codec_;</span><br><span class="line">MutexLock mutex_;</span><br><span class="line">TcpConnectionPtr connection_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>main() 函数里除了例行公事，还要启动 EventLoop 线程和读取键盘输入。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">"pid = "</span> &lt;&lt; getpid();</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        EventLoopThread loopThread;</span><br><span class="line">        <span class="keyword">uint16_t</span> port = <span class="keyword">static_cast</span>(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">        <span class="function">InetAddress <span class="title">serverAddr</span><span class="params">(argv[<span class="number">1</span>], port)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function">ChatClient <span class="title">client</span><span class="params">(loopThread.startLoop(), serverAddr)</span></span>; <span class="comment">// 注册到 EventLoopThread 的 EventLoop 上。</span></span><br><span class="line">        client.connect();</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> line;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">std</span>::getline(<span class="built_in">std</span>::<span class="built_in">cin</span>, line)) &#123;</span><br><span class="line">            <span class="function"><span class="built_in">string</span> <span class="title">message</span><span class="params">(line.c_str())</span></span>; <span class="comment">// 这里似乎多此一举，可直接发送 line。这里是</span></span><br><span class="line">            client.write(message);</span><br><span class="line">        &#125;</span><br><span class="line">        client.disconnect();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage: %s host_ip port/n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="九、简单测试"><a href="#九、简单测试" class="headerlink" title="九、简单测试"></a>九、简单测试</h2><p>开三个命令行窗口，在第一个运行</p>
<p><code>$ ./asio_chat_server 3000</code></p>
<p>第二个运行</p>
<p><code>$ ./asio_chat_client 127.0.0.1 3000</code></p>
<p>第三个运行同样的命令</p>
<p><code>$ ./asio_chat_client 127.0.0.1 3000</code></p>
<p>这样就有两个客户端进程参与聊天。在第二个窗口里输入一些字符并回车，字符会出现在本窗口和第三个窗口中。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B%E4%B9%8B%E4%BA%8C%EF%BC%9ABoost.Asio%E7%9A%84%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/" data-id="ck7jw5i2d000ay4ve8q4nfd4z" class="article-share-link">分享到</a>
      

      
        <a href="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B%E4%B9%8B%E4%BA%8C%EF%BC%9ABoost.Asio%E7%9A%84%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Boost/" rel="tag">Boost</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cpp/" rel="tag">Cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Net/" rel="tag">Net</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%EF%BC%9A%E4%B8%80%E4%B8%AASudoku%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%BC%94%E5%8F%98/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">
        
          muduo 多线程模型：一个 Sudoku 服务器演变
        
      </div>
    </a>
  
  
    <a href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/%E4%B8%BA%E4%BB%80%E4%B9%88muduo%E7%9A%84shutdown()%E6%B2%A1%E6%9C%89%E7%9B%B4%E6%8E%A5%E5%85%B3%E9%97%ADTCP%E8%BF%9E%E6%8E%A5%EF%BC%9F/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">为什么 muduo 的 shutdown() 没有直接关闭 TCP 连接？</div>
    </a>
  
</nav>

  
</article>


  <section id="comments">
    <div id="ds-thread" class="ds-thread" data-thread-key="开源组件/muduo/muduo网络编程示例之二：Boost.Asio的聊天服务器/" data-title="muduo 网络编程示例之二： Boost.Asio 的聊天服务器" data-url="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B%E4%B9%8B%E4%BA%8C%EF%BC%9ABoost.Asio%E7%9A%84%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/"></div>
  </section>
</section>
      
      <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/">开源组件</a><span class="category-list-count">12</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/">muduo</a><span class="category-list-count">12</span></li></ul></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Boost/" rel="tag">Boost</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CMake/" rel="tag">CMake</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cpp/" rel="tag">Cpp</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IO/" rel="tag">IO</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Net/" rel="tag">Net</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reactor/" rel="tag">Reactor</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP/" rel="tag">TCP</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Boost/" style="font-size: 13.33px;">Boost</a> <a href="/tags/CMake/" style="font-size: 10px;">CMake</a> <a href="/tags/Cpp/" style="font-size: 20px;">Cpp</a> <a href="/tags/IO/" style="font-size: 13.33px;">IO</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Net/" style="font-size: 16.67px;">Net</a> <a href="/tags/Reactor/" style="font-size: 10px;">Reactor</a> <a href="/tags/TCP/" style="font-size: 13.33px;">TCP</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a><span class="archive-list-count">12</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%EF%BC%9A%E4%B8%80%E4%B8%AASudoku%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%BC%94%E5%8F%98/">muduo 多线程模型：一个 Sudoku 服务器演变</a>
          </li>
        
          <li>
            <a href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B%E4%B9%8B%E4%BA%8C%EF%BC%9ABoost.Asio%E7%9A%84%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/">muduo 网络编程示例之二： Boost.Asio 的聊天服务器</a>
          </li>
        
          <li>
            <a href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/%E4%B8%BA%E4%BB%80%E4%B9%88muduo%E7%9A%84shutdown()%E6%B2%A1%E6%9C%89%E7%9B%B4%E6%8E%A5%E5%85%B3%E9%97%ADTCP%E8%BF%9E%E6%8E%A5%EF%BC%9F/">为什么 muduo 的 shutdown() 没有直接关闭 TCP 连接？</a>
          </li>
        
          <li>
            <a href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B%E4%B9%8B%E4%B8%80%EF%BC%9A%E4%BA%94%E4%B8%AA%E7%AE%80%E5%8D%95TCP%E5%8D%8F%E8%AE%AE/">muduo 网络编程示例之一：五个简单 TCP 协议</a>
          </li>
        
          <li>
            <a href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E4%B8%AD%E7%9A%84net%E7%BB%84%E4%BB%B6/">muduo 中的 net 组件</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">友情链接</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="https://github.com/midudu" target="_blank">GitHub</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Midudu<br>
      Powered by <a href="//hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/xiangming/landscape-plus" target="_blank">Landscape-plus</a>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->

<!-- 多说公共js代码 start -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"midudu"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共js代码 end -->


<!-- 百度分享 start -->

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>




<! -- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
                processEscapes: true
                    
}
  
        });
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
                  
}
    
        });
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Queue(function() {
            var all = MathJax.Hub.getAllJax(), i;
            for(i=0; i < all.length; i += 1) {
                            all[i].SourceElement().parentNode.className += ' has-jax';
                                    
            }
                
        });
</script>

<script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



<script src="/js/script.js"></script>


</div>
</body>
</html>
