
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>muduo 多线程模型：一个 Sudoku 服务器演变 | Midudu&#39;s Home</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="原文链接 https:&#x2F;&#x2F;blog.csdn.net&#x2F;solstice&#x2F;article&#x2F;details&#x2F;6548228  本文以一个 Sudoku Solver 为例，回顾了并发网络服务程序的多种设计方案，并介绍了使用 muduo 网络库编写多线程服务器的两种最常用手法。以往的例子展现了 Muduo 在编写单线程并发网络服务程序方面的能力与便捷性，今天我们看一看它在多线程方面的表现。 本文代码见">
<meta property="og:type" content="article">
<meta property="og:title" content="muduo 多线程模型：一个 Sudoku 服务器演变">
<meta property="og:url" content="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%EF%BC%9A%E4%B8%80%E4%B8%AASudoku%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%BC%94%E5%8F%98/index.html">
<meta property="og:site_name" content="Midudu&#39;s Home">
<meta property="og:description" content="原文链接 https:&#x2F;&#x2F;blog.csdn.net&#x2F;solstice&#x2F;article&#x2F;details&#x2F;6548228  本文以一个 Sudoku Solver 为例，回顾了并发网络服务程序的多种设计方案，并介绍了使用 muduo 网络库编写多线程服务器的两种最常用手法。以往的例子展现了 Muduo 在编写单线程并发网络服务程序方面的能力与便捷性，今天我们看一看它在多线程方面的表现。 本文代码见">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/resources/%E5%8D%95%E7%BA%BF%E7%A8%8Breactor%E7%9A%84%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84.gif">
<meta property="og:image" content="http://yoursite.com/resources/%E4%B8%BB%E7%BA%BF%E7%A8%8Bio+%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E8%AE%A1%E7%AE%97gif.gif">
<meta property="og:image" content="http://yoursite.com/resources/mutiple_reactors.gif">
<meta property="og:image" content="http://yoursite.com/resources/multiple_reactors_with_thread_pool.gif">
<meta property="article:published_time" content="2020-03-09T03:01:57.280Z">
<meta property="article:modified_time" content="2020-03-09T03:02:43.000Z">
<meta property="article:author" content="Midudu">
<meta property="article:tag" content="Cpp">
<meta property="article:tag" content="Net">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/resources/%E5%8D%95%E7%BA%BF%E7%A8%8Breactor%E7%9A%84%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84.gif">
  
    <link rel="alternative" href="/atom.xml" title="Midudu&#39;s Home" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
<link rel="stylesheet" href="/css/style.css">

  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
<meta name="generator" content="Hexo 4.2.0"></head>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Midudu&#39;s Home</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="yoursite.com">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main"><article id="post-muduo多线程模型：一个Sudoku服务器演变" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%EF%BC%9A%E4%B8%80%E4%B8%AASudoku%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%BC%94%E5%8F%98/" class="article-date">
  <time datetime="2020-03-09T03:01:57.280Z" itemprop="datePublished">2020-03-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/">开源组件</a>►<a class="article-category-link" href="/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/">muduo</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      muduo 多线程模型：一个 Sudoku 服务器演变
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>原文链接 <a href="https://blog.csdn.net/solstice/article/details/6548228" target="_blank" rel="noopener">https://blog.csdn.net/solstice/article/details/6548228</a></p>
</blockquote>
<p>本文以一个 Sudoku Solver 为例，回顾了并发网络服务程序的多种设计方案，并介绍了使用 muduo 网络库编写<strong>多线程服务器</strong>的两种最常用手法。以往的例子展现了 Muduo 在编写单线程并发网络服务程序方面的能力与便捷性，今天我们看一看它在多线程方面的表现。</p>
<p>本文代码见：<a href="http://code.google.com/p/muduo/source/browse/trunk/examples/sudoku/" target="_blank" rel="noopener">http://code.google.com/p/muduo/source/browse/trunk/examples/sudoku/</a></p>
<p>下载：<a href="http://muduo.googlecode.com/files/muduo-0.2.5-alpha.tar.gz" target="_blank" rel="noopener">http://muduo.googlecode.com/files/muduo-0.2.5-alpha.tar.gz</a></p>
<p>关于数独的求解算法见 <a href="https://blog.csdn.net/Solstice/article/details/2096209" target="_blank" rel="noopener">https://blog.csdn.net/Solstice/article/details/2096209</a></p>
<ul>
<li><a href="#%e4%b8%80sudoku-solver">一、Sudoku Solver</a><ul>
<li><a href="#%e5%8d%8f%e8%ae%ae">协议</a></li>
<li><a href="#%e5%9f%ba%e6%9c%ac%e5%ae%9e%e7%8e%b0">基本实现</a></li>
</ul>
</li>
<li><a href="#%e4%ba%8c%e5%b8%b8%e8%a7%81%e7%9a%84%e5%b9%b6%e5%8f%91%e7%bd%91%e7%bb%9c%e6%9c%8d%e5%8a%a1%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%e6%96%b9%e6%a1%88">二、常见的并发网络服务程序设计方案</a></li>
<li><a href="#%e4%b8%89%e7%bb%93%e8%af%ad">三、结语</a></li>
<li><a href="#%e5%9b%9b%e4%bb%a3%e7%a0%81">四、代码</a><ul>
<li><a href="#%e6%96%b9%e6%a1%88-5%e5%8d%95%e7%ba%bf%e7%a8%8b-reactor">方案 5：单线程 Reactor</a></li>
<li><a href="#%e6%96%b9%e6%a1%88-8reactor--thread-pool">方案 8：Reactor + Thread Pool</a></li>
<li><a href="#%e6%96%b9%e6%a1%88-9multiple-reactors">方案 9：Multiple Reactors</a></li>
</ul>
</li>
</ul>
<h2 id="一、Sudoku-Solver"><a href="#一、Sudoku-Solver" class="headerlink" title="一、Sudoku Solver"></a>一、Sudoku Solver</h2><p>假设有这么一个网络编程任务：写一个求解数独的程序 (Sudoku Solver)，并把它做成一个网络服务。</p>
<p>Sudoku Solver 是我喜爱的网络编程例子，它曾经出现在《分布式系统部署、监控与进程管理的几重境界》、《Muduo 设计与实现之一：Buffer 类的设计》、《〈多线程服务器的适用场合〉例释与答疑》等文中，它也可以看成是 echo 服务的一个变种（《谈一谈网络编程学习经验》把 echo 列为三大 TCP 网络编程案例之一）。</p>
<p>写这么一个程序在网络编程方面的难度不高，跟写 echo 服务差不多（从网络连接读入一个 Sudoku 题目，算出答案，再发回给客户），挑战在于怎样做才能发挥现在多核硬件的能力？在谈这个问题之前，让我们先写一个基本的单线程版。</p>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>一个简单的以 /r/n 分隔的文本行协议，<strong>使用 TCP 长连接</strong>，<strong>客户端在不需要服务时主动断开连接</strong>。</p>
<p>请求：<code>[id:]〈81digits〉/r/n</code></p>
<p>响应：<code>[id:]〈81digits〉/r/n</code> 或者 <code>[id:]NoSolution/r/n</code></p>
<p>其中 <code>[id:]</code> 表示可选的 id，<strong>用于区分先后的请求</strong>，以支持 Parallel Pipelining，响应中会回显请求中的 id。Parallel Pipelining 的意义见赖勇浩的《以小见大——那些基于 protobuf 的五花八门的 RPC（2） 》，或者见我写的《分布式系统的工程化开发方法》第 54 页关于 out-of-order RPC 的介绍。</p>
<p>〈81digits〉是 Sudoku 的棋盘，9x9 个数字，未知数字以 0 表示。</p>
<p>如果 Sudoku 有解，那么响应是填满数字的棋盘；如果无解，则返回 NoSolution。</p>
<p><strong>例子1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">请求：000000010400000000020000000000050407008000300001090000300400200050100000000806000&#x2F;r&#x2F;n</span><br><span class="line"></span><br><span class="line">响应：693784512487512936125963874932651487568247391741398625319475268856129743274836159&#x2F;r&#x2F;n</span><br></pre></td></tr></table></figure>

<p><strong>例子2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">请求：a:000000010400000000020000000000050407008000300001090000300400200050100000000806000&#x2F;r&#x2F;n</span><br><span class="line"></span><br><span class="line">响应：a:693784512487512936125963874932651487568247391741398625319475268856129743274836159&#x2F;r&#x2F;n</span><br></pre></td></tr></table></figure>

<p><strong>例子3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">请求：b:000000010400000000020000000000050407008000300001090000300400200050100000000806005&#x2F;r&#x2F;n</span><br><span class="line"></span><br><span class="line">响应：b:NoSolution&#x2F;r&#x2F;n</span><br></pre></td></tr></table></figure>

<p>基于这个文本协议，我们可以用 <code>telnet</code> <strong>模拟客户端来测试</strong> sudoku solver，不需要单独编写 sudoku client。SudokuSolver 的默认端口号是 9981，因为它有 9x9=81 个格子。</p>
<h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><p>Sudoku 的求解算法见《谈谈数独(Sudoku)》一文，这不是本文的重点。假设我们已经有一个函数能求解 Sudoku，它的原型如下</p>
<p><code>string solveSudoku(const string&amp; puzzle);</code></p>
<p>函数的输入是上文的”〈81digits〉”，输出是”〈81digits〉”或”NoSolution”。这个函数是个 pure function，同时也是线程安全的。</p>
<p>有了这个函数，我们以《Muduo 网络编程示例之零：前言》中的 EchoServer 为蓝本，稍作修改就能得到 SudokuServer。这里只列出最关键的 onMessage() 函数，完整的代码见 <a href="http://code.google.com/p/muduo/source/browse/trunk/examples/sudoku/server_basic.cc" target="_blank" rel="noopener">http://code.google.com/p/muduo/source/browse/trunk/examples/sudoku/server_basic.cc</a> 。onMessage() 的主要功能是<strong>处理协议格式，并调用 solveSudoku() 求解问题</strong>。</p>
<p><code>server_basic.cc</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn, Buffer *buf, Timestamp)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    LOG_DEBUG &lt;&lt; conn-&gt;name();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">size_t</span> len = buf-&gt;readableBytes();</span><br><span class="line">    <span class="keyword">while</span> (len &gt;= kCells + <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *crlf = buf-&gt;findCRLF();</span><br><span class="line">        <span class="keyword">if</span> (crlf) &#123;</span><br><span class="line">            <span class="function"><span class="built_in">string</span> <span class="title">request</span><span class="params">(buf-&gt;peek(), crlf)</span></span>;</span><br><span class="line">            buf-&gt;retrieveUntil(crlf + <span class="number">2</span>);</span><br><span class="line">            len = buf-&gt;readableBytes();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!processRequest(conn, request)) &#123;</span><br><span class="line">                conn-&gt;send(<span class="string">"Bad Request!\r\n"</span>);</span><br><span class="line">                conn-&gt;shutdown();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; <span class="number">100</span>) &#123;</span><br><span class="line">            conn-&gt;send(<span class="string">"Id too long!\r\n"</span>);</span><br><span class="line">            conn-&gt;shutdown();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>server_basic.cc 是一个<strong>并发服务器</strong>，可以同时服务多个客户连接。<strong>但是它是单线程的</strong>，无法发挥多核硬件的能力。</p>
<p>Sudoku 是一个<strong>计算密集型</strong>的任务（见《Muduo 设计与实现之一：Buffer 类的设计》中关于其性能的分析），其瓶颈在 CPU。为了让这个单线程 server_basic 程序充分利用 CPU 资源，一个简单的办法是在同一台机器上部署多个 server_basic 进程，让每个进程占用不同的端口，比如在一台 8 核机器上部署 8 个 server_basic 进程，分别占用 9981、9982、……、9988 端口。这样做其实是把难题推给了客户端，因为客户端(s)要自己做负载均衡。再想得远一点，在 8 个 server_basic 前面部署一个 load balancer？似乎小题大做了。</p>
<p>能不能在一个端口上提供服务，并且又能发挥多核处理器的计算能力呢？当然可以，办法不止一种。</p>
<h2 id="二、常见的并发网络服务程序设计方案"><a href="#二、常见的并发网络服务程序设计方案" class="headerlink" title="二、常见的并发网络服务程序设计方案"></a>二、常见的并发网络服务程序设计方案</h2><p>W. Richard Stevens 的 UNP2e 第 27 章 Client-Server Design Alternatives 介绍了十来种当时（90 年代末）流行的编写并发网络程序的方案。UNP3e 第 30 章，内容未变，还是这几种。以下简称 UNP CSDA 方案。UNP 这本书主要讲解阻塞式网络编程，在非阻塞方面着墨不多，仅有一章。正确使用 non-blocking IO 需要考虑的问题很多，不适宜直接调用 Sockets API，而需要一个功能完善的网络库支撑。</p>
<p>随着 2000 年前后第一次互联网浪潮的兴起，业界对高并发 http 服务器的强烈需求大大推动了这一领域的研究，<strong>目前高性能 httpd 普遍采用的是单线程 reactor 方式</strong>。另外一个说法是 IBM Lotus 使用 TCP 长连接协议，而把 Lotus 服务端移植到 Linux 的过程中 IBM 的工程师们大大提高了 Linux 内核在处理并发连接方面的可伸缩性，因为一个公司可能有上万人同时上线，连接到同一台跑着 Lotus server 的 Linux 服务器。</p>
<p>可伸缩网络编程这个领域其实近十年来没什么新东西，POSA2 已经作了相当全面的总结，另外以下几篇文章也值得参考。</p>
<p><a href="http://bulk.fefe.de/scalable-networking.pdf" target="_blank" rel="noopener">http://bulk.fefe.de/scalable-networking.pdf</a></p>
<p><a href="http://www.kegel.com/c10k.html" target="_blank" rel="noopener">http://www.kegel.com/c10k.html</a></p>
<p><a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf" target="_blank" rel="noopener">http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf</a></p>
<p>下表是陈硕总结的 10 种常见方案。其中“<strong>多连接互通</strong>”指的是如果开发 chat 服务，多个客户连接之间是否能方便地交换数据（chat 也是《谈一谈网络编程学习经验》中举的三大 TCP 网络编程案例之一）。对于 echo/http/sudoku 这类“连接相互独立”的服务程序，这个功能无足轻重，但是对于 chat 类服务至关重要。“<strong>顺序性</strong>”指的是在 http/sudoku 这类请求-响应服务中，如果客户连接顺序发送多个请求，那么计算得到的多个响应是否按相同的顺序发还给客户（这里指的是在自然条件下，不含刻意同步）。</p>
<table>
<thead>
<tr>
<th align="center">方案</th>
<th align="center">model</th>
<th align="center">UNP 对应</th>
<th align="center">阻塞/非阻塞</th>
<th align="center">多进程？</th>
<th align="center">多线程？</th>
<th align="center">IO 复用？</th>
<th align="center">长连接？</th>
<th align="center">并发性</th>
<th align="center">多核？</th>
<th align="center">开销</th>
<th align="center">多连接互通？</th>
<th align="center">顺序性</th>
<th align="center">线程数确定？</th>
<th align="center">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">accept + read/write</td>
<td align="center">0</td>
<td align="center">阻塞</td>
<td align="center">no</td>
<td align="center">no</td>
<td align="center">no</td>
<td align="center">no</td>
<td align="center">无</td>
<td align="center">no</td>
<td align="center">低</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">一次服务一个客户</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">accept + fork</td>
<td align="center">1</td>
<td align="center">阻塞</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">低</td>
<td align="center">yes</td>
<td align="center">高</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">process-per-connection</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">accept + thread</td>
<td align="center">6</td>
<td align="center">阻塞</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">中</td>
<td align="center">yes</td>
<td align="center">中</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">thread-per-connection</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">prefork</td>
<td align="center">2/3/4/5</td>
<td align="center">阻塞</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">低</td>
<td align="center">yes</td>
<td align="center">高</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">见 UNP</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">pre threaded</td>
<td align="center">7/8</td>
<td align="center">阻塞</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">中</td>
<td align="center">yes</td>
<td align="center">中</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">见 UNP</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">poll(reactor)</td>
<td align="center">sec 6.8</td>
<td align="center">非阻塞</td>
<td align="center">no</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">高</td>
<td align="center">no</td>
<td align="center">低</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">单线程 reactor</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">reactor + thread-per-task</td>
<td align="center">无</td>
<td align="center">非阻塞</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">中</td>
<td align="center">yes</td>
<td align="center">中</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">no</td>
<td align="center">thread-per-request</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">reactor + worker thread</td>
<td align="center">无</td>
<td align="center">非阻塞</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">中</td>
<td align="center">yes</td>
<td align="center">中</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">worker-thread-per-connection</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">reactor + thread pool</td>
<td align="center">无</td>
<td align="center">非阻塞</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">高</td>
<td align="center">yes</td>
<td align="center">低</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">主线程 io + 工作线程计算</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">multiple reactors</td>
<td align="center">无</td>
<td align="center">非阻塞</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">高</td>
<td align="center">yes</td>
<td align="center">低</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">one-loop-per-thread</td>
</tr>
</tbody></table>
<p>UNP CSDA 方案归入 0~5。5 也是目前用得很多的单线程 reactor 方案，muduo 对此提供了很好的支持。6 和 7 其实不是实用的方案，只是作为过渡品。8 和 9 是本文重点介绍的方案，其实这两个方案已经在《多线程服务器的常用编程模型》一文中提到过，只不过当时我还没有写 muduo，无法用具体的代码示例来说明。</p>
<p>在对比各方案之前，我们先看看基本的 micro benchmark 数据（前三项由 lmbench 测得）：</p>
<ul>
<li>fork()+exit(): 160us</li>
<li>pthread_create()+pthread_join(): 12us</li>
<li>context switch : 1.5us</li>
<li>sudoku resolve: 100us (根据题目难度不同，浮动范围 20~200us)</li>
</ul>
<p>接下来看一下几种方案：</p>
<ul>
<li><p><strong>方案 0</strong>：这其实不是并发服务器，而是 iterative 服务器，因为它一次只能服务一个客户。代码见 UNP figure 1.9，UNP 以此为对比其他方案的基准点。这个方案不适合长连接，到是很适合 daytime 这种 write-only 服务。</p>
</li>
<li><p><strong>方案 1</strong>：这是传统的 Unix 并发网络编程方案，UNP 称之为 child-per-client 或 fork()-per-client，另外也俗称 process-per-connection。这种方案适合并发连接数不大的情况。至今仍有一些网络服务程序用这种方式实现，比如 PostgreSQL 和 Perforce 的服务端。<strong>这种方案适合“计算响应的工作量远大于 fork() 的开销”这种情况</strong>，比如数据库服务器。这种方案适合长连接，但不太适合短连接，因为 fork() 开销大于求解 sudoku 的用时。</p>
</li>
<li><p><strong>方案 2</strong>：<strong>这是传统的 Java 网络编程方案</strong> thread-per-connection，在 Java 1.4 引入 NIO 之前，Java 网络服务程序多采用这种方案。它的初始化开销比方案 1 要小很多。这种方案的伸缩性受到线程数的限制，一两百个还行，几千个的话对操作系统的 scheduler 恐怕是个不小的负担。</p>
</li>
<li><p><strong>方案 3</strong>：这是针对方案 1 的优化，UNP 详细分析了几种变化，包括对 accept 惊群问题的考虑。</p>
</li>
<li><p><strong>方案 4</strong>：这是对方案 2 的优化，UNP 详细分析了它的几种变化。</p>
</li>
</ul>
<p>以上几种方案都是<strong>阻塞式网络编程</strong>，程序（thread-of-control）通常<strong>阻塞在 read() 上</strong>，等待数据到达。但是 TCP 是个全双工协议，同时支持 read() 和 write() 操作，当一个线程/进程阻塞在 read() 上，但程序又想给这个 TCP 连接发数据，那该怎么办？比如说 echo client，既要从 stdin 读，又要从网络读，当程序正在阻塞地读网络的时候，如何处理键盘输入？又比如 proxy，既要把连接 a 收到的数据发给连接 b，又要把从连接 b 收到的数据发给连接 a，那么到底读哪个？（proxy 是《谈一谈网络编程学习经验》中举的三大 TCP 网络编程案例之一。）</p>
<p><strong>一种方法</strong>是用两个线程/进程，一个负责读，一个负责写。UNP 也在实现 echo client 时介绍了这种方案。另外见 Python Pinhole 的代码：<a href="http://code.activestate.com/recipes/114642/" target="_blank" rel="noopener">http://code.activestate.com/recipes/114642/</a></p>
<p>((另一种方法))是使用 <code>IO multiplexing</code>，也就是 select/poll/epoll/kqueue 这一系列的“多路选择器”，让一个 thread-of-control 能处理多个连接。“IO 复用”其实复用的不是 IO 连接，而是复用线程。<strong>使用 select/poll 几乎肯定要配合 non-blocking IO，而使用 non-blocking IO 肯定要使用应用层 buffer</strong>，原因见《Muduo 设计与实现之一：Buffer 类的设计》。这就不是一件轻松的事儿了，如果每个程序都去搞一套自己的 IO multiplexing 机制（本质是 event-driven 事件驱动），这是一种很大的浪费。感谢 Doug Schmidt 为我们总结出了 <code>Reactor</code> 模式，让 event-driven 网络编程有章可循。继而出现了一些通用的 reactor 框架/库，比如 libevent、muduo、Netty、twisted、POE 等等，有了这些库，我想基本不用去编写阻塞式的网络程序了（特殊情况除外，比如 proxy 流量限制）。</p>
<p>单线程 reactor 的程序结构是（图片取自 Doug Lea 的演讲）：</p>
<p><img src="/resources/%E5%8D%95%E7%BA%BF%E7%A8%8Breactor%E7%9A%84%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84.gif" alt="单线程 reactor 的程序结构"></p>
<ul>
<li><p><strong>方案 5</strong>：基本的单线程 reactor 方案，即前面的 server_basic.cc 程序。本文以它作为对比其他方案的基准点。这种方案的优点是由网络库搞定数据收发，程序只关心业务逻辑；缺点在前面已经谈了：适合 IO 密集的应用，不太适合 CPU 密集的应用，因为较难发挥多核的威力。</p>
</li>
<li><p><strong>方案 6</strong>：这是一个过渡方案，收到 Sudoku 请求之后，不在 reactor 线程计算，而是创建一个新线程去计算，以充分利用多核 CPU。这是非常初级的多线程应用，<strong>因为它为每个请求（而不是每个连接）创建了一个新线程</strong>。这个开销可以用线程池来避免，即方案 8。这个方案还有一个特点是 out-of-order，即同时创建多个线程去计算同一个连接上收到的多个请求，那么算出结果的次序是不确定的，可能第 2 个 Sudoku 比较简单，比第 1 个先算出结果。这也是为什么我们在一开始设计协议的时候使用了 id，以便客户端区分 response 对应的是哪个 request。</p>
</li>
<li><p><strong>方案 7</strong>：为了让返回结果的顺序确定，我们可以<strong>为每个连接创建一个计算线程，每个连接上的请求固定发给同一个线程去算，先到先得</strong>。这也是一个过渡方案，因为并发连接数受限于线程数目，这个方案或许还不如直接使用阻塞 IO 的 thread-per-connection 方案2。方案 7 与方案 6 的另外一个区别是一个 client 的最大 CPU 占用率，在方案 6 中，一个 connection 上发来的一长串突发请求(burst requests) 可以占满全部 8 个 core；而在方案 7 中，由于每个连接上的请求固定由同一个线程处理，那么它最多占用 12.5% 的 CPU 资源。这两种方案各有优劣，取决于应用场景的需要，到底是<strong>公平性</strong>重要还是<strong>突发性能</strong>重要。这个区别在方案 8 和方案 9 中同样存在，需要根据应用来取舍。</p>
</li>
<li><p><strong>方案 8</strong>：为了弥补方案 6 中为每个请求创建线程的缺陷，我们使用固定大小线程池，程序结构如下图。全部的 IO 工作都在一个 reactor 线程完成，而计算任务交给 thread pool。如果计算任务彼此独立，而且 IO 的压力不大，那么这种方案是非常适用的。Sudoku Solver 正好符合。代码见：<a href="http://code.google.com/p/muduo/source/browse/trunk/examples/sudoku/server_threadpool.cc" target="_blank" rel="noopener">http://code.google.com/p/muduo/source/browse/trunk/examples/sudoku/server_threadpool.cc</a> 后文给出了它与方案 9 的区别。</p>
</li>
</ul>
<p><img src="/resources/%E4%B8%BB%E7%BA%BF%E7%A8%8Bio+%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E8%AE%A1%E7%AE%97gif.gif" alt="主线程 io + 工作线程计算"></p>
<p>如果 IO 的压力比较大，一个 reactor 忙不过来，可以试试 multiple reactors 的方案 9。</p>
<ul>
<li><strong>方案 9</strong>：<strong>这是 muduo 内置的多线程方案</strong>，也是 Netty 内置的多线程方案。这种方案的特点是 one loop per thread，<strong>有一个 main reactor 负责 accept 连接，然后把连接挂在某个 sub reactor 中</strong>（muduo 采用 round-robin 的方式来选择 sub reactor），这样该连接的所有操作都在那个 sub reactor 所处的线程中完成。多个连接可能被分派到多个线程中，以充分利用 CPU。Muduo 采用的是固定大小的 reactor pool，池子的大小通常根据 CPU 核数确定，也就是说线程数是固定的，这样程序的总体处理能力不会随连接数增加而下降。另外，由于一个连接完全由一个线程管理，那么请求的顺序性有保证，突发请求也不会占满全部 8 个核（如果需要优化突发请求，可以考虑方案 10）。这种方案把 IO 分派给多个线程，防止出现一个 reactor 的处理能力饱和。与方案 8 的线程池相比，方案 9 减少了进出 thread pool 的两次上下文切换。我认为这是一个适应性很强的多线程 IO 模型，因此把它作为 muduo 的默认线程模型。</li>
</ul>
<p><img src="/resources/mutiple_reactors.gif" alt="Multiple Reactors"></p>
<ul>
<li><strong>方案 10</strong>：把方案 8 和方案 90 混合，既使用多个 reactors 来处理 IO，又使用线程池来处理计算。这种方案适合既有突发 IO （利用多线程处理多个连接上的 IO），又有突发计算的应用（利用线程池把一个连接上的计算任务分配给多个线程去做）。</li>
</ul>
<p><img src="/resources/multiple_reactors_with_thread_pool.gif" alt="Multiple Reactors With Thread Pool"></p>
<p>这种其实方案看起来复杂，<strong>其实写起来很简单，只要把方案 8 的代码加一行 server_.setThreadNum(numThreads); 就行</strong>，这里就不举例了。</p>
<h2 id="三、结语"><a href="#三、结语" class="headerlink" title="三、结语"></a>三、结语</h2><p>我在《多线程服务器的常用编程模型》一文中说</p>
<p>总结起来，我推荐的多线程服务端编程模式为：event loop per thread + thread pool。</p>
<p>event loop 用作 non-blocking IO 和定时器。<br>thread pool 用来做计算，具体可以是任务队列或消费者-生产者队列。</p>
<p>当时（2010年2月）我还说“以这种方式写服务器程序，需要一个优质的基于 Reactor 模式的网络库来支撑，我只用过in-house的产品，无从比较并推荐市面上常见的 C++ 网络库，抱歉。”</p>
<p>现在有了 muduo 网络库，我终于能够用具体的代码示例把思想完整地表达出来。</p>
<h2 id="四、代码"><a href="#四、代码" class="headerlink" title="四、代码"></a>四、代码</h2><h3 id="方案-5：单线程-Reactor"><a href="#方案-5：单线程-Reactor" class="headerlink" title="方案 5：单线程 Reactor"></a>方案 5：单线程 Reactor</h3><p><code>server_basic.cc</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SudokuServer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SudokuServer(EventLoop *loop, <span class="keyword">const</span> InetAddress &amp;listenAddr)</span><br><span class="line">            : server_(loop, listenAddr, <span class="string">"SudokuServer"</span>),</span><br><span class="line">              startTime_(Timestamp::now()) &#123;</span><br><span class="line">        server_.setConnectionCallback(</span><br><span class="line">                <span class="built_in">std</span>::bind(&amp;SudokuServer::onConnection, <span class="keyword">this</span>, _1));</span><br><span class="line">        server_.setMessageCallback(</span><br><span class="line">                <span class="built_in">std</span>::bind(&amp;SudokuServer::onMessage, <span class="keyword">this</span>, _1, _2, _3));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        server_.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn, Buffer *buf, Timestamp)</span> </span>&#123;</span><br><span class="line">        LOG_DEBUG &lt;&lt; conn-&gt;name();</span><br><span class="line">        <span class="keyword">size_t</span> len = buf-&gt;readableBytes();</span><br><span class="line">        <span class="keyword">while</span> (len &gt;= kCells + <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *crlf = buf-&gt;findCRLF();</span><br><span class="line">            <span class="keyword">if</span> (crlf) &#123;</span><br><span class="line">                <span class="function"><span class="built_in">string</span> <span class="title">request</span><span class="params">(buf-&gt;peek(), crlf)</span></span>;</span><br><span class="line">                buf-&gt;retrieveUntil(crlf + <span class="number">2</span>);</span><br><span class="line">                len = buf-&gt;readableBytes();</span><br><span class="line">                <span class="keyword">if</span> (!processRequest(conn, request)) &#123;</span><br><span class="line">                    conn-&gt;send(<span class="string">"Bad Request!\r\n"</span>);</span><br><span class="line">                    conn-&gt;shutdown();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; <span class="number">100</span>) <span class="comment">// id + ":" + kCells + "\r\n"</span></span><br><span class="line">            &#123;</span><br><span class="line">                conn-&gt;send(<span class="string">"Id too long!\r\n"</span>);</span><br><span class="line">                conn-&gt;shutdown();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">processRequest</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn, <span class="keyword">const</span> <span class="built_in">string</span> &amp;request)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> id;</span><br><span class="line">        <span class="built_in">string</span> puzzle;</span><br><span class="line">        <span class="keyword">bool</span> goodRequest = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span>::const_iterator colon = find(request.begin(), request.end(), <span class="string">':'</span>);</span><br><span class="line">        <span class="keyword">if</span> (colon != request.end()) &#123;</span><br><span class="line">            id.assign(request.begin(), colon);</span><br><span class="line">            puzzle.assign(colon + <span class="number">1</span>, request.end());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            puzzle = request;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (puzzle.size() == implicit_cast&lt;<span class="keyword">size_t</span>&gt;(kCells)) &#123;</span><br><span class="line">            LOG_DEBUG &lt;&lt; conn-&gt;name();</span><br><span class="line">            <span class="built_in">string</span> result = solveSudoku(puzzle);</span><br><span class="line">            <span class="keyword">if</span> (id.empty()) &#123;</span><br><span class="line">                conn-&gt;send(result + <span class="string">"\r\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                conn-&gt;send(id + <span class="string">":"</span> + result + <span class="string">"\r\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            goodRequest = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> goodRequest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TcpServer server_;</span><br><span class="line">    Timestamp startTime_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="方案-8：Reactor-Thread-Pool"><a href="#方案-8：Reactor-Thread-Pool" class="headerlink" title="方案 8：Reactor + Thread Pool"></a>方案 8：Reactor + Thread Pool</h3><p><code>server_threadpool.cc</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SudokuServer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SudokuServer(EventLoop *loop, <span class="keyword">const</span> InetAddress &amp;listenAddr, <span class="keyword">int</span> numThreads)</span><br><span class="line">            : server_(loop, listenAddr, <span class="string">"SudokuServer"</span>),</span><br><span class="line">              numThreads_(numThreads),</span><br><span class="line">              startTime_(Timestamp::now()) &#123;</span><br><span class="line"></span><br><span class="line">        server_.setConnectionCallback(</span><br><span class="line">                <span class="built_in">std</span>::bind(&amp;SudokuServer::onConnection, <span class="keyword">this</span>, _1));</span><br><span class="line">        server_.setMessageCallback(</span><br><span class="line">                <span class="built_in">std</span>::bind(&amp;SudokuServer::onMessage, <span class="keyword">this</span>, _1, _2, _3));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LOG_INFO &lt;&lt; <span class="string">"starting "</span> &lt;&lt; numThreads_ &lt;&lt; <span class="string">" threads."</span>;</span><br><span class="line">        threadPool_.start(numThreads_);</span><br><span class="line">        server_.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn, Buffer *buf, Timestamp)</span> </span>&#123;</span><br><span class="line">        LOG_DEBUG &lt;&lt; conn-&gt;name();</span><br><span class="line">        <span class="keyword">size_t</span> len = buf-&gt;readableBytes();</span><br><span class="line">        <span class="keyword">while</span> (len &gt;= kCells + <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *crlf = buf-&gt;findCRLF();</span><br><span class="line">            <span class="keyword">if</span> (crlf) &#123;</span><br><span class="line">                <span class="function"><span class="built_in">string</span> <span class="title">request</span><span class="params">(buf-&gt;peek(), crlf)</span></span>;</span><br><span class="line">                buf-&gt;retrieveUntil(crlf + <span class="number">2</span>);</span><br><span class="line">                len = buf-&gt;readableBytes();</span><br><span class="line">                <span class="keyword">if</span> (!processRequest(conn, request)) &#123;</span><br><span class="line">                    conn-&gt;send(<span class="string">"Bad Request!\r\n"</span>);</span><br><span class="line">                    conn-&gt;shutdown();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; <span class="number">100</span>) &#123;</span><br><span class="line">                conn-&gt;send(<span class="string">"Id too long!\r\n"</span>);</span><br><span class="line">                conn-&gt;shutdown();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">processRequest</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn, <span class="keyword">const</span> <span class="built_in">string</span> &amp;request)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> id;</span><br><span class="line">        <span class="built_in">string</span> puzzle;</span><br><span class="line">        <span class="keyword">bool</span> goodRequest = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span>::const_iterator colon = find(request.begin(), request.end(), <span class="string">':'</span>);</span><br><span class="line">        <span class="keyword">if</span> (colon != request.end()) &#123;</span><br><span class="line">            id.assign(request.begin(), colon);</span><br><span class="line">            puzzle.assign(colon + <span class="number">1</span>, request.end());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            puzzle = request;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (puzzle.size() == implicit_cast&lt;<span class="keyword">size_t</span>&gt;(kCells)) &#123;</span><br><span class="line">            threadPool_.run(<span class="built_in">std</span>::bind(&amp;solve, conn, puzzle, id));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            goodRequest = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> goodRequest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> <span class="built_in">string</span> &amp;puzzle,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> <span class="built_in">string</span> &amp;id)</span> </span>&#123;</span><br><span class="line">        LOG_DEBUG &lt;&lt; conn-&gt;name();</span><br><span class="line">        <span class="built_in">string</span> result = solveSudoku(puzzle);</span><br><span class="line">        <span class="keyword">if</span> (id.empty()) &#123;</span><br><span class="line">            conn-&gt;send(result + <span class="string">"\r\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            conn-&gt;send(id + <span class="string">":"</span> + result + <span class="string">"\r\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TcpServer server_;</span><br><span class="line">    ThreadPool threadPool_;</span><br><span class="line">    <span class="keyword">int</span> numThreads_;</span><br><span class="line">    Timestamp startTime_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="方案-9：Multiple-Reactors"><a href="#方案-9：Multiple-Reactors" class="headerlink" title="方案 9：Multiple Reactors"></a>方案 9：Multiple Reactors</h3><p><code>server_multiloop.cc</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SudokuServer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SudokuServer(EventLoop *loop, <span class="keyword">const</span> InetAddress &amp;listenAddr, <span class="keyword">int</span> numThreads)</span><br><span class="line">            : server_(loop, listenAddr, <span class="string">"SudokuServer"</span>),</span><br><span class="line">              numThreads_(numThreads),</span><br><span class="line">              startTime_(Timestamp::now()) &#123;</span><br><span class="line"></span><br><span class="line">        server_.setConnectionCallback(</span><br><span class="line">                <span class="built_in">std</span>::bind(&amp;SudokuServer::onConnection, <span class="keyword">this</span>, _1));</span><br><span class="line">        server_.setMessageCallback(</span><br><span class="line">                <span class="built_in">std</span>::bind(&amp;SudokuServer::onMessage, <span class="keyword">this</span>, _1, _2, _3));</span><br><span class="line">        server_.setThreadNum(numThreads);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LOG_INFO &lt;&lt; <span class="string">"starting "</span> &lt;&lt; numThreads_ &lt;&lt; <span class="string">" threads."</span>;</span><br><span class="line">        server_.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn, Buffer *buf, Timestamp)</span> </span>&#123;</span><br><span class="line">        LOG_DEBUG &lt;&lt; conn-&gt;name();</span><br><span class="line">        <span class="keyword">size_t</span> len = buf-&gt;readableBytes();</span><br><span class="line">        <span class="keyword">while</span> (len &gt;= kCells + <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *crlf = buf-&gt;findCRLF();</span><br><span class="line">            <span class="keyword">if</span> (crlf) &#123;</span><br><span class="line">                <span class="function"><span class="built_in">string</span> <span class="title">request</span><span class="params">(buf-&gt;peek(), crlf)</span></span>;</span><br><span class="line">                buf-&gt;retrieveUntil(crlf + <span class="number">2</span>);</span><br><span class="line">                len = buf-&gt;readableBytes();</span><br><span class="line">                <span class="keyword">if</span> (!processRequest(conn, request)) &#123;</span><br><span class="line">                    conn-&gt;send(<span class="string">"Bad Request!\r\n"</span>);</span><br><span class="line">                    conn-&gt;shutdown();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; <span class="number">100</span>) &#123;</span><br><span class="line">                conn-&gt;send(<span class="string">"Id too long!\r\n"</span>);</span><br><span class="line">                conn-&gt;shutdown();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">processRequest</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn, <span class="keyword">const</span> <span class="built_in">string</span> &amp;request)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> id;</span><br><span class="line">        <span class="built_in">string</span> puzzle;</span><br><span class="line">        <span class="keyword">bool</span> goodRequest = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span>::const_iterator colon = find(request.begin(), request.end(), <span class="string">':'</span>);</span><br><span class="line">        <span class="keyword">if</span> (colon != request.end()) &#123;</span><br><span class="line">            id.assign(request.begin(), colon);</span><br><span class="line">            puzzle.assign(colon + <span class="number">1</span>, request.end());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            puzzle = request;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (puzzle.size() == implicit_cast&lt;<span class="keyword">size_t</span>&gt;(kCells)) &#123;</span><br><span class="line">            LOG_DEBUG &lt;&lt; conn-&gt;name();</span><br><span class="line">            <span class="built_in">string</span> result = solveSudoku(puzzle);</span><br><span class="line">            <span class="keyword">if</span> (id.empty()) &#123;</span><br><span class="line">                conn-&gt;send(result + <span class="string">"\r\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                conn-&gt;send(id + <span class="string">":"</span> + result + <span class="string">"\r\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            goodRequest = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> goodRequest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TcpServer server_;</span><br><span class="line">    <span class="keyword">int</span> numThreads_;</span><br><span class="line">    Timestamp startTime_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%EF%BC%9A%E4%B8%80%E4%B8%AASudoku%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%BC%94%E5%8F%98/" data-id="ck7jw5i2e000by4vehp6fgen2" class="article-share-link">分享到</a>
      

      
        <a href="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%EF%BC%9A%E4%B8%80%E4%B8%AASudoku%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%BC%94%E5%8F%98/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cpp/" rel="tag">Cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Net/" rel="tag">Net</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B%E4%B9%8B%E4%BA%8C%EF%BC%9ABoost.Asio%E7%9A%84%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">muduo 网络编程示例之二： Boost.Asio 的聊天服务器</div>
    </a>
  
</nav>

  
</article>


  <section id="comments">
    <div id="ds-thread" class="ds-thread" data-thread-key="开源组件/muduo/muduo多线程模型：一个Sudoku服务器演变/" data-title="muduo 多线程模型：一个 Sudoku 服务器演变" data-url="http://yoursite.com/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%EF%BC%9A%E4%B8%80%E4%B8%AASudoku%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%BC%94%E5%8F%98/"></div>
  </section>
</section>
      
      <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/">开源组件</a><span class="category-list-count">12</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/">muduo</a><span class="category-list-count">12</span></li></ul></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Boost/" rel="tag">Boost</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CMake/" rel="tag">CMake</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cpp/" rel="tag">Cpp</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IO/" rel="tag">IO</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Net/" rel="tag">Net</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Reactor/" rel="tag">Reactor</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP/" rel="tag">TCP</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Boost/" style="font-size: 13.33px;">Boost</a> <a href="/tags/CMake/" style="font-size: 10px;">CMake</a> <a href="/tags/Cpp/" style="font-size: 20px;">Cpp</a> <a href="/tags/IO/" style="font-size: 13.33px;">IO</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Net/" style="font-size: 16.67px;">Net</a> <a href="/tags/Reactor/" style="font-size: 10px;">Reactor</a> <a href="/tags/TCP/" style="font-size: 13.33px;">TCP</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a><span class="archive-list-count">12</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%EF%BC%9A%E4%B8%80%E4%B8%AASudoku%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%BC%94%E5%8F%98/">muduo 多线程模型：一个 Sudoku 服务器演变</a>
          </li>
        
          <li>
            <a href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B%E4%B9%8B%E4%BA%8C%EF%BC%9ABoost.Asio%E7%9A%84%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/">muduo 网络编程示例之二： Boost.Asio 的聊天服务器</a>
          </li>
        
          <li>
            <a href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/%E4%B8%BA%E4%BB%80%E4%B9%88muduo%E7%9A%84shutdown()%E6%B2%A1%E6%9C%89%E7%9B%B4%E6%8E%A5%E5%85%B3%E9%97%ADTCP%E8%BF%9E%E6%8E%A5%EF%BC%9F/">为什么 muduo 的 shutdown() 没有直接关闭 TCP 连接？</a>
          </li>
        
          <li>
            <a href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B%E4%B9%8B%E4%B8%80%EF%BC%9A%E4%BA%94%E4%B8%AA%E7%AE%80%E5%8D%95TCP%E5%8D%8F%E8%AE%AE/">muduo 网络编程示例之一：五个简单 TCP 协议</a>
          </li>
        
          <li>
            <a href="/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/muduo/muduo%E4%B8%AD%E7%9A%84net%E7%BB%84%E4%BB%B6/">muduo 中的 net 组件</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">友情链接</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="https://github.com/midudu" target="_blank">GitHub</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Midudu<br>
      Powered by <a href="//hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/xiangming/landscape-plus" target="_blank">Landscape-plus</a>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->

<!-- 多说公共js代码 start -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"midudu"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共js代码 end -->


<!-- 百度分享 start -->

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>




<! -- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
                processEscapes: true
                    
}
  
        });
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
                  
}
    
        });
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Queue(function() {
            var all = MathJax.Hub.getAllJax(), i;
            for(i=0; i < all.length; i += 1) {
                            all[i].SourceElement().parentNode.className += ' has-jax';
                                    
            }
                
        });
</script>

<script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



<script src="/js/script.js"></script>


</div>
</body>
</html>
